---
title: "Feature production markdown for Detecting Postural Instability in Parkinson's Disease from IMU-based Objective Measures"
subtitle: "Feature Production"
author: "Kendal Raymond William Smith <ksmi3341@alumni.sydney.edu.au>"
date: "`r Sys.Date()`"
output:
  pdf_document:
    number_sections: no
    toc: no
    keep_tex: yes
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '3'
fontsize: 10pt
editor_options: 
  chunk_output_type: inline
geometry: "left=2.5cm,right=2.5cm,top=2.05cm,bottom=2.5cm"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setup

```{r libraries, include=FALSE}
# Install any needed package
if (!require(tidyverse)) install.packages("tidyverse")
if (!require(signal)) install.packages("signal")
if (!require(pracma)) install.packages("pracma")
if (!require(mgcv)) install.packages("mgcv")
if (!require(entropy)) install.packages("entropy")
if (!require(Hmisc)) install.packages("Hmisc")
if (!require(zoo)) install.packages("zoo")
if (!require(EMD)) install.packages("EMD")
if (!require(doParallel)) install.packages("doParallel")
if (!require(foreach)) install.packages("foreach")
if (!require(corrplot)) install.packages("corrplot")
if (!require(pROC)) install.packages("pROC")
# if (!require(klaR)) install.packages("klaR") # sub package for gnb
# if (!require(tidymodels)) install.packages("tidymodels")
# if (!require(discrim)) install.packages("discrim")
# if (!require(kknn)) install.packages("kknn")
# if (!require(kernlab)) install.packages("kernlab")
# if (!require(C50)) install.packages("C50")
# if (!require(randomForest)) install.packages("randomForest")
# if (!require(sda)) install.packages("sda")
# if (!require(sparsediscrim)) install.packages("sparsediscrim")
# if (!require(mda)) install.packages("mda")
# if (!require(stacks)) install.packages("stacks")

# if (!require(tseriesChaos)) install.packages("tseriesChaos")
# if (!require(parallel)) install.packages("parallel")


# LOAD REQUIRED libraries, rest are loaded as sub-libraries.
library(tidyverse) # for manipulating data
library(signal) # for signal processing & Hilbert transforms
library(pracma) # for peak finding
library(mgcv) # for GAM creating
library(entropy) # for TS entropy calculation
library(Hmisc) # to calculate weighted variances
library(zoo) # to trim NA values as some segments are missing end values.
library(EMD) # to do Empirical Mode Decomposition (EMD) for Hilbert Spectrum
library(corrplot) # to plot the correlation matrix
library(pROC) # for ROC AUC analysis
# library(tidymodels) # for ML and Statistical modelling
# library(doParallel) # to run the training on multiple cores
# library(stacks) # for stacks

# parallel processing if available
# ncores <- detectCores(logical = FALSE) - 1
# doParallel::registerDoParallel(cores = ncores)

# library(tseriesChaos) # additional TS analysis e.g. Lyapunov exponents
# library(parallel)

```

## Classification groups

```{r group_selection, echo=FALSE}

# set these up to decide which H&Y groups to classify between.

group_A <- 2
group_B <- 3


```

# Imports

```{r subject_data, echo = FALSE}
# this is a list of subjects with no confidential data. The main feature is the classification
# of H&Y DP class 0, 1, 2, and 3.

subjects <- read.csv("subjects.csv")


```


```{r chest_indices, echo = FALSE}

# This is for manual indices defined by eye

axis_points <- read.csv("axis_points.csv")


```


```{r subject_type, echo = FALSE}
# declare subject type (PD or CT)
subject_type <- vector("list", length = 90)

```


```{r database, echo = FALSE}
# create the sensor data dataframe as a tibble
sensor_data <- tibble(
  lumbar = vector("list", length = 90),
  left_shank = vector("list", length = 90),
  right_shank = vector("list", length = 90),
  chest = vector("list", length = 90),
  left_foot = vector("list", length = 90)
)

# make sure the colnames line up with the actual axis as per the tech datasheet
column_names <- c("i", "VT", "ML", "AP", "Yaw", "Pitch", "Roll", "v8", "v9", "v10", "v11")

# the last four columns are the three axis of the magnetometer and temperature
# respectively, which are not needed for this analysis
column_classes <- c(rep("numeric", 7), rep("NULL", 4))

# make sure the colnames line up with the actual axis as per the tech datasheet
# need to do feet separately.
column_names_feet <- c("i", "AP", "ML", "VT", "Yaw", "Pitch", "Roll", "v8", "v9", "v10", "v11")

# Same with feet, noting we only use accelerometry data for feet.
column_classes_feet <- c(rep("numeric", 7), rep("NULL", 4))

```


## lumbar

```{r lumbar_read_AP, echo=FALSE}

# Loop over the numbers 7 to 90
for (i in 7:90) {
  
  # Create the file paths - separate file path is created outside of project folder
  # due to the large size of the files. This could also be placed in project folder.
  file_path_ct <- sprintf("E:/PD_csvs/%02d_ct/balance/%02d_ct_balance_Lumbar_capp.csv", i, i)
  file_path_pd <- sprintf("E:/PD_csvs/%02d_pd/balance/%02d_pd_balance_Lumbar_capp.csv", i, i)
  
  # Check if the _ct file exists, done to run different code for different
  # type of patient, CT or PD.
  if (file.exists(file_path_ct)) {
     sensor_data$lumbar[[i]] <- read.table(file_path_ct, header = FALSE, sep = ",", col.names = column_names, colClasses = column_classes)
  }
  # Otherwise, check if the _pd file exists
  else if (file.exists(file_path_pd)) {
      sensor_data$lumbar[[i]] <- read.table(file_path_pd, header = FALSE, sep = ",", col.names = column_names, colClasses = column_classes)
  }
  # Otherwise, print a message and move on to the next iteration
  else {
    print(sprintf("Neither file exists for number %02d", i))
    next
  }
  # Set the subject type based on which file exists - needed for graph headers
  subject_type[[i]] <- ifelse(file.exists(file_path_ct), "CT", "PD")
}

```

```{r cut_lumbar, echo = FALSE}
# Initialize the sensor_data_cut list to store the cut data
# this is to isolate the pull test sessions from rest of balance data
sensor_data_cut <- list()
sensor_data_cut$lumbar <- list()

# Iterate over each subject
for (i in 1:length(sensor_data$lumbar)) {
  
  # Check if the element for the current subject is NULL
  if (is.null(sensor_data$lumbar[[i]])) {
    # If it is NULL, add NULL to sensor_data_cut for consistency
    sensor_data_cut$lumbar[[i]] <- NULL
  } else {
    # Otherwise, cut the data based on the axis limits
    # these axis are start of pull test session until end of session
    start_index <- axis_points$start[i]
    end_index <- axis_points$end[i]
    
    # Subsetting the data based on start and end index
    cut_data <- sensor_data$lumbar[[i]][start_index:end_index, ]
    
    # Add the cut data to the sensor_data_cut list
    sensor_data_cut$lumbar[[i]] <- cut_data
  }
}

```

```{r lumbar_zero_mean, echo = FALSE}
# this is to zeroise the data, or bring it to the mean

# Initialize an empty list to store the zeroised lumbar data
sensor_data_zeroised <- list()

# Loop over the elements in the lumbar list of sensor_data_cut
for (i in 1:length(sensor_data_cut$lumbar)) {

  # Skip NULL elements
  if (is.null(sensor_data_cut$lumbar[[i]])) {
    sensor_data_zeroised[[i]] <- NULL
    next
  }
  
  # Extract the AP data for the first 80 points
  initial_data_AP <- sensor_data_cut$lumbar[[i]]$AP[1:80]
  initial_data_ML <- sensor_data_cut$lumbar[[i]]$ML[1:80]
  initial_data_VT <- sensor_data_cut$lumbar[[i]]$VT[1:80]
  initial_data_Pitch <- sensor_data_cut$lumbar[[i]]$Pitch[1:80]
  initial_data_Roll <- sensor_data_cut$lumbar[[i]]$Roll[1:80]
  initial_data_Yaw <- sensor_data_cut$lumbar[[i]]$Yaw[1:80]
  
  # Create a weight vector (lightly weighted towards the end)
  weights <- seq(1, 2, length.out = 80) 
  
  # Calculate the weighted mean
  weighted_mean_AP <- sum(initial_data_AP * weights) / sum(weights)
  weighted_mean_ML <- sum(initial_data_ML * weights) / sum(weights)
  weighted_mean_VT <- sum(initial_data_VT * weights) / sum(weights)
  weighted_mean_Pitch <- sum(initial_data_Pitch * weights) / sum(weights)
  weighted_mean_Roll <- sum(initial_data_Roll * weights) / sum(weights)
  weighted_mean_Yaw <- sum(initial_data_Yaw * weights) / sum(weights)
  
  # Zeroise the entire series by subtracting the weighted mean
  # i.e. Centre the data....
  zeroised_data_AP <- sensor_data_cut$lumbar[[i]]$AP - weighted_mean_AP
  zeroised_data_ML <- sensor_data_cut$lumbar[[i]]$ML - weighted_mean_ML
  zeroised_data_VT <- sensor_data_cut$lumbar[[i]]$VT - weighted_mean_VT
  zeroised_data_Pitch <- sensor_data_cut$lumbar[[i]]$Pitch - weighted_mean_Pitch
  zeroised_data_Roll <- sensor_data_cut$lumbar[[i]]$Roll - weighted_mean_Roll
  zeroised_data_Yaw <- sensor_data_cut$lumbar[[i]]$Yaw - weighted_mean_Yaw
  
  # Create a new data frame with the zeroised data
  temp_df <- data.frame(i = sensor_data_cut$lumbar[[i]]$i,
                       AP = zeroised_data_AP,
                       ML = zeroised_data_ML,
                       VT = zeroised_data_VT,
                       Yaw = zeroised_data_Yaw,
                       Pitch = zeroised_data_Pitch,
                       Roll = zeroised_data_Roll)
  
  # Append the new data frame to the list
  sensor_data_zeroised$lumbar[[i]] <- temp_df
}



```

```{r data_fix_millionx_lum, echo = FALSE}
# Divide all numeric columns of subject 12's data by 1,000,000 because
# it has been changed by a factor of 1,000,000, stored as micrometres
# instead of metres...

# get numeric columns but excluse i
numeric_columns <- sapply(sensor_data_zeroised$lumbar[[12]], is.numeric)
numeric_columns["i"] <- FALSE

# Apply the operation except on i
sensor_data_zeroised$lumbar[[12]][, numeric_columns] <- 
  sensor_data_zeroised$lumbar[[12]][, numeric_columns] / 1e6

# differences to whole means: 6902176, -3757108, 1640162, 4130864, 26892426

```

## left foot

```{r left_foot_read, echo = FALSE}

# Loop over the numbers 7 to 90
for (i in 7:90) {
  
  # Create the file paths
  file_path_ct <- sprintf("E:/PD_csvs/%02d_ct/balance/%02d_ct_balance_LeftFoot_capp.csv", i, i)
  file_path_pd <- sprintf("E:/PD_csvs/%02d_pd/balance/%02d_pd_balance_LeftFoot_capp.csv", i, i)
  
  
  # Check if the _ct file exists
  if (file.exists(file_path_ct)) {
     sensor_data$left_foot[[i]] <- read.table(file_path_ct, header = FALSE, sep = ",", col.names = column_names_feet, colClasses = column_classes_feet)
  }
  # Otherwise, check if the _pd file exists
  else if (file.exists(file_path_pd)) {
      sensor_data$left_foot[[i]] <- read.table(file_path_pd, header = FALSE, sep = ",", col.names = column_names_feet, colClasses = column_classes_feet)
  }
  # Otherwise, print a message and move on to the next iteration
  else {
    print(sprintf("Neither file exists for number %02d", i))
    next
  }
}

```
```{r cut_left_foot, echo = FALSE}
# Initialize the list to store the cut data
sensor_data_cut$left_foot <- list()

# Iterate over each subject
for (i in 1:length(sensor_data$left_foot)) {
  
  # Check if the element for the current subject is NULL
  if (is.null(sensor_data$left_foot[[i]])) {
    # If it is NULL, add NULL to sensor_data_cut for consistency
    sensor_data_cut$left_foot[[i]] <- NULL
  } else {
    # Otherwise, cut the data based on the axis limits
    start_index <- axis_points$start[i]
    end_index <- axis_points$end[i]
    
    # Subsetting the data based on start and end index
    cut_data <- sensor_data$left_foot[[i]][start_index:end_index, ]
    
    # Add the cut data to the sensor_data_cut list
    sensor_data_cut$left_foot[[i]] <- cut_data
  }
}

```

```{r left_foot_zero_mean, echo = FALSE}

# Loop over the elements in the left_foot list of sensor_data_cut
for (i in 1:length(sensor_data_cut$left_foot)) {

  # Skip NULL elements
  if (is.null(sensor_data_cut$left_foot[[i]])) {
    sensor_data_zeroised$left_foot[[i]] <- NULL
    next
  }
  
  # Extract the data for the first 80 points
  initial_data_AP <- sensor_data_cut$left_foot[[i]]$AP[1:80]
  initial_data_ML <- sensor_data_cut$left_foot[[i]]$ML[1:80]
  initial_data_VT <- sensor_data_cut$left_foot[[i]]$VT[1:80]
  initial_data_Pitch <- sensor_data_cut$left_foot[[i]]$Pitch[1:80]
  initial_data_Roll <- sensor_data_cut$left_foot[[i]]$Roll[1:80]
  initial_data_Yaw <- sensor_data_cut$left_foot[[i]]$Yaw[1:80]
  
  # Create a weight vector (lightly weighted towards the end)
  weights <- seq(1, 2, length.out = 80) 
  
  # Calculate the weighted mean
  weighted_mean_AP <- sum(initial_data_AP * weights) / sum(weights)
  weighted_mean_ML <- sum(initial_data_ML * weights) / sum(weights)
  weighted_mean_VT <- sum(initial_data_VT * weights) / sum(weights)
  weighted_mean_Pitch <- sum(initial_data_Pitch * weights) / sum(weights)
  weighted_mean_Roll <- sum(initial_data_Roll * weights) / sum(weights)
  weighted_mean_Yaw <- sum(initial_data_Yaw * weights) / sum(weights)
  
  # Zeroise the entire series by subtracting the weighted mean
  zeroised_data_AP <- sensor_data_cut$left_foot[[i]]$AP - weighted_mean_AP
  zeroised_data_ML <- sensor_data_cut$left_foot[[i]]$ML - weighted_mean_ML
  zeroised_data_VT <- sensor_data_cut$left_foot[[i]]$VT - weighted_mean_VT
  zeroised_data_Pitch <- sensor_data_cut$left_foot[[i]]$Pitch - weighted_mean_Pitch
  zeroised_data_Roll <- sensor_data_cut$left_foot[[i]]$Roll - weighted_mean_Roll
  zeroised_data_Yaw <- sensor_data_cut$left_foot[[i]]$Yaw - weighted_mean_Yaw
  
  # Create a new data frame with the zeroised data
  temp_df <- data.frame(i = sensor_data_cut$left_foot[[i]]$i,
                       AP = zeroised_data_AP,
                       ML = zeroised_data_ML,
                       VT = zeroised_data_VT,
                       Pitch = zeroised_data_Pitch,
                       Roll = zeroised_data_Roll,
                       Yaw = zeroised_data_Yaw)
  
  # Append the new data frame to the list
  sensor_data_zeroised$left_foot[[i]] <- temp_df
}

```
```{r data_fix_millionx_lf, echo = FALSE}
# Divide all numeric columns of subject 12's data by 1,000,000
# due to stored as micrometres not metres
# get numeric columns but exclude i
numeric_columns <- sapply(sensor_data_zeroised$left_foot[[12]], is.numeric)
numeric_columns["i"] <- FALSE

# Apply the operation except on i
sensor_data_zeroised$left_foot[[12]][, numeric_columns] <- 
  sensor_data_zeroised$left_foot[[12]][, numeric_columns] / 1e6

```



## chest


```{r chest_read, echo = FALSE}

# Loop over the numbers 7 to 90
for (i in 7:90) {
  
  # Create the file paths
  file_path_ct <- sprintf("E:/PD_csvs/%02d_ct/balance/%02d_ct_balance_Chest_capp.csv", i, i)
  file_path_pd <- sprintf("E:/PD_csvs/%02d_pd/balance/%02d_pd_balance_Chest_capp.csv", i, i)
  
  
  # Check if the _ct file exists
  if (file.exists(file_path_ct)) {
     sensor_data$chest[[i]] <- read.table(file_path_ct, header = FALSE, sep = ",", col.names = column_names, colClasses = column_classes)
  }
  # Otherwise, check if the _pd file exists
  else if (file.exists(file_path_pd)) {
      sensor_data$chest[[i]] <- read.table(file_path_pd, header = FALSE, sep = ",", col.names = column_names, colClasses = column_classes)
  }
  # Otherwise, print a message and move on to the next iteration
  else {
    print(sprintf("Neither file exists for number %02d", i))
    next
  }
}

```
```{r cut_chest, echo = FALSE}
# Initialize the list to store the cut data
sensor_data_cut$chest <- list()

# Iterate over each subject (each subject corresponds to each element in the chest list)
for (i in 1:length(sensor_data$chest)) {
  
  # Check if the element for the current subject is NULL
  if (is.null(sensor_data$chest[[i]])) {
    # If it is NULL, add NULL to sensor_data_cut for consistency
    sensor_data_cut$chest[[i]] <- NULL
  } else {
    # Otherwise, cut the data based on the axis limits
    start_index <- axis_points$start[i]
    end_index <- axis_points$end[i]
    
    # Subsetting the data based on start and end index
    cut_data <- sensor_data$chest[[i]][start_index:end_index, ]
    
    # Add the cut data to the sensor_data_cut list
    sensor_data_cut$chest[[i]] <- cut_data
  }
}

```

```{r chest_zero_mean, echo = FALSE}

# Loop over the elements in the chest list of sensor_data_cut
for (i in 1:length(sensor_data_cut$chest)) {

  # Skip NULL elements
  if (is.null(sensor_data_cut$chest[[i]])) {
    sensor_data_zeroised$right_foot[[i]] <- NULL
    next
  }
  
  # Extract the AP data for the first 80 points
  initial_data_AP <- sensor_data_cut$chest[[i]]$AP[1:80]
  initial_data_ML <- sensor_data_cut$chest[[i]]$ML[1:80]
  initial_data_VT <- sensor_data_cut$chest[[i]]$VT[1:80]
  initial_data_Pitch <- sensor_data_cut$chest[[i]]$Pitch[1:80]
  initial_data_Roll <- sensor_data_cut$chest[[i]]$Roll[1:80]
  initial_data_Yaw <- sensor_data_cut$chest[[i]]$Yaw[1:80]
  
  # Create a weight vector (lightly weighted towards the end)
  weights <- seq(1, 2, length.out = 80) 
  
  # Calculate the weighted mean
  weighted_mean_AP <- sum(initial_data_AP * weights) / sum(weights)
  weighted_mean_ML <- sum(initial_data_ML * weights) / sum(weights)
  weighted_mean_VT <- sum(initial_data_VT * weights) / sum(weights)
  weighted_mean_Pitch <- sum(initial_data_Pitch * weights) / sum(weights)
  weighted_mean_Roll <- sum(initial_data_Roll * weights) / sum(weights)
  weighted_mean_Yaw <- sum(initial_data_Yaw * weights) / sum(weights)
  
  # Zeroise the entire series by subtracting the weighted mean
  zeroised_data_AP <- sensor_data_cut$chest[[i]]$AP - weighted_mean_AP
  zeroised_data_ML <- sensor_data_cut$chest[[i]]$ML - weighted_mean_ML
  zeroised_data_VT <- sensor_data_cut$chest[[i]]$VT - weighted_mean_VT
  zeroised_data_Pitch <- sensor_data_cut$chest[[i]]$Pitch - weighted_mean_Pitch
  zeroised_data_Roll <- sensor_data_cut$chest[[i]]$Roll - weighted_mean_Roll
  zeroised_data_Yaw <- sensor_data_cut$chest[[i]]$Yaw - weighted_mean_Yaw
  
  # Create a new data frame with the zeroised data
  temp_df <- data.frame(i = sensor_data_cut$chest[[i]]$i,
                       AP = zeroised_data_AP,
                       ML = zeroised_data_ML,
                       VT = zeroised_data_VT,
                       Pitch = zeroised_data_Pitch,
                       Roll = zeroised_data_Roll,
                       Yaw = zeroised_data_Yaw)
  
  # Append the new data frame to the list
  sensor_data_zeroised$chest[[i]] <- temp_df
}

```

```{r data_fix_millionx_che, echo = FALSE}
# Divide all numeric columns of subject 12's data by 1,000,000
# due to stored as micrometres not metres
# get numeric columns but exclude i
numeric_columns <- sapply(sensor_data_zeroised$chest[[12]], is.numeric)
numeric_columns["i"] <- FALSE

# Apply the operation except on i
sensor_data_zeroised$chest[[12]][, numeric_columns] <- 
  sensor_data_zeroised$chest[[12]][, numeric_columns] / 1e6

```

## left shank

```{r left_shank_read, echo = FALSE}

# Loop over the numbers 7 to 90
for (i in 7:90) {
  
  # Create the file paths
  file_path_ct <- sprintf("E:/PD_csvs/%02d_ct/balance/%02d_ct_balance_LeftShank_capp.csv", i, i)
  file_path_pd <- sprintf("E:/PD_csvs/%02d_pd/balance/%02d_pd_balance_LeftShank_capp.csv", i, i)
  
  
  
  # Check if the _ct file exists
  if (file.exists(file_path_ct)) {
     sensor_data$left_shank[[i]] <- read.table(file_path_ct, header = FALSE, sep = ",", col.names = column_names, colClasses = column_classes)
  }
  # Otherwise, check if the _pd file exists
  else if (file.exists(file_path_pd)) {
      sensor_data$left_shank[[i]] <- read.table(file_path_pd, header = FALSE, sep = ",", col.names = column_names, colClasses = column_classes)
  }
  # Otherwise, print a message and move on to the next iteration
  else {
    print(sprintf("Neither file exists for number %02d", i))
    next
  }
}

```
```{r cut_left_shank, echo = FALSE}
# Initialize the list to store the cut data
sensor_data_cut$left_shank <- list()

# Iterate over each subject (each subject corresponds to each element in the left_shank list)
for (i in 1:length(sensor_data$left_shank)) {
  
  # Check if the element for the current subject is NULL
  if (is.null(sensor_data$left_shank[[i]])) {
    # If it is NULL, add NULL to sensor_data_cut for consistency
    sensor_data_cut$left_shank[[i]] <- NULL
  } else {
    # Otherwise, cut the data based on the axis limits
    start_index <- axis_points$start[i]
    end_index <- axis_points$end[i]
    
    # Subsetting the data based on start and end index
    cut_data <- sensor_data$left_shank[[i]][start_index:end_index, ]
    
    # Add the cut data to the sensor_data_cut list
    sensor_data_cut$left_shank[[i]] <- cut_data
  }
}

```

```{r left_shank_zero_mean, echo = FALSE}

# Loop over the elements in the left_shank list of sensor_data_cut
for (i in 1:length(sensor_data_cut$left_shank)) {

  # Skip NULL elements
  if (is.null(sensor_data_cut$left_shank[[i]])) {
    sensor_data_zeroised$left_shank[[i]] <- NULL
    next
  }
  
  # Extract the data for the first 80 points
  initial_data_AP <- sensor_data_cut$left_shank[[i]]$AP[1:80]
  initial_data_ML <- sensor_data_cut$left_shank[[i]]$ML[1:80]
  initial_data_VT <- sensor_data_cut$left_shank[[i]]$VT[1:80]
  initial_data_Pitch <- sensor_data_cut$left_shank[[i]]$Pitch[1:80]
  initial_data_Roll <- sensor_data_cut$left_shank[[i]]$Roll[1:80]
  initial_data_Yaw <- sensor_data_cut$left_shank[[i]]$Yaw[1:80]
  
  # Create a weight vector (lightly weighted towards the end)
  weights <- seq(1, 2, length.out = 80) 
  
  # Calculate the weighted mean
  weighted_mean_AP <- sum(initial_data_AP * weights) / sum(weights)
  weighted_mean_ML <- sum(initial_data_ML * weights) / sum(weights)
  weighted_mean_VT <- sum(initial_data_VT * weights) / sum(weights)
  weighted_mean_Pitch <- sum(initial_data_Pitch * weights) / sum(weights)
  weighted_mean_Roll <- sum(initial_data_Roll * weights) / sum(weights)
  weighted_mean_Yaw <- sum(initial_data_Yaw * weights) / sum(weights)
  
  # Zeroise the entire series by subtracting the weighted mean
  zeroised_data_AP <- sensor_data_cut$left_shank[[i]]$AP - weighted_mean_AP
  zeroised_data_ML <- sensor_data_cut$left_shank[[i]]$ML - weighted_mean_ML
  zeroised_data_VT <- sensor_data_cut$left_shank[[i]]$VT - weighted_mean_VT
  zeroised_data_Pitch <- sensor_data_cut$left_shank[[i]]$Pitch - weighted_mean_Pitch
  zeroised_data_Roll <- sensor_data_cut$left_shank[[i]]$Roll - weighted_mean_Roll
  zeroised_data_Yaw <- sensor_data_cut$left_shank[[i]]$Yaw - weighted_mean_Yaw
  
  # Create a new data frame with the zeroised data
  temp_df <- data.frame(i = sensor_data_cut$left_shank[[i]]$i,
                       AP = zeroised_data_AP,
                       ML = zeroised_data_ML,
                       VT = zeroised_data_VT,
                       Pitch = zeroised_data_Pitch,
                       Roll = zeroised_data_Roll,
                       Yaw = zeroised_data_Yaw)
  
  # Append the new data frame to the list
  sensor_data_zeroised$left_shank[[i]] <- temp_df
}

```
```{r data_fix_millionx_lf, echo = FALSE}
# Divide all numeric columns of subject 12's data by 1,000,000
# due to stored as micrometres not metres
# get numeric columns but exclude i
numeric_columns <- sapply(sensor_data_zeroised$left_shank[[12]], is.numeric)
numeric_columns["i"] <- FALSE

# Apply the operation except on i
sensor_data_zeroised$left_shank[[12]][, numeric_columns] <- 
  sensor_data_zeroised$left_shank[[12]][, numeric_columns] / 1e6

```

## right shank

```{r right_shank_read, echo = FALSE}

# Loop over the numbers 7 to 90
for (i in 7:90) {
  
  # Create the file paths
  file_path_ct <- sprintf("E:/PD_csvs/%02d_ct/balance/%02d_ct_balance_RightShank_capp.csv", i, i)
  file_path_pd <- sprintf("E:/PD_csvs/%02d_pd/balance/%02d_pd_balance_RightShank_capp.csv", i, i)
  
  
  
  
  # Check if the _ct file exists
  if (file.exists(file_path_ct)) {
     sensor_data$right_shank[[i]] <- read.table(file_path_ct, header = FALSE, sep = ",", col.names = column_names, colClasses = column_classes)
  }
  # Otherwise, check if the _pd file exists
  else if (file.exists(file_path_pd)) {
      sensor_data$right_shank[[i]] <- read.table(file_path_pd, header = FALSE, sep = ",", col.names = column_names, colClasses = column_classes)
  }
  # Otherwise, print a message and move on to the next iteration
  else {
    print(sprintf("Neither file exists for number %02d", i))
    next
  }
}

```
```{r cut_right_shank, echo = FALSE}
# Initialize the list to store the cut data
sensor_data_cut$right_shank <- list()

# Iterate over each subject (each subject corresponds to each element in the right_shank list)
for (i in 1:length(sensor_data$right_shank)) {
  
  # Check if the element for the current subject is NULL
  if (is.null(sensor_data$right_shank[[i]])) {
    # If it is NULL, add NULL to sensor_data_cut for consistency
    sensor_data_cut$right_shank[[i]] <- NULL
  } else {
    # Otherwise, cut the data based on the axis limits
    start_index <- axis_points$start[i]
    end_index <- axis_points$end[i]
    
    # Subsetting the data based on start and end index
    cut_data <- sensor_data$right_shank[[i]][start_index:end_index, ]
    
    # Add the cut data to the sensor_data_cut list
    sensor_data_cut$right_shank[[i]] <- cut_data
  }
}

```

```{r right_shank_zero_mean, echo = FALSE}

# Loop over the elements in the right_shank list of sensor_data_cut
for (i in 1:length(sensor_data_cut$right_shank)) {

  # Skip NULL elements
  if (is.null(sensor_data_cut$right_shank[[i]])) {
    sensor_data_zeroised$right_shank[[i]] <- NULL
    next
  }
  
  # Extract the data for the first 80 points
  initial_data_AP <- sensor_data_cut$right_shank[[i]]$AP[1:80]
  initial_data_ML <- sensor_data_cut$right_shank[[i]]$ML[1:80]
  initial_data_VT <- sensor_data_cut$right_shank[[i]]$VT[1:80]
  initial_data_Pitch <- sensor_data_cut$right_shank[[i]]$Pitch[1:80]
  initial_data_Roll <- sensor_data_cut$right_shank[[i]]$Roll[1:80]
  initial_data_Yaw <- sensor_data_cut$right_shank[[i]]$Yaw[1:80]
  
  # Create a weight vector (lightly weighted towards the end)
  weights <- seq(1, 2, length.out = 80) 
  
  # Calculate the weighted mean
  weighted_mean_AP <- sum(initial_data_AP * weights) / sum(weights)
  weighted_mean_ML <- sum(initial_data_ML * weights) / sum(weights)
  weighted_mean_VT <- sum(initial_data_VT * weights) / sum(weights)
  weighted_mean_Pitch <- sum(initial_data_Pitch * weights) / sum(weights)
  weighted_mean_Roll <- sum(initial_data_Roll * weights) / sum(weights)
  weighted_mean_Yaw <- sum(initial_data_Yaw * weights) / sum(weights)
  
  # Zeroise the entire series by subtracting the weighted mean
  zeroised_data_AP <- sensor_data_cut$right_shank[[i]]$AP - weighted_mean_AP
  zeroised_data_ML <- sensor_data_cut$right_shank[[i]]$ML - weighted_mean_ML
  zeroised_data_VT <- sensor_data_cut$right_shank[[i]]$VT - weighted_mean_VT
  zeroised_data_Pitch <- sensor_data_cut$right_shank[[i]]$Pitch - weighted_mean_Pitch
  zeroised_data_Roll <- sensor_data_cut$right_shank[[i]]$Roll - weighted_mean_Roll
  zeroised_data_Yaw <- sensor_data_cut$right_shank[[i]]$Yaw - weighted_mean_Yaw
  
  # Create a new data frame with the zeroised data
  temp_df <- data.frame(i = sensor_data_cut$right_shank[[i]]$i,
                       AP = zeroised_data_AP,
                       ML = zeroised_data_ML,
                       VT = zeroised_data_VT,
                       Pitch = zeroised_data_Pitch,
                       Roll = zeroised_data_Roll,
                       Yaw = zeroised_data_Yaw)
  
  # Append the new data frame to the list
  sensor_data_zeroised$right_shank[[i]] <- temp_df
}

```
```{r data_fix_millionx_lf, echo = FALSE}
# Divide all numeric columns of subject 12's data by 1,000,000
# due stored as micrometres not metres
# get numeric columns but exclude i
numeric_columns <- sapply(sensor_data_zeroised$right_shank[[12]], is.numeric)
numeric_columns["i"] <- FALSE

# Apply the operation except on i
sensor_data_zeroised$right_shank[[12]][, numeric_columns] <- 
  sensor_data_zeroised$right_shank[[12]][, numeric_columns] / 1e6

```


# Sorting data

## lumbar

```{r sorting_lumbar, echo=FALSE}

# create new df copying the lumbar data
lumbar_sorted <- sensor_data_zeroised$lumbar

# assign an index attribute to each subject to retain the subject number data for
# when the list is sorted
for(i in 1:90) {
  if(is.null(lumbar_sorted[[i]])) {
    lumbar_sorted[[i]] <- data.frame(placeholder = NA)
  }
  attr(lumbar_sorted[[i]], "index") <- i
}

# cut the null data subjects from the list and remove bad data subjects
lumbar_sorted <- lumbar_sorted[-c(1:6, 8, 78, 81)]

# assign H&Y class from subjects
for(i in 1:length(lumbar_sorted)) {
  index_value <- attr(lumbar_sorted[[i]], "index")
  attr(lumbar_sorted[[i]], "HYclass") <- subjects$stage[index_value]
}

# do the sorting:
# Get a vector of HYclass attributes from the list
HYclass_vector <- sapply(lumbar_sorted, function(x) attr(x, "HYclass"))
# Get the indices of the sorted vector (sorting in ascending order)
sorted_indices <- order(HYclass_vector)
# Use the sorted indices to rearrange the list
lumbar_sorted <- lumbar_sorted[sorted_indices]

# group amounts for averaging later
num_0 <- 38
num_1 <- 13
num_2 <- 19 # total is 21, but 8 and 78 removed which are 2.
num_3 <- 11


```


## Chest

```{r sorting_chest, echo=FALSE}

# create new df copying the lumbar data
chest_sorted <- sensor_data_zeroised$chest

# assign an index attribute to each subject to retain the subject number data for
# when the list is sorted
for(i in 1:90) {
  if(is.null(chest_sorted[[i]])) {
    chest_sorted[[i]] <- data.frame(placeholder = NA)
  }
  attr(chest_sorted[[i]], "index") <- i
}

# cut the null data subjects from the list and remove bad data subjects
chest_sorted <- chest_sorted[-c(1:6, 8, 78, 81)]

# assign H&Y class from subjects
for(i in 1:length(chest_sorted)) {
  index_value <- attr(chest_sorted[[i]], "index")
  attr(chest_sorted[[i]], "HYclass") <- subjects$stage[index_value]
}

# do the sorting:
# Get a vector of HYclass attributes from the list
HYclass_vector <- sapply(chest_sorted, function(x) attr(x, "HYclass"))
# Get the indices of the sorted vector (sorting in ascending order)
sorted_indices <- order(HYclass_vector)
# Use the sorted indices to rearrange the list
chest_sorted <- chest_sorted[sorted_indices]

# group amounts for averaging later
num_0 <- 38
num_1 <- 13
num_2 <- 19 # total is 21, but 8 and 78 removed which are 2.
num_3 <- 11


```

## left shank

```{r sorting_shank, echo=FALSE}

# create new df copying the lumbar data
left_shank_sorted <- sensor_data_zeroised$left_shank

# assign an index attribute to each subject to retain the subject number data for
# when the list is sorted
for(i in 1:90) {
  if(is.null(left_shank_sorted[[i]])) {
    left_shank_sorted[[i]] <- data.frame(placeholder = NA)
  }
  attr(left_shank_sorted[[i]], "index") <- i
}

# cut the null data subjects from the list and remove bad data subjects
left_shank_sorted <- left_shank_sorted[-c(1:6, 8, 78, 81)]

# assign H&Y class from subjects
for(i in 1:length(left_shank_sorted)) {
  index_value <- attr(left_shank_sorted[[i]], "index")
  attr(left_shank_sorted[[i]], "HYclass") <- subjects$stage[index_value]
}

# do the sorting:
# Get a vector of HYclass attributes from the list
HYclass_vector <- sapply(left_shank_sorted, function(x) attr(x, "HYclass"))
# Get the indices of the sorted vector (sorting in ascending order)
sorted_indices <- order(HYclass_vector)
# Use the sorted indices to rearrange the list
left_shank_sorted <- left_shank_sorted[sorted_indices]

# group amounts for averaging later
num_0 <- 38
num_1 <- 13
num_2 <- 19 # total is 21, but 8 and 78 removed which are 2.
num_3 <- 11


```

## right shank

```{r sorting_shank, echo=FALSE}

# create new df copying the lumbar data
right_shank_sorted <- sensor_data_zeroised$right_shank

# assign an index attribute to each subject to retain the subject number data for
# when the list is sorted
for(i in 1:90) {
  if(is.null(right_shank_sorted[[i]])) {
    right_shank_sorted[[i]] <- data.frame(placeholder = NA)
  }
  attr(right_shank_sorted[[i]], "index") <- i
}

# cut the null data subjects from the list and remove bad data subjects
right_shank_sorted <- right_shank_sorted[-c(1:6, 8, 78, 81)]

# assign H&Y class from subjects
for(i in 1:length(right_shank_sorted)) {
  index_value <- attr(right_shank_sorted[[i]], "index")
  attr(right_shank_sorted[[i]], "HYclass") <- subjects$stage[index_value]
}

# do the sorting:
# Get a vector of HYclass attributes from the list
HYclass_vector <- sapply(right_shank_sorted, function(x) attr(x, "HYclass"))
# Get the indices of the sorted vector (sorting in ascending order)
sorted_indices <- order(HYclass_vector)
# Use the sorted indices to rearrange the list
right_shank_sorted <- right_shank_sorted[sorted_indices]

# group amounts for averaging later
num_0 <- 38
num_1 <- 13
num_2 <- 19 # total is 21, but 8 and 78 removed which are 2.
num_3 <- 11


```

## left foot

```{r sorting_foot, echo=FALSE}

# create new df copying the foot data
left_foot_sorted <- sensor_data_zeroised$left_foot

# assign an index attribute to each subject to retain the subject number data for
# when the list is sorted
for(i in 1:90) {
  if(is.null(left_foot_sorted[[i]])) {
    left_foot_sorted[[i]] <- data.frame(placeholder = NA)
  }
  attr(left_foot_sorted[[i]], "index") <- i
}

# cut the null data subjects from the list and remove bad data subjects
left_foot_sorted <- left_foot_sorted[-c(1:6, 8, 78, 81)]

# assign H&Y class from subjects
for(i in 1:length(left_foot_sorted)) {
  index_value <- attr(left_foot_sorted[[i]], "index")
  attr(left_foot_sorted[[i]], "HYclass") <- subjects$stage[index_value]
}

# do the sorting:
# Get a vector of HYclass attributes from the list
HYclass_vector <- sapply(left_foot_sorted, function(x) attr(x, "HYclass"))
# Get the indices of the sorted vector (sorting in ascending order)
sorted_indices <- order(HYclass_vector)
# Use the sorted indices to rearrange the list
left_foot_sorted <- left_foot_sorted[sorted_indices]

# group amounts for averaging later
num_0 <- 38
num_1 <- 13
num_2 <- 19 # total is 21, but 8 and 78 removed which are 2.
num_3 <- 11


```



# Signal Filtering

## lumbar

```{r filter_lumbar, echo=FALSE}
# empty list for filtered AP data
filtered_acceleration_ap <- list()

# 4th-order Butterworth filter with pass band frequency
bf <- butter(4, c(0.022, 0.8), type = "pass", plane = 'z')
# 4th-order high-pass Butterworth filter
# bf <- butter(4, 0.022, type = 'high', plane = 'z')

# Loop over all subjects in features$Subject
for(i in 1:length(lumbar_sorted)) {
  
  # Apply the filter
  filtered_data_ap <- signal::filter(filt = bf$b, a=bf$a, lumbar_sorted[[i]]$AP)
  
  # Store the filtered AP data
  filtered_acceleration_ap[[i]] <- filtered_data_ap
}

# empty list for filtered ML data
filtered_acceleration_ml <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(lumbar_sorted)) {
  
  # Apply the filter
  filtered_data_ml <- signal::filter(filt = bf$b, a=bf$a, lumbar_sorted[[i]]$ML)
  
  # Store the filtered ML data
  filtered_acceleration_ml[[i]] <- filtered_data_ml
}

# empty list for filtered VT data
filtered_acceleration_vt <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(lumbar_sorted)) {
  
  # Apply the filter
  filtered_data_vt <- signal::filter(filt = bf$b, a=bf$a, lumbar_sorted[[i]]$VT)
  
  # Store the filtered ML data
  filtered_acceleration_vt[[i]] <- filtered_data_vt
}

# empty list for filtered Pitch data
filtered_angular_velocity_pi <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(lumbar_sorted)) {
  
  # Apply the filter
  filtered_data_pi <- signal::filter(filt = bf$b, a=bf$a, lumbar_sorted[[i]]$Pitch)
  
  # Store the filtered ML data
  filtered_angular_velocity_pi[[i]] <- filtered_data_pi
}

# empty list for filtered roll data
filtered_angular_velocity_ro <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(lumbar_sorted)) {
  
  # Apply the filter
  filtered_data_ro <- signal::filter(filt = bf$b, a=bf$a, lumbar_sorted[[i]]$Roll)
  
  # Store the filtered ML data
  filtered_angular_velocity_ro[[i]] <- filtered_data_ro
}

# empty list for filtered yaw data
filtered_angular_velocity_ya <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(lumbar_sorted)) {
  
  # Apply the filter
  filtered_data_ya <- signal::filter(filt = bf$b, a=bf$a, lumbar_sorted[[i]]$Yaw)
  
  # Store the filtered ML data
  filtered_angular_velocity_ya[[i]] <- filtered_data_ya
}

```

## chest

```{r filter_chest, echo=FALSE}
# empty list for filtered AP data
filtered_acceleration_chest_ap <- list()

# 4th-order Butterworth filter with pass band frequency
bf <- butter(4, c(0.022, 0.8), type = "pass", plane = 'z')


# Loop over all subjects in features$Subject
for(i in 1:length(chest_sorted)) {
  
  # Apply the filter
  filtered_data_ap <- signal::filter(filt = bf$b, a=bf$a, chest_sorted[[i]]$AP)
  
  # Store the filtered AP data
  filtered_acceleration_chest_ap[[i]] <- filtered_data_ap
}

# empty list for filtered ML data
filtered_acceleration_chest_ml <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(chest_sorted)) {
  
  # Apply the filter
  filtered_data_ml <- signal::filter(filt = bf$b, a=bf$a, chest_sorted[[i]]$ML)
  
  # Store the filtered ML data
  filtered_acceleration_chest_ml[[i]] <- filtered_data_ml
}

# empty list for filtered VT data
filtered_acceleration_chest_vt <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(chest_sorted)) {
  
  # Apply the filter
  filtered_data_vt <- signal::filter(filt = bf$b, a=bf$a, chest_sorted[[i]]$VT)
  
  # Store the filtered ML data
  filtered_acceleration_chest_vt[[i]] <- filtered_data_vt
}

# empty list for filtered Pitch data
filtered_angular_velocity_chest_pi <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(chest_sorted)) {
  
  # Apply the filter
  filtered_data_pi <- signal::filter(filt = bf$b, a=bf$a, chest_sorted[[i]]$Pitch)
  
  # Store the filtered ML data
  filtered_angular_velocity_chest_pi[[i]] <- filtered_data_pi
}

# empty list for filtered roll data
filtered_angular_velocity_chest_ro <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(chest_sorted)) {
  
  # Apply the filter
  filtered_data_ro <- signal::filter(filt = bf$b, a=bf$a, chest_sorted[[i]]$Roll)
  
  # Store the filtered ML data
  filtered_angular_velocity_chest_ro[[i]] <- filtered_data_ro
}

# empty list for filtered roll data
filtered_angular_velocity_chest_ya <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(chest_sorted)) {
  
  # Apply the filter
  filtered_data_ya <- signal::filter(filt = bf$b, a=bf$a, chest_sorted[[i]]$Yaw)
  
  # Store the filtered ML data
  filtered_angular_velocity_chest_ya[[i]] <- filtered_data_ya
}

```

## left shank

```{r filter_left_shank, echo=FALSE}
# empty list for filtered AP data
filtered_acceleration_left_shank_ap <- list()

# 4th-order Butterworth filter with pass band frequency
bf <- butter(4, c(0.022, 0.8), type = "pass", plane = 'z')
# 4th-order high-pass Butterworth filter
# bf <- butter(4, 0.022, type = 'high', plane = 'z')

# Loop over all subjects in features$Subject
for(i in 1:length(left_shank_sorted)) {
  
  # Apply the filter
  filtered_data_ap <- signal::filter(filt = bf$b, a=bf$a, left_shank_sorted[[i]]$AP)
  
  # Store the filtered AP data
  filtered_acceleration_left_shank_ap[[i]] <- filtered_data_ap
}

# empty list for filtered ML data
filtered_acceleration_left_shank_ml <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(left_shank_sorted)) {
  
  # Apply the filter
  filtered_data_ml <- signal::filter(filt = bf$b, a=bf$a, left_shank_sorted[[i]]$ML)
  
  # Store the filtered ML data
  filtered_acceleration_left_shank_ml[[i]] <- filtered_data_ml
}

# empty list for filtered VT data
filtered_acceleration_left_shank_vt <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(left_shank_sorted)) {
  
  # Apply the filter
  filtered_data_vt <- signal::filter(filt = bf$b, a=bf$a, left_shank_sorted[[i]]$VT)
  
  # Store the filtered ML data
  filtered_acceleration_left_shank_vt[[i]] <- filtered_data_vt
}

# empty list for filtered Pitch data
filtered_angular_velocity_left_shank_pi <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(left_shank_sorted)) {
  
  # Apply the filter
  filtered_data_pi <- signal::filter(filt = bf$b, a=bf$a, left_shank_sorted[[i]]$Pitch)
  
  # Store the filtered ML data
  filtered_angular_velocity_left_shank_pi[[i]] <- filtered_data_pi
}

# empty list for filtered roll data
filtered_angular_velocity_left_shank_ro <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(left_shank_sorted)) {
  
  # Apply the filter
  filtered_data_ro <- signal::filter(filt = bf$b, a=bf$a, left_shank_sorted[[i]]$Roll)
  
  # Store the filtered ML data
  filtered_angular_velocity_left_shank_ro[[i]] <- filtered_data_ro
}

# empty list for filtered yaw data
filtered_angular_velocity_left_shank_ya <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(left_shank_sorted)) {
  
  # Apply the filter
  filtered_data_ya <- signal::filter(filt = bf$b, a=bf$a, left_shank_sorted[[i]]$Yaw)
  
  # Store the filtered ML data
  filtered_angular_velocity_left_shank_ya[[i]] <- filtered_data_ya
}

```

## right shank

```{r filter_right_shank, echo=FALSE}
# empty list for filtered AP data
filtered_acceleration_right_shank_ap <- list()

# 4th-order Butterworth filter with pass band frequency
bf <- butter(4, c(0.022, 0.8), type = "pass", plane = 'z')
# 4th-order high-pass Butterworth filter
# bf <- butter(4, 0.022, type = 'high', plane = 'z')

# Loop over all subjects in features$Subject
for(i in 1:length(right_shank_sorted)) {
  
  # Apply the filter
  filtered_data_ap <- signal::filter(filt = bf$b, a=bf$a, right_shank_sorted[[i]]$AP)
  
  # Store the filtered AP data
  filtered_acceleration_right_shank_ap[[i]] <- filtered_data_ap
}

# empty list for filtered ML data
filtered_acceleration_right_shank_ml <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(right_shank_sorted)) {
  
  # Apply the filter
  filtered_data_ml <- signal::filter(filt = bf$b, a=bf$a, right_shank_sorted[[i]]$ML)
  
  # Store the filtered ML data
  filtered_acceleration_right_shank_ml[[i]] <- filtered_data_ml
}

# empty list for filtered VT data
filtered_acceleration_right_shank_vt <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(right_shank_sorted)) {
  
  # Apply the filter
  filtered_data_vt <- signal::filter(filt = bf$b, a=bf$a, right_shank_sorted[[i]]$VT)
  
  # Store the filtered ML data
  filtered_acceleration_right_shank_vt[[i]] <- filtered_data_vt
}

# empty list for filtered Pitch data
filtered_angular_velocity_right_shank_pi <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(right_shank_sorted)) {
  
  # Apply the filter
  filtered_data_pi <- signal::filter(filt = bf$b, a=bf$a, right_shank_sorted[[i]]$Pitch)
  
  # Store the filtered ML data
  filtered_angular_velocity_right_shank_pi[[i]] <- filtered_data_pi
}

# empty list for filtered roll data
filtered_angular_velocity_right_shank_ro <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(right_shank_sorted)) {
  
  # Apply the filter
  filtered_data_ro <- signal::filter(filt = bf$b, a=bf$a, right_shank_sorted[[i]]$Roll)
  
  # Store the filtered ML data
  filtered_angular_velocity_right_shank_ro[[i]] <- filtered_data_ro
}

# empty list for filtered yaw data
filtered_angular_velocity_right_shank_ya <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(right_shank_sorted)) {
  
  # Apply the filter
  filtered_data_ya <- signal::filter(filt = bf$b, a=bf$a, right_shank_sorted[[i]]$Yaw)
  
  # Store the filtered ML data
  filtered_angular_velocity_right_shank_ya[[i]] <- filtered_data_ya
}

```



## left foot

```{r filter_left_foot, echo=FALSE}
# empty list for filtered AP data
filtered_acceleration_left_foot_ap <- list()

# 4th-order Butterworth filter with pass band frequency
bf <- butter(4, c(0.022, 0.8), type = "pass", plane = 'z')
# 4th-order high-pass Butterworth filter
# bf <- butter(4, 0.022, type = 'high', plane = 'z')

# Loop over all subjects in features$Subject
for(i in 1:length(left_foot_sorted)) {
  
  # Apply the filter
  filtered_data_ap <- signal::filter(filt = bf$b, a=bf$a, left_foot_sorted[[i]]$AP)
  
  # Store the filtered AP data
  filtered_acceleration_left_foot_ap[[i]] <- filtered_data_ap
}

# empty list for filtered ML data
filtered_acceleration_left_foot_ml <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(left_foot_sorted)) {
  
  # Apply the filter
  filtered_data_ml <- signal::filter(filt = bf$b, a=bf$a, left_foot_sorted[[i]]$ML)
  
  # Store the filtered ML data
  filtered_acceleration_left_foot_ml[[i]] <- filtered_data_ml
}

# empty list for filtered VT data
filtered_acceleration_left_foot_vt <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(left_foot_sorted)) {
  
  # Apply the filter
  filtered_data_vt <- signal::filter(filt = bf$b, a=bf$a, left_foot_sorted[[i]]$VT)
  
  # Store the filtered ML data
  filtered_acceleration_left_foot_vt[[i]] <- filtered_data_vt
}

# empty list for filtered Pitch data
filtered_angular_velocity_left_foot_pi <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(left_foot_sorted)) {
  
  # Apply the filter
  filtered_data_pi <- signal::filter(filt = bf$b, a=bf$a, left_foot_sorted[[i]]$Pitch)
  
  # Store the filtered ML data
  filtered_angular_velocity_left_foot_pi[[i]] <- filtered_data_pi
}

# empty list for filtered roll data
filtered_angular_velocity_left_foot_ro <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(left_foot_sorted)) {
  
  # Apply the filter
  filtered_data_ro <- signal::filter(filt = bf$b, a=bf$a, left_foot_sorted[[i]]$Roll)
  
  # Store the filtered ML data
  filtered_angular_velocity_left_foot_ro[[i]] <- filtered_data_ro
}

# empty list for filtered roll data
filtered_angular_velocity_left_foot_ya <- list()

# Loop over all subjects in features$Subject
for(i in 1:length(left_foot_sorted)) {
  
  # Apply the filter
  filtered_data_ya <- signal::filter(filt = bf$b, a=bf$a, left_foot_sorted[[i]]$Yaw)
  
  # Store the filtered ML data
  filtered_angular_velocity_left_foot_ya[[i]] <- filtered_data_ya
}

```

```{r filter_check, echo=FALSE, fig.align='left'}
sub <- 15

# Step 1: Get the FFT of the original and filtered data
fft_original <- fft(chest_sorted[[sub]]$AP)
fft_filtered <- fft(filtered_acceleration_chest_ap[[sub]])

# Step 2: Calculate half length of the FFT data
half_length_original <- floor(length(fft_original)/2)
half_length_filtered <- floor(length(fft_filtered)/2)

# Step 3: Compute the magnitude of the first half of the FFT data
magnitude_original <- Mod(fft_original[1:half_length_original])
magnitude_filtered <- Mod(fft_filtered[1:half_length_filtered])

# Step 4: compute the frequency resolution for 50 Hz
delta_f <- 50 / length(lumbar_sorted[[sub]]$AP)  # Frequency resolution

# Step 5: Generate the frequency sequences
freq_original <- seq(0, 50/2-delta_f, length.out = half_length_original)
freq_filtered <- seq(0, 50/2-delta_f, length.out = half_length_filtered)

# Step 6: Plot the original and filtered data on the same plot
plot(freq_original, magnitude_original, type = "l", ylim = c(0, 70),  xlim = c(0,15),
     main = "Original and Filtered Data (AP)", 
     xlab = "Frequency (Hz)", ylab = "Magnitude", col = "black")
lines(freq_filtered, magnitude_filtered, col = "red")
legend("topright", legend = c("Original Data", "Filtered Data"), 
       col = c("black", "red"), lty = 1)


```


```{r filter_check_ml, echo=FALSE, fig.align='left'}
sub <- 15

# Step 1: Get the FFT of the original and filtered data
fft_original <- fft(lumbar_sorted[[sub]]$ML)
fft_filtered <- fft(filtered_acceleration_ml[[sub]])

# Step 2: Calculate half length of the FFT data
half_length_original <- floor(length(fft_original)/2)
half_length_filtered <- floor(length(fft_filtered)/2)

# Step 3: Compute the magnitude of the first half of the FFT data
magnitude_original <- Mod(fft_original[1:half_length_original])
magnitude_filtered <- Mod(fft_filtered[1:half_length_filtered])

# Step 4: compute the frequency resolution for 50 Hz
delta_f <- 50 / length(lumbar_sorted[[sub]]$ML)  # Frequency resolution

# Step 5: Generate the frequency sequences
freq_original <- seq(0, 50/2-delta_f, length.out = half_length_original)
freq_filtered <- seq(0, 50/2-delta_f, length.out = half_length_filtered)

# Step 6: Plot the original and filtered data on the same plot
plot(freq_original, magnitude_original, type = "l", ylim = c(0, 50),  xlim = c(0,15),
     main = "Original and Filtered Data (ML)", 
     xlab = "Frequency (Hz)", ylab = "Magnitude", col = "black")
lines(freq_filtered, magnitude_filtered, col = "red")
legend("topright", legend = c("Original Data", "Filtered Data"), 
       col = c("black", "red"), lty = 1)



```



# Features


```{r feature_df, echo=FALSE}
# create feature df
# this has been checked, same order as lumbar_sorted (see attr of lumbar_sorted)
features <- tibble(Subject = vector("list", length = 90),
                   HYclass = vector("list", length = 90))
# add subject ID
features$Subject <- subjects$sub_num
# add H&Y class
features$HYclass <- subjects$stage

# remove subjects with no balance data, remember these gaps later
# also need to remove subjects 8 and 78
features <- features %>%
  dplyr::filter(!(Subject %in% c(1:6, 8, 78, 81)))

# sort it into order
features <- features[order(features$HYclass), ]

```

## Data preparation

### Segmentation

In this data set, each subject will include three segmented pulls.

```{r segmentation_upload, echo = FALSE}

# read in the segment indexes
segments <- read.csv("segments_manual.csv")



```


### Cutting into segments
#### Lumbar

```{r optional_filter_injection, echo = FALSE}

# replace each of the sorted with filtered data
for (i in 1:length(lumbar_sorted)) {
  n <- length(filtered_acceleration_ap[[i]])
  lumbar_sorted[[i]]$AP[1:n] <- filtered_acceleration_ap[[i]]
  lumbar_sorted[[i]]$ML[1:n] <- filtered_acceleration_ml[[i]]
  lumbar_sorted[[i]]$VT[1:n] <- filtered_acceleration_vt[[i]]
  lumbar_sorted[[i]]$Pitch[1:n] <- filtered_angular_velocity_pi[[i]]
  lumbar_sorted[[i]]$Roll[1:n] <- filtered_angular_velocity_ro[[i]]
  lumbar_sorted[[i]]$Yaw[1:n] <- filtered_angular_velocity_ya[[i]]
  
  chest_sorted[[i]]$AP[1:n] <- filtered_acceleration_chest_ap[[i]]
  chest_sorted[[i]]$ML[1:n] <- filtered_acceleration_chest_ml[[i]]
  chest_sorted[[i]]$VT[1:n] <- filtered_acceleration_chest_vt[[i]]
  chest_sorted[[i]]$Pitch[1:n] <- filtered_angular_velocity_chest_pi[[i]]
  chest_sorted[[i]]$Roll[1:n] <- filtered_angular_velocity_chest_ro[[i]]
  chest_sorted[[i]]$Yaw[1:n] <- filtered_angular_velocity_chest_ya[[i]]
  
  left_shank_sorted[[i]]$AP[1:n] <- filtered_acceleration_left_shank_ap[[i]]
  left_shank_sorted[[i]]$ML[1:n] <- filtered_acceleration_left_shank_ml[[i]]
  left_shank_sorted[[i]]$VT[1:n] <- filtered_acceleration_left_shank_vt[[i]]
  left_shank_sorted[[i]]$Pitch[1:n] <- filtered_angular_velocity_left_shank_pi[[i]]
  left_shank_sorted[[i]]$Roll[1:n] <- filtered_angular_velocity_left_shank_ro[[i]]
  left_shank_sorted[[i]]$Yaw[1:n] <- filtered_angular_velocity_left_shank_ya[[i]]
  
  left_foot_sorted[[i]]$AP[1:n] <- filtered_acceleration_left_foot_ap[[i]]
  left_foot_sorted[[i]]$ML[1:n] <- filtered_acceleration_left_foot_ml[[i]]
  left_foot_sorted[[i]]$VT[1:n] <- filtered_acceleration_left_foot_vt[[i]]
  left_foot_sorted[[i]]$Pitch[1:n] <- filtered_angular_velocity_left_foot_pi[[i]]
  left_foot_sorted[[i]]$Roll[1:n] <- filtered_angular_velocity_left_foot_ro[[i]]
  left_foot_sorted[[i]]$Yaw[1:n] <- filtered_angular_velocity_left_foot_ya[[i]]
  
}



```



```{r segmentation_implementation, echo = FALSE}
# pull_segments dataset creation
pull_segments <- features[1:(length(lumbar_sorted)), c("Subject", "HYclass")]
pull_segments$AP_1 <- NA
pull_segments$AP_2 <- NA
pull_segments$AP_3 <- NA

pull_segments$ML_1 <- NA
pull_segments$ML_2 <- NA
pull_segments$ML_3 <- NA

pull_segments$VT_1 <- NA
pull_segments$VT_2 <- NA
pull_segments$VT_3 <- NA

pull_segments$Pitch_1 <- NA
pull_segments$Pitch_2 <- NA
pull_segments$Pitch_3 <- NA

pull_segments$Roll_1 <- NA
pull_segments$Roll_2 <- NA
pull_segments$Roll_3 <- NA

pull_segments$Yaw_1 <- NA
pull_segments$Yaw_2 <- NA
pull_segments$Yaw_3 <- NA


# Loop over all
for (i in 1:length(lumbar_sorted)) {
  # Get the start index for the segment
  start_index_1 <- segments$First[i]
  start_index_2 <- segments$Second[i]
  start_index_3 <- segments$Third[i]
  
  # end index making it 2 second segment
  end_index_1 <- start_index_1 + 99
  end_index_2 <- start_index_2 + 99
  end_index_3 <- start_index_3 + 99
  
  # Extract the segment vector as a list to the variable
  pull_segments$AP_1[i] <- list(lumbar_sorted[[i]]$AP[start_index_1:end_index_1])
  pull_segments$AP_2[i] <- list(lumbar_sorted[[i]]$AP[start_index_2:end_index_2])
  pull_segments$AP_3[i] <- list(lumbar_sorted[[i]]$AP[start_index_3:end_index_3])
  
  pull_segments$ML_1[i] <- list(lumbar_sorted[[i]]$ML[start_index_1:end_index_1])
  pull_segments$ML_2[i] <- list(lumbar_sorted[[i]]$ML[start_index_2:end_index_2])
  pull_segments$ML_3[i] <- list(lumbar_sorted[[i]]$ML[start_index_3:end_index_3]) 
  
  pull_segments$VT_1[i] <- list(lumbar_sorted[[i]]$VT[start_index_1:end_index_1])
  pull_segments$VT_2[i] <- list(lumbar_sorted[[i]]$VT[start_index_2:end_index_2])
  pull_segments$VT_3[i] <- list(lumbar_sorted[[i]]$VT[start_index_3:end_index_3]) 
  
  pull_segments$Pitch_1[i] <- list(lumbar_sorted[[i]]$Pitch[start_index_1:end_index_1])
  pull_segments$Pitch_2[i] <- list(lumbar_sorted[[i]]$Pitch[start_index_2:end_index_2])
  pull_segments$Pitch_3[i] <- list(lumbar_sorted[[i]]$Pitch[start_index_3:end_index_3]) 
  
  pull_segments$Roll_1[i] <- list(lumbar_sorted[[i]]$Roll[start_index_1:end_index_1])
  pull_segments$Roll_2[i] <- list(lumbar_sorted[[i]]$Roll[start_index_2:end_index_2])
  pull_segments$Roll_3[i] <- list(lumbar_sorted[[i]]$Roll[start_index_3:end_index_3]) 
  
  pull_segments$Yaw_1[i] <- list(lumbar_sorted[[i]]$Yaw[start_index_1:end_index_1])
  pull_segments$Yaw_2[i] <- list(lumbar_sorted[[i]]$Yaw[start_index_2:end_index_2])
  pull_segments$Yaw_3[i] <- list(lumbar_sorted[[i]]$Yaw[start_index_3:end_index_3]) 
  
  # need to truncate some segments as 2 second length is too long for a few.
  # Alternatively these observations could also be removed. As no segment lengths
  # are too short in the classes of interest (HYclass II and III), there is no
  # issue including these.
  # 1 = CT
  if (i == 1) {
    pull_segments$AP_2[[i]] <- head(pull_segments$AP_2[[i]], 96)
    pull_segments$ML_2[[i]] <- head(pull_segments$ML_2[[i]], 96)
    pull_segments$VT_2[[i]] <- head(pull_segments$VT_2[[i]], 96)
    pull_segments$Pitch_2[[i]] <- head(pull_segments$Pitch_2[[i]], 96)
    pull_segments$Roll_2[[i]] <- head(pull_segments$Roll_2[[i]], 96)
    pull_segments$Yaw_2[[i]] <- head(pull_segments$Yaw_2[[i]], 96)
  } # 33 = CT
  if (i == 33) {
    pull_segments$AP_2[[i]] <- head(pull_segments$AP_2[[i]], 90)
    pull_segments$ML_2[[i]] <- head(pull_segments$ML_2[[i]], 90)
    pull_segments$VT_2[[i]] <- head(pull_segments$VT_2[[i]], 90)
    pull_segments$Pitch_2[[i]] <- head(pull_segments$Pitch_2[[i]], 90)
    pull_segments$Roll_2[[i]] <- head(pull_segments$Roll_2[[i]], 90)
    pull_segments$Yaw_2[[i]] <- head(pull_segments$Yaw_2[[i]], 90)
  } # 34 = CT
  if (i == 34) {
    pull_segments$AP_2[[i]] <- head(pull_segments$AP_2[[i]], 88)
    pull_segments$ML_2[[i]] <- head(pull_segments$ML_2[[i]], 88)
    pull_segments$VT_2[[i]] <- head(pull_segments$VT_2[[i]], 88)
    pull_segments$Pitch_2[[i]] <- head(pull_segments$Pitch_2[[i]], 88)
    pull_segments$Roll_2[[i]] <- head(pull_segments$Roll_2[[i]], 88)
    pull_segments$Yaw_2[[i]] <- head(pull_segments$Yaw_2[[i]], 88)
  } # 35 = CT
  if (i == 35) {
    pull_segments$AP_2[[i]] <- head(pull_segments$AP_2[[i]], 86)
    pull_segments$ML_2[[i]] <- head(pull_segments$ML_2[[i]], 86)
    pull_segments$VT_2[[i]] <- head(pull_segments$VT_2[[i]], 86)
    pull_segments$Pitch_2[[i]] <- head(pull_segments$Pitch_2[[i]], 86)
    pull_segments$Roll_2[[i]] <- head(pull_segments$Roll_2[[i]], 86)
    pull_segments$Yaw_2[[i]] <- head(pull_segments$Yaw_2[[i]], 86)
  } # 38 = CT
  if (i == 38) {
    pull_segments$AP_2[[i]] <- head(pull_segments$AP_2[[i]], 98)
    pull_segments$ML_2[[i]] <- head(pull_segments$ML_2[[i]], 98)
    pull_segments$VT_2[[i]] <- head(pull_segments$VT_2[[i]], 98)
    pull_segments$Pitch_2[[i]] <- head(pull_segments$Pitch_2[[i]], 98)
    pull_segments$Roll_2[[i]] <- head(pull_segments$Roll_2[[i]], 98)
    pull_segments$Yaw_2[[i]] <- head(pull_segments$Yaw_2[[i]], 98)
  } # 51 = HYclass 1
  if (i == 51) {
    pull_segments$AP_1[[i]] <- head(pull_segments$AP_2[[i]], 92)
    pull_segments$ML_1[[i]] <- head(pull_segments$ML_2[[i]], 92)
    pull_segments$VT_1[[i]] <- head(pull_segments$VT_2[[i]], 92)
    pull_segments$Pitch_1[[i]] <- head(pull_segments$Pitch_2[[i]], 92)
    pull_segments$Roll_1[[i]] <- head(pull_segments$Roll_2[[i]], 92)
    pull_segments$Yaw_1[[i]] <- head(pull_segments$Yaw_2[[i]], 92)
    
    pull_segments$AP_2[[i]] <- head(pull_segments$AP_2[[i]], 74)
    pull_segments$ML_2[[i]] <- head(pull_segments$ML_2[[i]], 74)
    pull_segments$VT_2[[i]] <- head(pull_segments$VT_2[[i]], 74)
    pull_segments$Pitch_2[[i]] <- head(pull_segments$Pitch_2[[i]], 74)
    pull_segments$Roll_2[[i]] <- head(pull_segments$Roll_2[[i]], 74)
    pull_segments$Yaw_2[[i]] <- head(pull_segments$Yaw_2[[i]], 74)
  }
  
}


```

#### Chest

```{r segmentation_implementation_chest, echo = FALSE}
# chest_pull_segments dataset creation
chest_pull_segments <- features[1:(length(chest_sorted)), c("Subject", "HYclass")]
chest_pull_segments$AP_1 <- NA
chest_pull_segments$AP_2 <- NA
chest_pull_segments$AP_3 <- NA

chest_pull_segments$ML_1 <- NA
chest_pull_segments$ML_2 <- NA
chest_pull_segments$ML_3 <- NA

chest_pull_segments$VT_1 <- NA
chest_pull_segments$VT_2 <- NA
chest_pull_segments$VT_3 <- NA

chest_pull_segments$Pitch_1 <- NA
chest_pull_segments$Pitch_2 <- NA
chest_pull_segments$Pitch_3 <- NA

chest_pull_segments$Roll_1 <- NA
chest_pull_segments$Roll_2 <- NA
chest_pull_segments$Roll_3 <- NA

chest_pull_segments$Yaw_1 <- NA
chest_pull_segments$Yaw_2 <- NA
chest_pull_segments$Yaw_3 <- NA


# Loop over i starting from 52 (where class 2 starts) to the length of 
# chest_sorted (where the last of class 3 is stored):
for (i in 1:length(chest_sorted)) {
  # Get the start index for the segment
  start_index_1 <- segments$First[i]  # Adjusting i by -51 because segments starts counting from 52
  start_index_2 <- segments$Second[i]
  start_index_3 <- segments$Third[i]

  end_index_1 <- start_index_1 + 99
  end_index_2 <- start_index_2 + 99
  end_index_3 <- start_index_3 + 99
  
  # Extract the segment vector as a list to the variable
  chest_pull_segments$AP_1[i] <- list(chest_sorted[[i]]$AP[start_index_1:end_index_1])
  chest_pull_segments$AP_2[i] <- list(chest_sorted[[i]]$AP[start_index_2:end_index_2])
  chest_pull_segments$AP_3[i] <- list(chest_sorted[[i]]$AP[start_index_3:end_index_3])
  
  chest_pull_segments$ML_1[i] <- list(chest_sorted[[i]]$ML[start_index_1:end_index_1])
  chest_pull_segments$ML_2[i] <- list(chest_sorted[[i]]$ML[start_index_2:end_index_2])
  chest_pull_segments$ML_3[i] <- list(chest_sorted[[i]]$ML[start_index_3:end_index_3]) 
  
  chest_pull_segments$VT_1[i] <- list(chest_sorted[[i]]$VT[start_index_1:end_index_1])
  chest_pull_segments$VT_2[i] <- list(chest_sorted[[i]]$VT[start_index_2:end_index_2])
  chest_pull_segments$VT_3[i] <- list(chest_sorted[[i]]$VT[start_index_3:end_index_3]) 
  
  chest_pull_segments$Pitch_1[i] <- list(chest_sorted[[i]]$Pitch[start_index_1:end_index_1])
  chest_pull_segments$Pitch_2[i] <- list(chest_sorted[[i]]$Pitch[start_index_2:end_index_2])
  chest_pull_segments$Pitch_3[i] <- list(chest_sorted[[i]]$Pitch[start_index_3:end_index_3]) 
  
  chest_pull_segments$Roll_1[i] <- list(chest_sorted[[i]]$Roll[start_index_1:end_index_1])
  chest_pull_segments$Roll_2[i] <- list(chest_sorted[[i]]$Roll[start_index_2:end_index_2])
  chest_pull_segments$Roll_3[i] <- list(chest_sorted[[i]]$Roll[start_index_3:end_index_3]) 
  
  chest_pull_segments$Yaw_1[i] <- list(chest_sorted[[i]]$Yaw[start_index_1:end_index_1])
  chest_pull_segments$Yaw_2[i] <- list(chest_sorted[[i]]$Yaw[start_index_2:end_index_2])
  chest_pull_segments$Yaw_3[i] <- list(chest_sorted[[i]]$Yaw[start_index_3:end_index_3]) 
  
}


```

```{r test_segment_check_2, echo=FALSE, eval = FALSE}

# Loop over the length of pull_segments
for (i in 1:nrow(chest_pull_segments)) {
  # Extract the segment vector from the list in pull_segments$whichever
  segment_vector <- unlist(chest_pull_segments$ML_3[i])
  
  # Define the plot title using the Subject column
  plot_title <- paste("Subject", chest_pull_segments$Subject[i], "- test Segment")

  # Plot the segment vector
  plot(segment_vector, type = 'l', main = plot_title, xlab = "Cycle", ylab = "Acceleration (m/s^2)")
  
  abline(h = -6, col="red")
  
}


```




#### Left shank

```{r segmentation_implementation_left_shank, echo = FALSE}
# left_shank_pull_segments dataset creation
left_shank_pull_segments <- features[1:(length(left_shank_sorted)), c("Subject", "HYclass")]
left_shank_pull_segments$AP_1 <- NA
left_shank_pull_segments$AP_2 <- NA
left_shank_pull_segments$AP_3 <- NA

left_shank_pull_segments$ML_1 <- NA
left_shank_pull_segments$ML_2 <- NA
left_shank_pull_segments$ML_3 <- NA

left_shank_pull_segments$VT_1 <- NA
left_shank_pull_segments$VT_2 <- NA
left_shank_pull_segments$VT_3 <- NA

left_shank_pull_segments$Pitch_1 <- NA
left_shank_pull_segments$Pitch_2 <- NA
left_shank_pull_segments$Pitch_3 <- NA

left_shank_pull_segments$Roll_1 <- NA
left_shank_pull_segments$Roll_2 <- NA
left_shank_pull_segments$Roll_3 <- NA

left_shank_pull_segments$Yaw_1 <- NA
left_shank_pull_segments$Yaw_2 <- NA
left_shank_pull_segments$Yaw_3 <- NA


# Loop over i starting from 52 (where class 2 starts) to the length of 
# left_shank_sorted (where the last of class 3 is stored):
for (i in 1:length(left_shank_sorted)) {
  # Get the start index for the segment
  start_index_1 <- segments$First[i]  # Adjusting i by -51 because segments starts counting from 52
  start_index_2 <- segments$Second[i]
  start_index_3 <- segments$Third[i]

  end_index_1 <- start_index_1 + 99
  end_index_2 <- start_index_2 + 99
  end_index_3 <- start_index_3 + 99
  
  # Extract the segment vector as a list to the variable
  left_shank_pull_segments$AP_1[i] <- list(left_shank_sorted[[i]]$AP[start_index_1:end_index_1])
  left_shank_pull_segments$AP_2[i] <- list(left_shank_sorted[[i]]$AP[start_index_2:end_index_2])
  left_shank_pull_segments$AP_3[i] <- list(left_shank_sorted[[i]]$AP[start_index_3:end_index_3])
  
  left_shank_pull_segments$ML_1[i] <- list(left_shank_sorted[[i]]$ML[start_index_1:end_index_1])
  left_shank_pull_segments$ML_2[i] <- list(left_shank_sorted[[i]]$ML[start_index_2:end_index_2])
  left_shank_pull_segments$ML_3[i] <- list(left_shank_sorted[[i]]$ML[start_index_3:end_index_3]) 
  
  left_shank_pull_segments$VT_1[i] <- list(left_shank_sorted[[i]]$VT[start_index_1:end_index_1])
  left_shank_pull_segments$VT_2[i] <- list(left_shank_sorted[[i]]$VT[start_index_2:end_index_2])
  left_shank_pull_segments$VT_3[i] <- list(left_shank_sorted[[i]]$VT[start_index_3:end_index_3])
  
  left_shank_pull_segments$Pitch_1[i] <-
    list(left_shank_sorted[[i]]$Pitch[start_index_1:end_index_1])
  left_shank_pull_segments$Pitch_2[i] <-
    list(left_shank_sorted[[i]]$Pitch[start_index_2:end_index_2])
  left_shank_pull_segments$Pitch_3[i] <-
    list(left_shank_sorted[[i]]$Pitch[start_index_3:end_index_3]) 
  
  left_shank_pull_segments$Roll_1[i] <-
    list(left_shank_sorted[[i]]$Roll[start_index_1:end_index_1])
  left_shank_pull_segments$Roll_2[i] <-
    list(left_shank_sorted[[i]]$Roll[start_index_2:end_index_2])
  left_shank_pull_segments$Roll_3[i] <-
    list(left_shank_sorted[[i]]$Roll[start_index_3:end_index_3]) 
  
  left_shank_pull_segments$Yaw_1[i] <-
    list(left_shank_sorted[[i]]$Yaw[start_index_1:end_index_1])
  left_shank_pull_segments$Yaw_2[i] <-
    list(left_shank_sorted[[i]]$Yaw[start_index_2:end_index_2])
  left_shank_pull_segments$Yaw_3[i] <-
    list(left_shank_sorted[[i]]$Yaw[start_index_3:end_index_3]) 
  
  
}


```

```{r test_segment_check_3, echo=FALSE, eval = FALSE}

# Loop over the length of pull_segments
for (i in 1:nrow(left_shank_pull_segments)) {
  # Extract the segment vector from the list in pull_segments$whichever
  segment_vector <- unlist(left_shank_pull_segments$ML_3[i])
  
  # Define the plot title using the Subject column
  plot_title <- paste("Subject", left_shank_pull_segments$Subject[i], "- test Segment")

  # Plot the segment vector
  plot(segment_vector, type = 'l', main = plot_title, xlab = "Cycle", ylab = "Acceleration (m/s^2)")
  
  abline(h = -6, col="red")
  
}


```

#### Right shank

```{r segmentation_implementation_right_shank, echo = FALSE}
# right_shank_pull_segments dataset creation
right_shank_pull_segments <- features[1:(length(right_shank_sorted)), c("Subject", "HYclass")]
right_shank_pull_segments$AP_1 <- NA
right_shank_pull_segments$AP_2 <- NA
right_shank_pull_segments$AP_3 <- NA

right_shank_pull_segments$ML_1 <- NA
right_shank_pull_segments$ML_2 <- NA
right_shank_pull_segments$ML_3 <- NA

right_shank_pull_segments$VT_1 <- NA
right_shank_pull_segments$VT_2 <- NA
right_shank_pull_segments$VT_3 <- NA

right_shank_pull_segments$Pitch_1 <- NA
right_shank_pull_segments$Pitch_2 <- NA
right_shank_pull_segments$Pitch_3 <- NA

right_shank_pull_segments$Roll_1 <- NA
right_shank_pull_segments$Roll_2 <- NA
right_shank_pull_segments$Roll_3 <- NA

right_shank_pull_segments$Yaw_1 <- NA
right_shank_pull_segments$Yaw_2 <- NA
right_shank_pull_segments$Yaw_3 <- NA


# Loop over i starting from 52 (where class 2 starts) to the length of 
# right_shank_sorted (where the last of class 3 is stored):
for (i in 1:length(right_shank_sorted)) {
  # Get the start index for the segment
  start_index_1 <- segments$First[i]  # Adjusting i by -51 because segments starts counting from 52
  start_index_2 <- segments$Second[i]
  start_index_3 <- segments$Third[i]

  end_index_1 <- start_index_1 + 99
  end_index_2 <- start_index_2 + 99
  end_index_3 <- start_index_3 + 99
  
  # Extract the segment vector as a list to the variable
  right_shank_pull_segments$AP_1[i] <- list(right_shank_sorted[[i]]$AP[start_index_1:end_index_1])
  right_shank_pull_segments$AP_2[i] <- list(right_shank_sorted[[i]]$AP[start_index_2:end_index_2])
  right_shank_pull_segments$AP_3[i] <- list(right_shank_sorted[[i]]$AP[start_index_3:end_index_3])
  
  right_shank_pull_segments$ML_1[i] <- list(right_shank_sorted[[i]]$ML[start_index_1:end_index_1])
  right_shank_pull_segments$ML_2[i] <- list(right_shank_sorted[[i]]$ML[start_index_2:end_index_2])
  right_shank_pull_segments$ML_3[i] <- list(right_shank_sorted[[i]]$ML[start_index_3:end_index_3]) 
  
  right_shank_pull_segments$VT_1[i] <- list(right_shank_sorted[[i]]$VT[start_index_1:end_index_1])
  right_shank_pull_segments$VT_2[i] <- list(right_shank_sorted[[i]]$VT[start_index_2:end_index_2])
  right_shank_pull_segments$VT_3[i] <- list(right_shank_sorted[[i]]$VT[start_index_3:end_index_3])
  
  right_shank_pull_segments$Pitch_1[i] <-
    list(right_shank_sorted[[i]]$Pitch[start_index_1:end_index_1])
  right_shank_pull_segments$Pitch_2[i] <-
    list(right_shank_sorted[[i]]$Pitch[start_index_2:end_index_2])
  right_shank_pull_segments$Pitch_3[i] <-
    list(right_shank_sorted[[i]]$Pitch[start_index_3:end_index_3]) 
  
  right_shank_pull_segments$Roll_1[i] <-
    list(right_shank_sorted[[i]]$Roll[start_index_1:end_index_1])
  right_shank_pull_segments$Roll_2[i] <-
    list(right_shank_sorted[[i]]$Roll[start_index_2:end_index_2])
  right_shank_pull_segments$Roll_3[i] <-
    list(right_shank_sorted[[i]]$Roll[start_index_3:end_index_3]) 
  
  right_shank_pull_segments$Yaw_1[i] <-
    list(right_shank_sorted[[i]]$Yaw[start_index_1:end_index_1])
  right_shank_pull_segments$Yaw_2[i] <-
    list(right_shank_sorted[[i]]$Yaw[start_index_2:end_index_2])
  right_shank_pull_segments$Yaw_3[i] <-
    list(right_shank_sorted[[i]]$Yaw[start_index_3:end_index_3]) 
  
  
}


```

```{r test_segment_check_3, echo=FALSE, eval = FALSE}

# Loop over the length of pull_segments
for (i in 1:nrow(right_shank_pull_segments)) {
  # Extract the segment vector from the list in pull_segments$whichever
  segment_vector <- unlist(right_shank_pull_segments$ML_3[i])
  
  # Define the plot title using the Subject column
  plot_title <- paste("Subject", right_shank_pull_segments$Subject[i], "- test Segment")

  # Plot the segment vector
  plot(segment_vector, type = 'l', main = plot_title, xlab = "Cycle", ylab = "Acceleration (m/s^2)")
  
  abline(h = -6, col="red")
  
}


```


#### Left foot


```{r segmentation_implementation_left_foot, echo = FALSE}
# left_foot_pull_segments dataset creation
left_foot_pull_segments <- features[1:(length(left_foot_sorted)), c("Subject", "HYclass")]
left_foot_pull_segments$AP_1 <- NA
left_foot_pull_segments$AP_2 <- NA
left_foot_pull_segments$AP_3 <- NA

left_foot_pull_segments$ML_1 <- NA
left_foot_pull_segments$ML_2 <- NA
left_foot_pull_segments$ML_3 <- NA

left_foot_pull_segments$VT_1 <- NA
left_foot_pull_segments$VT_2 <- NA
left_foot_pull_segments$VT_3 <- NA

left_foot_pull_segments$Pitch_1 <- NA
left_foot_pull_segments$Pitch_2 <- NA
left_foot_pull_segments$Pitch_3 <- NA

left_foot_pull_segments$Roll_1 <- NA
left_foot_pull_segments$Roll_2 <- NA
left_foot_pull_segments$Roll_3 <- NA

left_foot_pull_segments$Yaw_1 <- NA
left_foot_pull_segments$Yaw_2 <- NA
left_foot_pull_segments$Yaw_3 <- NA


# Loop over i starting from 52 (where class 2 starts) to the length of 
# left_foot_sorted (where the last of class 3 is stored):
for (i in 1:length(left_foot_sorted)) {
  # Get the start index for the segment
  start_index_1 <- segments$First[i]  # Adjusting i by -51 because segments starts counting from 52
  start_index_2 <- segments$Second[i]
  start_index_3 <- segments$Third[i]

  end_index_1 <- start_index_1 + 99
  end_index_2 <- start_index_2 + 99
  end_index_3 <- start_index_3 + 99
  
  # Extract the segment vector as a list to the variable
  left_foot_pull_segments$AP_1[i] <- list(left_foot_sorted[[i]]$AP[start_index_1:end_index_1])
  left_foot_pull_segments$AP_2[i] <- list(left_foot_sorted[[i]]$AP[start_index_2:end_index_2])
  left_foot_pull_segments$AP_3[i] <- list(left_foot_sorted[[i]]$AP[start_index_3:end_index_3])
  
  left_foot_pull_segments$ML_1[i] <- list(left_foot_sorted[[i]]$ML[start_index_1:end_index_1])
  left_foot_pull_segments$ML_2[i] <- list(left_foot_sorted[[i]]$ML[start_index_2:end_index_2])
  left_foot_pull_segments$ML_3[i] <- list(left_foot_sorted[[i]]$ML[start_index_3:end_index_3]) 
  
  left_foot_pull_segments$VT_1[i] <- list(left_foot_sorted[[i]]$VT[start_index_1:end_index_1])
  left_foot_pull_segments$VT_2[i] <- list(left_foot_sorted[[i]]$VT[start_index_2:end_index_2])
  left_foot_pull_segments$VT_3[i] <- list(left_foot_sorted[[i]]$VT[start_index_3:end_index_3]) 
  
  left_foot_pull_segments$Pitch_1[i] <- list(left_foot_sorted[[i]]$Pitch[start_index_1:end_index_1])
  left_foot_pull_segments$Pitch_2[i] <- list(left_foot_sorted[[i]]$Pitch[start_index_2:end_index_2])
  left_foot_pull_segments$Pitch_3[i] <- list(left_foot_sorted[[i]]$Pitch[start_index_3:end_index_3]) 
  
  left_foot_pull_segments$Roll_1[i] <- list(left_foot_sorted[[i]]$Roll[start_index_1:end_index_1])
  left_foot_pull_segments$Roll_2[i] <- list(left_foot_sorted[[i]]$Roll[start_index_2:end_index_2])
  left_foot_pull_segments$Roll_3[i] <- list(left_foot_sorted[[i]]$Roll[start_index_3:end_index_3]) 
  
  left_foot_pull_segments$Yaw_1[i] <- list(left_foot_sorted[[i]]$Yaw[start_index_1:end_index_1])
  left_foot_pull_segments$Yaw_2[i] <- list(left_foot_sorted[[i]]$Yaw[start_index_2:end_index_2])
  left_foot_pull_segments$Yaw_3[i] <- list(left_foot_sorted[[i]]$Yaw[start_index_3:end_index_3]) 
  
  
}


```

```{r test_segment_check_3, echo=FALSE, eval = FALSE}

# Loop over the length of pull_segments
for (i in 1:nrow(left_foot_pull_segments)) {
  # Extract the segment vector from the list in pull_segments$whichever
  segment_vector <- unlist(left_foot_pull_segments$ML_3[i])
  
  # Define the plot title using the Subject column
  plot_title <- paste("Subject", left_foot_pull_segments$Subject[i], "- test Segment")

  # Plot the segment vector
  plot(segment_vector, type = 'l', main = plot_title, xlab = "Cycle", ylab = "Acceleration (m/s^2)")
  
  abline(h = -6, col="red")
  
}


```



Segments are now created with 100 cycles from the pull, including ~5 cycles before the peak amplitude of the pull.


### Outlier setup

```{r outlier_setup, echo = FALSE}
# create outlier df
# this has been checked, same order as lumbar_sorted (see attr of lumbar_sorted)
feature_outliers <- tibble(Subject = vector("list", length = 90),
                   HYclass = vector("list", length = 90))
# add subject ID
feature_outliers$Subject <- subjects$sub_num
# add H&Y class
feature_outliers$HYclass <- subjects$stage

# remove subjects with no balance data, remember these gaps later
# also need to remove subjects 8 and 78 due to bad data
feature_outliers <- feature_outliers %>%
  dplyr::filter(!(Subject %in% c(1:6, 8, 78, 81)))

# sort it into order
feature_outliers <- feature_outliers[order(feature_outliers$HYclass), ]

```

### P-value setup

```{r p.value_setup, echo = FALSE}
# create empty p-value list, need to create placeholder then drop it
p_values <- tibble(x = 1.000)
p_values <- dplyr::select(p_values, -x)

```

### 0 to 1 PEAK FOR ALL SAMPLES

```{r}

# this will perform the scale for AP axis only. To re-create features in
# all axes with the same scaling we will need to modify this as well.

# Other scaling can be used by modifyng this code

# note that the chest to lumbar max accel ratio performs even better without
# scaling w ROCAUC of 0.98 - which is expected as ratios will work better
# where scaling can remove information in ratios between two locations.

vector_cols <- c("AP_1", "AP_2", "AP_3")

# make a function for this one...
apply_scaling <- function(segment_data) {
  for (i in 1:nrow(segment_data)) {

    # Only do this calculation for HYclass 2 and 3
    if (segment_data$HYclass[[i]] == 0 || segment_data$HYclass[[i]] == 1) {
      next
    }

    for (col in vector_cols) {

      # Access the vector correctly
      vector <- segment_data[[i, col]][[1]]

      # Calculate min and max of the elements between samples 1 and 9
      segment_min <- min(vector[1:9])
      segment_max <- max(vector[1:9])

      # Scale the entire vector based on the min and max of the segment
      scaled_vector <- (vector - segment_min) / (segment_max - segment_min)

      # Assign the scaled vector back to the DataFrame
      segment_data[[i, col]][[1]] <- scaled_vector
    }
  }
  return(segment_data)
}


# Apply to each segment
pull_segments <- apply_scaling(pull_segments)
chest_pull_segments <- apply_scaling(chest_pull_segments)
left_foot_pull_segments <- apply_scaling(left_foot_pull_segments)
left_shank_pull_segments <- apply_scaling(left_shank_pull_segments)
right_shank_pull_segments <- apply_scaling(right_shank_pull_segments)

```


\newpage

## A Range

```{r Acceleration_range_all, echo=FALSE}
# # Initialize the new columns for acceleration range in AP and ML
# features$AR_AP <- NA
# features$AR_ML <- NA
# 
# # Loop through each subject to calculate acceleration range
# for(i in 1:nrow(features)) {
#   # Calculate the range for AP
#   features$AR_AP[i] <- max(lumbar_sorted[[i]]$AP, na.rm = TRUE) - min(lumbar_sorted[[i]]$AP, na.rm = TRUE)
#   
#   # Calculate the range for ML
#   features$AR_ML[i] <- max(lumbar_sorted[[i]]$ML, na.rm = TRUE) - min(lumbar_sorted[[i]]$ML, na.rm = TRUE)
# }

```

```{r Acceleration_range_segment, echo=FALSE}
# Initialize the new columns for acceleration range in AP and ML
features$AR_AP <- NA
features$AR_ML <- NA
features$AR_VT <- NA
features$AR_Pitch <- NA
features$AR_Roll <- NA
features$AR_Yaw <- NA

# Loop through each subject to calculate acceleration range
for(i in 1:nrow(features)) {
  # Calculate the range for AP
  # features$AR_AP[i] <- max(lumbar_sorted[[i]]$AP, na.rm = TRUE) - min(lumbar_sorted[[i]]$AP, na.rm = TRUE)
  AP_1 <- max(pull_segments$AP_1[[i]], na.rm = TRUE) - min(pull_segments$AP_1[[i]], na.rm = TRUE)
  AP_2 <- max(pull_segments$AP_2[[i]], na.rm = TRUE) - min(pull_segments$AP_2[[i]], na.rm = TRUE)
  AP_3 <- max(pull_segments$AP_3[[i]], na.rm = TRUE) - min(pull_segments$AP_3[[i]], na.rm = TRUE)
  
  features$AR_AP[i] <- mean(c(AP_1, AP_2, AP_3))
  
  # Calculate the range for ML
  # features$AR_ML[i] <- max(lumbar_sorted[[i]]$ML, na.rm = TRUE) - min(lumbar_sorted[[i]]$ML, na.rm = TRUE)
  ML_1 <- max(pull_segments$ML_1[[i]], na.rm = TRUE) - min(pull_segments$ML_1[[i]], na.rm = TRUE)
  ML_2 <- max(pull_segments$ML_2[[i]], na.rm = TRUE) - min(pull_segments$ML_2[[i]], na.rm = TRUE)
  ML_3 <- max(pull_segments$ML_3[[i]], na.rm = TRUE) - min(pull_segments$ML_3[[i]], na.rm = TRUE)
  
  features$AR_ML[i] <- mean(c(ML_1, ML_2, ML_3))
  
    # Calculate the range for VT
  # features$AR_VT[i] <- max(lumbar_sorted[[i]]$VT, na.rm = TRUE) - min(lumbar_sorted[[i]]$VT, na.rm = TRUE)
  VT_1 <- max(pull_segments$VT_1[[i]], na.rm = TRUE) - min(pull_segments$VT_1[[i]], na.rm = TRUE)
  VT_2 <- max(pull_segments$VT_2[[i]], na.rm = TRUE) - min(pull_segments$VT_2[[i]], na.rm = TRUE)
  VT_3 <- max(pull_segments$VT_3[[i]], na.rm = TRUE) - min(pull_segments$VT_3[[i]], na.rm = TRUE)
  
  features$AR_VT[i] <- mean(c(VT_1, VT_2, VT_3))
  
    # Calculate the range for Pitch
  # features$AR_Pitch[i] <- max(lumbar_sorted[[i]]$Pitch, na.rm = TRUE) - min(lumbar_sorted[[i]]$Pitch, na.rm = TRUE)
  Pitch_1 <- max(pull_segments$Pitch_1[[i]], na.rm = TRUE) - min(pull_segments$Pitch_1[[i]], na.rm = TRUE)
  Pitch_2 <- max(pull_segments$Pitch_2[[i]], na.rm = TRUE) - min(pull_segments$Pitch_2[[i]], na.rm = TRUE)
  Pitch_3 <- max(pull_segments$Pitch_3[[i]], na.rm = TRUE) - min(pull_segments$Pitch_3[[i]], na.rm = TRUE)
  
  features$AR_Pitch[i] <- mean(c(Pitch_1, Pitch_2, Pitch_3))
  
    # Calculate the range for Roll
  # features$AR_Roll[i] <- max(lumbar_sorted[[i]]$Roll, na.rm = TRUE) - min(lumbar_sorted[[i]]$Roll, na.rm = TRUE)
  Roll_1 <- max(pull_segments$Roll_1[[i]], na.rm = TRUE) - min(pull_segments$Roll_1[[i]], na.rm = TRUE)
  Roll_2 <- max(pull_segments$Roll_2[[i]], na.rm = TRUE) - min(pull_segments$Roll_2[[i]], na.rm = TRUE)
  Roll_3 <- max(pull_segments$Roll_3[[i]], na.rm = TRUE) - min(pull_segments$Roll_3[[i]], na.rm = TRUE)
  
  features$AR_Roll[i] <- mean(c(Roll_1, Roll_2, Roll_3))
  
    # Calculate the range for Yaw
  # features$AR_Yaw[i] <- max(lumbar_sorted[[i]]$Yaw, na.rm = TRUE) - min(lumbar_sorted[[i]]$Yaw, na.rm = TRUE)
  Yaw_1 <- max(pull_segments$Yaw_1[[i]], na.rm = TRUE) - min(pull_segments$Yaw_1[[i]], na.rm = TRUE)
  Yaw_2 <- max(pull_segments$Yaw_2[[i]], na.rm = TRUE) - min(pull_segments$Yaw_2[[i]], na.rm = TRUE)
  Yaw_3 <- max(pull_segments$Yaw_3[[i]], na.rm = TRUE) - min(pull_segments$Yaw_3[[i]], na.rm = TRUE)
  
  features$AR_Yaw[i] <- mean(c(Yaw_1, Yaw_2, Yaw_3))

}

```

### Anteroposterior

```{r Mann-Whitney-U-test_AR_AP, echo=FALSE}

# Extract AR_AP values for HYclass 2 and 3
AR_AP_HYclass2 <- features$AR_AP[features$HYclass == group_A]
AR_AP_HYclass3 <- features$AR_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AR_AP <- wilcox.test(AR_AP_HYclass2, AR_AP_HYclass3)$p.value


```



```{r AR_AP_plot, echo=FALSE}

boxplot(AR_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AR_AP", 
        main = "Acceleration Range AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r AR_AP_outliers, echo=FALSE}

feature_outliers$AR_AP <- 0

# split the data into lists based on 'HYclass'
split_data <- split(features$AR_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AR_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set AR_AP to 1
    feature_outliers$AR_AP[feature_outliers$Subject == subject_num] <- 1
  }
}


```


### Mediolateral

```{r Mann-Whitney-U-test_AR_ML, echo=FALSE}

# Extract AR_ML values for HYclass 2 and 3
AR_ML_HYclass2 <- features$AR_ML[features$HYclass == group_A]
AR_ML_HYclass3 <- features$AR_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AR_ML <-wilcox.test(AR_ML_HYclass2, AR_ML_HYclass3)$p.value


```



```{r AR_ML_plot, echo=FALSE}

boxplot(AR_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AR_ML", 
        main = "Acceleration Range ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r AR_plot_zoom, echo=FALSE}

boxplot(AR_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AR_ML", 
        outline = FALSE,
        main = "Acceleration Range - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r AR_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AR_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AR_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AR_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AR_ML[feature_outliers$Subject == subject_num] <- 1
  }
}


```

### Vertical    

```{r Mann-Whitney-U-test_AR_VT, echo=FALSE}

# Extract AR_VT values for HYclass 2 and 3
AR_VT_HYclass2 <- features$AR_VT[features$HYclass == group_A]
AR_VT_HYclass3 <- features$AR_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AR_VT <-wilcox.test(AR_VT_HYclass2, AR_VT_HYclass3)$p.value


```

```{r AR_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AR_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AR_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AR_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AR_VT[feature_outliers$Subject == subject_num] <- 1
  }
}


```

### Pitch
```{r Mann-Whitney-U-test_AR_Pitch, echo=FALSE}

# Extract AR_Pitch values for HYclass 2 and 3
AR_Pitch_HYclass2 <- features$AR_Pitch[features$HYclass == group_A]
AR_Pitch_HYclass3 <- features$AR_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AR_Pitch <-wilcox.test(AR_Pitch_HYclass2, AR_Pitch_HYclass3)$p.value


```

```{r AR_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AR_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AR_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AR_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AR_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}


```

### Roll    

```{r Mann-Whitney-U-test_AR_Roll, echo=FALSE}

# Extract AR_Roll values for HYclass 2 and 3
AR_Roll_HYclass2 <- features$AR_Roll[features$HYclass == group_A]
AR_Roll_HYclass3 <- features$AR_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AR_Roll <-wilcox.test(AR_Roll_HYclass2, AR_Roll_HYclass3)$p.value


```

```{r AR_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AR_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AR_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AR_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AR_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}


```

### Yaw   

```{r Mann-Whitney-U-test_AR_Yaw, echo=FALSE}

# Extract AR_Yaw values for HYclass 2 and 3
AR_Yaw_HYclass2 <- features$AR_Yaw[features$HYclass == group_A]
AR_Yaw_HYclass3 <- features$AR_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AR_Yaw <-wilcox.test(AR_Yaw_HYclass2, AR_Yaw_HYclass3)$p.value


```

```{r AR_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AR_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AR_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AR_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AR_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}


```

\newpage
## A Peak

This is with maximum of absolute value, but can also do just the maximum or minimum value which also produces significant results.


```{r acceleration_peak, echo = FALSE}

# Initialize the new columns for acceleration range in AP and ML
features$AP_AP <- NA
features$AP_ML <- NA
features$AP_VT <- NA
features$AP_Pitch <- NA
features$AP_Roll <- NA
features$AP_Yaw <- NA

# Loop through each subject to calculate acceleration range
for(i in 1:nrow(features)) {

  AP_1 <- max(abs(pull_segments$AP_1[[i]]), na.rm = TRUE)
  AP_2 <- max(abs(pull_segments$AP_2[[i]]), na.rm = TRUE)
  AP_3 <- max(abs(pull_segments$AP_3[[i]]), na.rm = TRUE)
  
  features$AP_AP[i] <- mean(c(AP_1, AP_2, AP_3))
  
  ML_1 <- max(abs(pull_segments$ML_1[[i]]), na.rm = TRUE)
  ML_2 <- max(abs(pull_segments$ML_2[[i]]), na.rm = TRUE)
  ML_3 <- max(abs(pull_segments$ML_3[[i]]), na.rm = TRUE)
  
  features$AP_ML[i] <- mean(c(ML_1, ML_2, ML_3))
  
  VT_1 <- max(abs(pull_segments$VT_1[[i]]), na.rm = TRUE)
  VT_2 <- max(abs(pull_segments$VT_2[[i]]), na.rm = TRUE)
  VT_3 <- max(abs(pull_segments$VT_3[[i]]), na.rm = TRUE)
  
  features$AP_VT[i] <- mean(c(VT_1, VT_2, VT_3))
  
  Pitch_1 <- max(abs(pull_segments$Pitch_1[[i]]), na.rm = TRUE)
  Pitch_2 <- max(abs(pull_segments$Pitch_2[[i]]), na.rm = TRUE)
  Pitch_3 <- max(abs(pull_segments$Pitch_3[[i]]), na.rm = TRUE)
  
  features$AP_Pitch[i] <- mean(c(Pitch_1, Pitch_2, Pitch_3))
  
  Roll_1 <- max(abs(pull_segments$Roll_1[[i]]), na.rm = TRUE)
  Roll_2 <- max(abs(pull_segments$Roll_2[[i]]), na.rm = TRUE)
  Roll_3 <- max(abs(pull_segments$Roll_3[[i]]), na.rm = TRUE)
  
  features$AP_Roll[i] <- mean(c(Roll_1, Roll_2, Roll_3))
  
  Yaw_1 <- max(abs(pull_segments$Yaw_1[[i]]), na.rm = TRUE)
  Yaw_2 <- max(abs(pull_segments$Yaw_2[[i]]), na.rm = TRUE)
  Yaw_3 <- max(abs(pull_segments$Yaw_3[[i]]), na.rm = TRUE)
  
  features$AP_Yaw[i] <- mean(c(Yaw_1, Yaw_2, Yaw_3))

}

```

### Anteroposterior


```{r Mann-Whitney-U-test_AP_AP, echo=FALSE}

# Extract AP_AP values for HYclass 2 and 3
AP_AP_HYclass2 <- features$AP_AP[features$HYclass == group_A]
AP_AP_HYclass3 <- features$AP_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AP_AP <- wilcox.test(AP_AP_HYclass2, AP_AP_HYclass3)$p.value


```


```{r AP_AP_plot, echo=FALSE}

boxplot(AP_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AP_AP", 
        main = "Acceleration Peak AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r AP_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AP_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AP_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AP_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AP_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_AP_ML, echo=FALSE}

# Extract AP_AP values for HYclass 2 and 3
AP_ML_HYclass2 <- features$AP_ML[features$HYclass == group_A]
AP_ML_HYclass3 <- features$AP_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AP_ML <- wilcox.test(AP_ML_HYclass2, AP_ML_HYclass3)$p.value



```


```{r AP_ML_plot, echo=FALSE}

boxplot(AP_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AP_ML", 
        main = "Acceleration Peak ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```
```{r AR_ML_plot_zoomed, echo=FALSE}

boxplot(AP_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AP_ML", 
        outline = FALSE,
        main = "Acceleration Peak ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r AP_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AP_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AP_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AP_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AP_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_AP_VT, echo=FALSE}

# Extract AP_AP values for HYclass 2 and 3
AP_VT_HYclass2 <- features$AP_VT[features$HYclass == group_A]
AP_VT_HYclass3 <- features$AP_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AP_VT <- wilcox.test(AP_VT_HYclass2, AP_VT_HYclass3)$p.value



```


```{r AP_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AP_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AP_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AP_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AP_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_AP_Pitch, echo=FALSE}

# Extract AP_AP values for HYclass 2 and 3
AP_Pitch_HYclass2 <- features$AP_Pitch[features$HYclass == group_A]
AP_Pitch_HYclass3 <- features$AP_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AP_Pitch <- wilcox.test(AP_Pitch_HYclass2, AP_Pitch_HYclass3)$p.value



```


```{r AP_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AP_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AP_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AP_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AP_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_AP_Roll, echo=FALSE}

# Extract AP_AP values for HYclass 2 and 3
AP_Roll_HYclass2 <- features$AP_Roll[features$HYclass == group_A]
AP_Roll_HYclass3 <- features$AP_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AP_Roll <- wilcox.test(AP_Roll_HYclass2, AP_Roll_HYclass3)$p.value



```


```{r AP_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AP_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AP_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AP_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AP_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_AP_Yaw, echo=FALSE}

# Extract AP_AP values for HYclass 2 and 3
AP_Yaw_HYclass2 <- features$AP_Yaw[features$HYclass == group_A]
AP_Yaw_HYclass3 <- features$AP_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AP_Yaw <- wilcox.test(AP_Yaw_HYclass2, AP_Yaw_HYclass3)$p.value



```


```{r AP_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AP_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AP_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AP_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AP_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## A peak left shank 

```{r acceleration_shank_peak, echo = FALSE}

# Initialize the new columns for acceleration range in AP and ML
features$Shank_AP_AP <- NA
features$Shank_AP_ML <- NA
features$Shank_AP_VT <- NA
features$Shank_AP_Pitch <- NA
features$Shank_AP_Roll <- NA
features$Shank_AP_Yaw <- NA

# Loop through each subject to calculate acceleration peak (trough)
for(i in 1:nrow(features)) {

  # max is in opposite direction of pull, should correlate with steps back
  # forward but also with knee bend as IMU is close to knee.
  
  AP_1 <- max((left_shank_pull_segments$AP_1[[i]]), na.rm = TRUE)
  AP_2 <- max((left_shank_pull_segments$AP_2[[i]]), na.rm = TRUE)
  AP_3 <- max((left_shank_pull_segments$AP_3[[i]]), na.rm = TRUE)
    
  ML_1 <- max((left_shank_pull_segments$ML_1[[i]]), na.rm = TRUE)
  ML_2 <- max((left_shank_pull_segments$ML_2[[i]]), na.rm = TRUE)
  ML_3 <- max((left_shank_pull_segments$ML_3[[i]]), na.rm = TRUE)
    
  VT_1 <- max((left_shank_pull_segments$VT_1[[i]]), na.rm = TRUE)
  VT_2 <- max((left_shank_pull_segments$VT_2[[i]]), na.rm = TRUE)
  VT_3 <- max((left_shank_pull_segments$VT_3[[i]]), na.rm = TRUE)
  
  Pitch_1 <- max((left_shank_pull_segments$Pitch_1[[i]]), na.rm = TRUE)
  Pitch_2 <- max((left_shank_pull_segments$Pitch_2[[i]]), na.rm = TRUE)
  Pitch_3 <- max((left_shank_pull_segments$Pitch_3[[i]]), na.rm = TRUE)
  
  Roll_1 <- max((left_shank_pull_segments$Roll_1[[i]]), na.rm = TRUE)
  Roll_2 <- max((left_shank_pull_segments$Roll_2[[i]]), na.rm = TRUE)
  Roll_3 <- max((left_shank_pull_segments$Roll_3[[i]]), na.rm = TRUE)
  
  Yaw_1 <- max((left_shank_pull_segments$Yaw_1[[i]]), na.rm = TRUE)
  Yaw_2 <- max((left_shank_pull_segments$Yaw_2[[i]]), na.rm = TRUE)
  Yaw_3 <- max((left_shank_pull_segments$Yaw_3[[i]]), na.rm = TRUE)
  
  features$Shank_AP_AP[i] <- mean(c(AP_1, AP_2, AP_3))
  features$Shank_AP_ML[i] <- mean(c(ML_1, ML_2, ML_3))
  features$Shank_AP_VT[i] <- mean(c(VT_1, VT_2, VT_3))
  features$Shank_AP_Pitch[i] <- mean(c(Pitch_1, Pitch_2, Pitch_3))
  features$Shank_AP_Roll[i] <- mean(c(Roll_1, Roll_2, Roll_3))
  features$Shank_AP_Yaw[i] <- mean(c(Yaw_1, Yaw_2, Yaw_3))

}

```

### Anteroposterior


```{r Mann-Whitney-U-test_Shank_AP_AP, echo=FALSE}

# Extract Shank_AP_AP values for HYclass 2 and 3
Shank_AP_AP_HYclass2 <- features$Shank_AP_AP[features$HYclass == group_A]
Shank_AP_AP_HYclass3 <- features$Shank_AP_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Shank_AP_AP <- wilcox.test(Shank_AP_AP_HYclass2, Shank_AP_AP_HYclass3)$p.value


```

```{r Shank_AP_AP_plot, echo=FALSE}

boxplot(Shank_AP_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "Shank_AP_AP", 
        main = "Shank acceleration Peak AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r Shank_AP_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Shank_AP_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Shank_AP_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Shank_AP_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Shank_AP_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral


```{r Mann-Whitney-U-test_Shank_AP_ML, echo=FALSE}

# Extract Shank_AP_ML values for HYclass 2 and 3
Shank_AP_ML_HYclass2 <- features$Shank_AP_ML[features$HYclass == group_A]
Shank_AP_ML_HYclass3 <- features$Shank_AP_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Shank_AP_ML <- wilcox.test(Shank_AP_ML_HYclass2, Shank_AP_ML_HYclass3)$p.value


```


```{r Shank_AP_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Shank_AP_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Shank_AP_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Shank_AP_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Shank_AP_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical


```{r Mann-Whitney-U-test_Shank_AP_VT, echo=FALSE}

# Extract Shank_AP_VT values for HYclass 2 and 3
Shank_AP_VT_HYclass2 <- features$Shank_AP_VT[features$HYclass == group_A]
Shank_AP_VT_HYclass3 <- features$Shank_AP_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Shank_AP_VT <- wilcox.test(Shank_AP_VT_HYclass2, Shank_AP_VT_HYclass3)$p.value


```


```{r Shank_AP_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Shank_AP_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Shank_AP_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Shank_AP_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Shank_AP_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch


```{r Mann-Whitney-U-test_Shank_AP_Pitch, echo=FALSE}

# Extract Shank_AP_Pitch values for HYclass 2 and 3
Shank_AP_Pitch_HYclass2 <- features$Shank_AP_Pitch[features$HYclass == group_A]
Shank_AP_Pitch_HYclass3 <- features$Shank_AP_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Shank_AP_Pitch <- wilcox.test(Shank_AP_Pitch_HYclass2, Shank_AP_Pitch_HYclass3)$p.value


```

```{r Shank_AP_Pitch_plot, echo=FALSE}

boxplot(Shank_AP_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "Shank_AP_Pitch", 
        main = "Shank acceleration Peak - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r Shank_AP_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Shank_AP_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Shank_AP_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Shank_AP_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Shank_AP_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll


```{r Mann-Whitney-U-test_Shank_AP_Roll, echo=FALSE}

# Extract Shank_AP_Roll values for HYclass 2 and 3
Shank_AP_Roll_HYclass2 <- features$Shank_AP_Roll[features$HYclass == group_A]
Shank_AP_Roll_HYclass3 <- features$Shank_AP_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Shank_AP_Roll <- wilcox.test(Shank_AP_Roll_HYclass2, Shank_AP_Roll_HYclass3)$p.value


```


```{r Shank_AP_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Shank_AP_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Shank_AP_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Shank_AP_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Shank_AP_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw


```{r Mann-Whitney-U-test_Shank_AP_Yaw, echo=FALSE}

# Extract Shank_AP_Yaw values for HYclass 2 and 3
Shank_AP_Yaw_HYclass2 <- features$Shank_AP_Yaw[features$HYclass == group_A]
Shank_AP_Yaw_HYclass3 <- features$Shank_AP_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Shank_AP_Yaw <- wilcox.test(Shank_AP_Yaw_HYclass2, Shank_AP_Yaw_HYclass3)$p.value


```


```{r Shank_AP_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Shank_AP_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Shank_AP_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Shank_AP_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Shank_AP_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## A trough left shank 


```{r acceleration_shank_trough, echo = FALSE}

# Initialize the new columns for acceleration range in AP and ML
features$Shank_AT_AP <- NA
features$Shank_AT_ML <- NA
features$Shank_AT_VT <- NA
features$Shank_AT_Pitch <- NA
features$Shank_AT_Roll <- NA
features$Shank_AT_Yaw <- NA

# Loop through each subject to calculate acceleration trough (trough)
for(i in 1:nrow(features)) {
  
  # minimum indicates the pull direction, should correlate with leg movement
  # in the backward direction.

  AP_1 <- min((left_shank_pull_segments$AP_1[[i]]), na.rm = TRUE)
  AP_2 <- min((left_shank_pull_segments$AP_2[[i]]), na.rm = TRUE)
  AP_3 <- min((left_shank_pull_segments$AP_3[[i]]), na.rm = TRUE)
  
  ML_1 <- min((left_shank_pull_segments$ML_1[[i]]), na.rm = TRUE)
  ML_2 <- min((left_shank_pull_segments$ML_2[[i]]), na.rm = TRUE)
  ML_3 <- min((left_shank_pull_segments$ML_3[[i]]), na.rm = TRUE)
  
  VT_1 <- min((left_shank_pull_segments$VT_1[[i]]), na.rm = TRUE)
  VT_2 <- min((left_shank_pull_segments$VT_2[[i]]), na.rm = TRUE)
  VT_3 <- min((left_shank_pull_segments$VT_3[[i]]), na.rm = TRUE)
  
  Pitch_1 <- min((left_shank_pull_segments$Pitch_1[[i]]), na.rm = TRUE)
  Pitch_2 <- min((left_shank_pull_segments$Pitch_2[[i]]), na.rm = TRUE)
  Pitch_3 <- min((left_shank_pull_segments$Pitch_3[[i]]), na.rm = TRUE)
  
  Roll_1 <- min((left_shank_pull_segments$Roll_1[[i]]), na.rm = TRUE)
  Roll_2 <- min((left_shank_pull_segments$Roll_2[[i]]), na.rm = TRUE)
  Roll_3 <- min((left_shank_pull_segments$Roll_3[[i]]), na.rm = TRUE)
  
  Yaw_1 <- min((left_shank_pull_segments$Yaw_1[[i]]), na.rm = TRUE)
  Yaw_2 <- min((left_shank_pull_segments$Yaw_2[[i]]), na.rm = TRUE)
  Yaw_3 <- min((left_shank_pull_segments$Yaw_3[[i]]), na.rm = TRUE)
  
  features$Shank_AT_AP[i] <- mean(c(AP_1, AP_2, AP_3))
  features$Shank_AT_ML[i] <- mean(c(ML_1, ML_2, ML_3))
  features$Shank_AT_VT[i] <- mean(c(VT_1, VT_2, VT_3))
  features$Shank_AT_Pitch[i] <- mean(c(Pitch_1, Pitch_2, Pitch_3))
  features$Shank_AT_Roll[i] <- mean(c(Roll_1, Roll_2, Roll_3))
  features$Shank_AT_Yaw[i] <- mean(c(Yaw_1, Yaw_2, Yaw_3))

}

```

### Anteroposterior

```{r Mann-Whitney-U-test_Shank_AT_AP, echo=FALSE}

# Extract Shank_AT_AP values for HYclass 2 and 3
Shank_AT_AP_HYclass2 <- features$Shank_AT_AP[features$HYclass == group_A]
Shank_AT_AP_HYclass3 <- features$Shank_AT_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Shank_AT_AP <- wilcox.test(Shank_AT_AP_HYclass2, Shank_AT_AP_HYclass3)$p.value


```

```{r Shank_AT_AP_plot, echo=FALSE}

boxplot(Shank_AT_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "Shank_AT_AP", 
        main = "Shank acceleration trough AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r Shank_AT_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Shank_AT_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Shank_AT_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Shank_AT_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Shank_AT_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_Shank_AT_ML, echo=FALSE}

# Extract Shank_AT_ML values for HYclass 2 and 3
Shank_AT_ML_HYclass2 <- features$Shank_AT_ML[features$HYclass == group_A]
Shank_AT_ML_HYclass3 <- features$Shank_AT_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Shank_AT_ML <- wilcox.test(Shank_AT_ML_HYclass2, Shank_AT_ML_HYclass3)$p.value


```


```{r Shank_AT_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Shank_AT_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mML them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Shank_AT_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Shank_AT_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Shank_AT_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_Shank_AT_VT, echo=FALSE}

# Extract Shank_AT_VT values for HYclass 2 and 3
Shank_AT_VT_HYclass2 <- features$Shank_AT_VT[features$HYclass == group_A]
Shank_AT_VT_HYclass3 <- features$Shank_AT_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Shank_AT_VT <- wilcox.test(Shank_AT_VT_HYclass2, Shank_AT_VT_HYclass3)$p.value


```


```{r Shank_AT_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Shank_AT_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mVT them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Shank_AT_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Shank_AT_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Shank_AT_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch

```{r Mann-Whitney-U-test_Shank_AT_Pitch, echo=FALSE}

# Extract Shank_AT_Pitch values for HYclass 2 and 3
Shank_AT_Pitch_HYclass2 <- features$Shank_AT_Pitch[features$HYclass == group_A]
Shank_AT_Pitch_HYclass3 <- features$Shank_AT_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Shank_AT_Pitch <- wilcox.test(Shank_AT_Pitch_HYclass2, Shank_AT_Pitch_HYclass3)$p.value


```

```{r Shank_AT_Pitch_plot, echo=FALSE}

boxplot(Shank_AT_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "Shank_AT_Pitch", 
        main = "Shank acceleration trough - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r Shank_AT_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Shank_AT_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Shank_AT_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Shank_AT_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Shank_AT_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_Shank_AT_Roll, echo=FALSE}

# Extract Shank_AT_Roll values for HYclass 2 and 3
Shank_AT_Roll_HYclass2 <- features$Shank_AT_Roll[features$HYclass == group_A]
Shank_AT_Roll_HYclass3 <- features$Shank_AT_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Shank_AT_Roll <- wilcox.test(Shank_AT_Roll_HYclass2, Shank_AT_Roll_HYclass3)$p.value


```


```{r Shank_AT_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Shank_AT_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Shank_AT_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Shank_AT_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Shank_AT_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_Shank_AT_Yaw, echo=FALSE}

# Extract Shank_AT_Yaw values for HYclass 2 and 3
Shank_AT_Yaw_HYclass2 <- features$Shank_AT_Yaw[features$HYclass == group_A]
Shank_AT_Yaw_HYclass3 <- features$Shank_AT_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Shank_AT_Yaw <- wilcox.test(Shank_AT_Yaw_HYclass2, Shank_AT_Yaw_HYclass3)$p.value


```


```{r Shank_AT_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Shank_AT_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Shank_AT_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Shank_AT_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Shank_AT_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## A peak left foot 


```{r acceleration_foot_peak, echo = FALSE}

# Initialize the new columns for acceleration range in AP and ML
features$Foot_AP_AP <- NA
features$Foot_AP_ML <- NA
features$Foot_AP_VT <- NA
features$Foot_AP_Pitch <- NA
features$Foot_AP_Roll <- NA
features$Foot_AP_Yaw <- NA

# Loop through each subject to calculate acceleration peak (trough)
for(i in 1:nrow(features)) {

  # max is in opposite direction of pull, should correlate with steps back
  # forward but also with knee bend as IMU is close to knee.
  
  AP_1 <- max((left_foot_pull_segments$AP_1[[i]]), na.rm = TRUE)
  AP_2 <- max((left_foot_pull_segments$AP_2[[i]]), na.rm = TRUE)
  AP_3 <- max((left_foot_pull_segments$AP_3[[i]]), na.rm = TRUE)
  
  ML_1 <- max((left_foot_pull_segments$ML_1[[i]]), na.rm = TRUE)
  ML_2 <- max((left_foot_pull_segments$ML_2[[i]]), na.rm = TRUE)
  ML_3 <- max((left_foot_pull_segments$ML_3[[i]]), na.rm = TRUE)
  
  VT_1 <- max((left_foot_pull_segments$VT_1[[i]]), na.rm = TRUE)
  VT_2 <- max((left_foot_pull_segments$VT_2[[i]]), na.rm = TRUE)
  VT_3 <- max((left_foot_pull_segments$VT_3[[i]]), na.rm = TRUE)
  
  Pitch_1 <- max((left_foot_pull_segments$Pitch_1[[i]]), na.rm = TRUE)
  Pitch_2 <- max((left_foot_pull_segments$Pitch_2[[i]]), na.rm = TRUE)
  Pitch_3 <- max((left_foot_pull_segments$Pitch_3[[i]]), na.rm = TRUE)
  
  Roll_1 <- max((left_foot_pull_segments$Roll_1[[i]]), na.rm = TRUE)
  Roll_2 <- max((left_foot_pull_segments$Roll_2[[i]]), na.rm = TRUE)
  Roll_3 <- max((left_foot_pull_segments$Roll_3[[i]]), na.rm = TRUE)
  
  Yaw_1 <- max((left_foot_pull_segments$Yaw_1[[i]]), na.rm = TRUE)
  Yaw_2 <- max((left_foot_pull_segments$Yaw_2[[i]]), na.rm = TRUE)
  Yaw_3 <- max((left_foot_pull_segments$Yaw_3[[i]]), na.rm = TRUE)
  
  
  features$Foot_AP_AP[i] <- mean(c(AP_1, AP_2, AP_3))
  features$Foot_AP_ML[i] <- mean(c(ML_1, ML_2, ML_3))
  features$Foot_AP_VT[i] <- mean(c(VT_1, VT_2, VT_3))
  features$Foot_AP_Pitch[i] <- mean(c(Pitch_1, Pitch_2, Pitch_3))
  features$Foot_AP_Roll[i] <- mean(c(Roll_1, Roll_2, Roll_3))
  features$Foot_AP_Yaw[i] <- mean(c(Yaw_1, Yaw_2, Yaw_3))

}

```

### Anteroposterior

```{r Mann-Whitney-U-test_foot_AP_AP, echo=FALSE}

# Extract foot_AP_AP values for HYclass 2 and 3
Foot_AP_AP_HYclass2 <- features$Foot_AP_AP[features$HYclass == group_A]
Foot_AP_AP_HYclass3 <- features$Foot_AP_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Foot_AP_AP <- wilcox.test(Foot_AP_AP_HYclass2, Foot_AP_AP_HYclass3)$p.value


```

```{r foot_AP_AP_plot, echo=FALSE}

boxplot(Foot_AP_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "Foot_AP_AP", 
        main = "Foot acceleration Peak AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r foot_AP_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Foot_AP_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Foot_AP_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Foot_AP_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Foot_AP_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_foot_AP_ML, echo=FALSE}

# Extract foot_AP_ML values for HYclass 2 and 3
Foot_AP_ML_HYclass2 <- features$Foot_AP_ML[features$HYclass == group_A]
Foot_AP_ML_HYclass3 <- features$Foot_AP_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Foot_AP_ML <- wilcox.test(Foot_AP_ML_HYclass2, Foot_AP_ML_HYclass3)$p.value


```


```{r foot_AP_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Foot_AP_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Foot_AP_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Foot_AP_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Foot_AP_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Vertical

```{r Mann-Whitney-U-test_foot_AP_VT, echo=FALSE}

# Extract foot_AP_VT values for HYclass 2 and 3
Foot_AP_VT_HYclass2 <- features$Foot_AP_VT[features$HYclass == group_A]
Foot_AP_VT_HYclass3 <- features$Foot_AP_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Foot_AP_VT <- wilcox.test(Foot_AP_VT_HYclass2, Foot_AP_VT_HYclass3)$p.value


```

```{r foot_AP_VT_plot, echo=FALSE}

boxplot(Foot_AP_VT ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "Foot_AP_VT", 
        main = "Foot acceleration Peak VT", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r foot_AP_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Foot_AP_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Foot_AP_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Foot_AP_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Foot_AP_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_foot_AP_Pitch, echo=FALSE}

# Extract foot_AP_Pitch values for HYclass 2 and 3
Foot_AP_Pitch_HYclass2 <- features$Foot_AP_Pitch[features$HYclass == group_A]
Foot_AP_Pitch_HYclass3 <- features$Foot_AP_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Foot_AP_Pitch <- wilcox.test(Foot_AP_Pitch_HYclass2, Foot_AP_Pitch_HYclass3)$p.value


```


```{r foot_AP_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Foot_AP_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Foot_AP_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Foot_AP_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Foot_AP_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_foot_AP_Roll, echo=FALSE}

# Extract foot_AP_Roll values for HYclass 2 and 3
Foot_AP_Roll_HYclass2 <- features$Foot_AP_Roll[features$HYclass == group_A]
Foot_AP_Roll_HYclass3 <- features$Foot_AP_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Foot_AP_Roll <- wilcox.test(Foot_AP_Roll_HYclass2, Foot_AP_Roll_HYclass3)$p.value


```


```{r foot_AP_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Foot_AP_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Foot_AP_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Foot_AP_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Foot_AP_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_foot_AP_Yaw, echo=FALSE}

# Extract foot_AP_Yaw values for HYclass 2 and 3
Foot_AP_Yaw_HYclass2 <- features$Foot_AP_Yaw[features$HYclass == group_A]
Foot_AP_Yaw_HYclass3 <- features$Foot_AP_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Foot_AP_Yaw <- wilcox.test(Foot_AP_Yaw_HYclass2, Foot_AP_Yaw_HYclass3)$p.value


```


```{r foot_AP_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Foot_AP_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Foot_AP_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Foot_AP_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Foot_AP_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## A Peak VT:ML Ratio


```{r acceleration_peak_ratio, echo = FALSE}

# Initialize the new columns for acceleration range in AP and ML
features$AP_Rat_VT.ML <- NA

# Loop through each subject to calculate acceleration range
for(i in 1:nrow(features)) {
  
  AP_1 <- max(abs(pull_segments$AP_1[[i]]), na.rm = TRUE)
  AP_2 <- max(abs(pull_segments$AP_2[[i]]), na.rm = TRUE)
  AP_3 <- max(abs(pull_segments$AP_3[[i]]), na.rm = TRUE)
  
  ML_1 <- max(abs(pull_segments$ML_1[[i]]), na.rm = TRUE)
  ML_2 <- max(abs(pull_segments$ML_2[[i]]), na.rm = TRUE)
  ML_3 <- max(abs(pull_segments$ML_3[[i]]), na.rm = TRUE)
  
  VT_1 <- max(abs(pull_segments$VT_1[[i]]), na.rm = TRUE)
  VT_2 <- max(abs(pull_segments$VT_2[[i]]), na.rm = TRUE)
  VT_3 <- max(abs(pull_segments$VT_3[[i]]), na.rm = TRUE)
  
  Pitch_1 <- max(abs(pull_segments$Pitch_1[[i]]), na.rm = TRUE)
  Pitch_2 <- max(abs(pull_segments$Pitch_2[[i]]), na.rm = TRUE)
  Pitch_3 <- max(abs(pull_segments$Pitch_3[[i]]), na.rm = TRUE)
  
  Roll_1 <- max(abs(pull_segments$Roll_1[[i]]), na.rm = TRUE)
  Roll_2 <- max(abs(pull_segments$Roll_2[[i]]), na.rm = TRUE)
  Roll_3 <- max(abs(pull_segments$Roll_3[[i]]), na.rm = TRUE)
  
  Yaw_1 <- max(abs(pull_segments$Yaw_1[[i]]), na.rm = TRUE)
  Yaw_2 <- max(abs(pull_segments$Yaw_2[[i]]), na.rm = TRUE)
  Yaw_3 <- max(abs(pull_segments$Yaw_3[[i]]), na.rm = TRUE)
  
  features$AP_Rat_VT.ML[i] <- mean(c(VT_1/ML_1, VT_2/ML_2, VT_3/ML_3))
  
}

```



```{r Mann-Whitney-U-test_AP_ratio_AP, echo=FALSE}

# Extract AP_Rat_VT values for HYclass 2 and 3
AP_Rat_VT.ML_HYclass2 <- features$AP_Rat_VT.ML[features$HYclass == group_A]
AP_Rat_VT.ML_HYclass3 <- features$AP_Rat_VT.ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AP_Rat_VT.ML <- wilcox.test(AP_Rat_VT.ML_HYclass2, AP_Rat_VT.ML_HYclass3)$p.value


```


```{r AP_ratio_AP_plot, echo=FALSE}

boxplot(AP_Rat_VT.ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AP_Rat_VT.ML", 
        main = "Acceleration Peak Ratio - VT:ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```
```{r AP_ratio_AP_plot_no_outlier, echo=FALSE}

boxplot(AP_Rat_VT.ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AP_Rat_VT.ML", 
        outline = FALSE,
        main = "Acceleration Peak Ratio - VT:ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r AP_ratio_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AP_Rat_VT.ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AP_Rat_VT.ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AP_Rat_VT.ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AP_Rat_VT.ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Acceleration Mean


```{r acceleration_mean, echo = FALSE}

# Initialize the new columns for acceleration range in AP and ML
features$Mu_AP <- NA
features$Mu_ML <- NA
features$Mu_VT <- NA
features$Mu_Pitch <- NA
features$Mu_Roll <- NA
features$Mu_Yaw <- NA

# Loop through each subject to calculate acceleration range
for(i in 1:nrow(features)) {

  AP_1 <- mean(abs(pull_segments$AP_1[[i]]), na.rm = TRUE)
  AP_2 <- mean(abs(pull_segments$AP_2[[i]]), na.rm = TRUE)
  AP_3 <- mean(abs(pull_segments$AP_3[[i]]), na.rm = TRUE)
  
  features$Mu_AP[i] <- mean(c(AP_1, AP_2, AP_3))
  
  ML_1 <- mean(abs(pull_segments$ML_1[[i]]), na.rm = TRUE)
  ML_2 <- mean(abs(pull_segments$ML_2[[i]]), na.rm = TRUE)
  ML_3 <- mean(abs(pull_segments$ML_3[[i]]), na.rm = TRUE)
  
  features$Mu_ML[i] <- mean(c(ML_1, ML_2, ML_3))
  
  VT_1 <- mean(abs(pull_segments$VT_1[[i]]), na.rm = TRUE)
  VT_2 <- mean(abs(pull_segments$VT_2[[i]]), na.rm = TRUE)
  VT_3 <- mean(abs(pull_segments$VT_3[[i]]), na.rm = TRUE)
  
  features$Mu_VT[i] <- mean(c(VT_1, VT_2, VT_3))
  
  Pitch_1 <- mean(abs(pull_segments$Pitch_1[[i]]), na.rm = TRUE)
  Pitch_2 <- mean(abs(pull_segments$Pitch_2[[i]]), na.rm = TRUE)
  Pitch_3 <- mean(abs(pull_segments$Pitch_3[[i]]), na.rm = TRUE)
  
  features$Mu_Pitch[i] <- mean(c(Pitch_1, Pitch_2, Pitch_3))
  
  Roll_1 <- mean(abs(pull_segments$Roll_1[[i]]), na.rm = TRUE)
  Roll_2 <- mean(abs(pull_segments$Roll_2[[i]]), na.rm = TRUE)
  Roll_3 <- mean(abs(pull_segments$Roll_3[[i]]), na.rm = TRUE)
  
  features$Mu_Roll[i] <- mean(c(Roll_1, Roll_2, Roll_3))
  
  Yaw_1 <- mean(abs(pull_segments$Yaw_1[[i]]), na.rm = TRUE)
  Yaw_2 <- mean(abs(pull_segments$Yaw_2[[i]]), na.rm = TRUE)
  Yaw_3 <- mean(abs(pull_segments$Yaw_3[[i]]), na.rm = TRUE)
  
  features$Mu_Yaw[i] <- mean(c(Yaw_1, Yaw_2, Yaw_3))

}

```

### Anteroposterior


```{r Mann-Whitney-U-test_Mu_AP, echo=FALSE}

# Extract Mu_AP values for HYclass 2 and 3
Mu_AP_HYclass2 <- features$Mu_AP[features$HYclass == group_A]
Mu_AP_HYclass3 <- features$Mu_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Mu_AP <- wilcox.test(Mu_AP_HYclass2, Mu_AP_HYclass3)$p.value


```


```{r Mu_AP_plot, echo=FALSE}

boxplot(Mu_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "Mu_AP", 
        main = "Acceleration Mean AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r Mu_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Mu_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Mu_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Mu_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Mu_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral


```{r Mann-Whitney-U-test_Mu_ML, echo=FALSE}

# Extract Mu_ML values for HYclass 2 and 3
Mu_ML_HYclass2 <- features$Mu_ML[features$HYclass == group_A]
Mu_ML_HYclass3 <- features$Mu_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Mu_ML <- wilcox.test(Mu_ML_HYclass2, Mu_ML_HYclass3)$p.value


```


```{r Mu_ML_plot, echo=FALSE}

boxplot(Mu_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "Mu_ML", 
        main = "Acceleration Mean ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r Mu_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Mu_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Mu_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Mu_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Mu_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical


```{r Mann-Whitney-U-test_Mu_VT, echo=FALSE}

# Extract Mu_VT values for HYclass 2 and 3
Mu_VT_HYclass2 <- features$Mu_VT[features$HYclass == group_A]
Mu_VT_HYclass3 <- features$Mu_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Mu_VT <- wilcox.test(Mu_VT_HYclass2, Mu_VT_HYclass3)$p.value


```




```{r Mu_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Mu_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Mu_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Mu_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Mu_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch


```{r Mann-Whitney-U-test_Mu_Pitch, echo=FALSE}

# Extract Mu_Pitch values for HYclass 2 and 3
Mu_Pitch_HYclass2 <- features$Mu_Pitch[features$HYclass == group_A]
Mu_Pitch_HYclass3 <- features$Mu_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Mu_Pitch <- wilcox.test(Mu_Pitch_HYclass2, Mu_Pitch_HYclass3)$p.value


```



```{r Mu_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Mu_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Mu_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Mu_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Mu_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll


```{r Mann-Whitney-U-test_Mu_Roll, echo=FALSE}

# Extract Mu_Roll values for HYclass 2 and 3
Mu_Roll_HYclass2 <- features$Mu_Roll[features$HYclass == group_A]
Mu_Roll_HYclass3 <- features$Mu_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Mu_Roll <- wilcox.test(Mu_Roll_HYclass2, Mu_Roll_HYclass3)$p.value


```



```{r Mu_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Mu_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Mu_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Mu_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Mu_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw


```{r Mann-Whitney-U-test_Mu_Yaw, echo=FALSE}

# Extract Mu_Yaw values for HYclass 2 and 3
Mu_Yaw_HYclass2 <- features$Mu_Yaw[features$HYclass == group_A]
Mu_Yaw_HYclass3 <- features$Mu_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Mu_Yaw <- wilcox.test(Mu_Yaw_HYclass2, Mu_Yaw_HYclass3)$p.value


```


```{r Mu_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Mu_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Mu_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Mu_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Mu_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Acceleration Standard Deviation


```{r acceleration_sd, echo = FALSE}

# Initialize the new columns for acceleration range in AP and ML
features$SD_AP <- NA
features$SD_ML <- NA
features$SD_VT <- NA
features$SD_Pitch <- NA
features$SD_Roll <- NA
features$SD_Yaw <- NA

# Loop through each subject to calculate acceleration range
for(i in 1:nrow(features)) {

  AP_1 <- sd(abs(pull_segments$AP_1[[i]]), na.rm = TRUE)
  AP_2 <- sd(abs(pull_segments$AP_2[[i]]), na.rm = TRUE)
  AP_3 <- sd(abs(pull_segments$AP_3[[i]]), na.rm = TRUE)
  
  features$SD_AP[i] <- mean(c(AP_1, AP_2, AP_3))
  
  ML_1 <- sd(abs(pull_segments$ML_1[[i]]), na.rm = TRUE)
  ML_2 <- sd(abs(pull_segments$ML_2[[i]]), na.rm = TRUE)
  ML_3 <- sd(abs(pull_segments$ML_3[[i]]), na.rm = TRUE)
  
  features$SD_ML[i] <- mean(c(ML_1, ML_2, ML_3))

  VT_1 <- sd(abs(pull_segments$VT_1[[i]]), na.rm = TRUE)
  VT_2 <- sd(abs(pull_segments$VT_2[[i]]), na.rm = TRUE)
  VT_3 <- sd(abs(pull_segments$VT_3[[i]]), na.rm = TRUE)
  
  features$SD_VT[i] <- mean(c(VT_1, VT_2, VT_3))

  Pitch_1 <- sd(abs(pull_segments$Pitch_1[[i]]), na.rm = TRUE)
  Pitch_2 <- sd(abs(pull_segments$Pitch_2[[i]]), na.rm = TRUE)
  Pitch_3 <- sd(abs(pull_segments$Pitch_3[[i]]), na.rm = TRUE)
  
  features$SD_Pitch[i] <- mean(c(Pitch_1, Pitch_2, Pitch_3))

  Roll_1 <- sd(abs(pull_segments$Roll_1[[i]]), na.rm = TRUE)
  Roll_2 <- sd(abs(pull_segments$Roll_2[[i]]), na.rm = TRUE)
  Roll_3 <- sd(abs(pull_segments$Roll_3[[i]]), na.rm = TRUE)
  
  features$SD_Roll[i] <- mean(c(Roll_1, Roll_2, Roll_3))

  Yaw_1 <- sd(abs(pull_segments$Yaw_1[[i]]), na.rm = TRUE)
  Yaw_2 <- sd(abs(pull_segments$Yaw_2[[i]]), na.rm = TRUE)
  Yaw_3 <- sd(abs(pull_segments$Yaw_3[[i]]), na.rm = TRUE)
  
  features$SD_Yaw[i] <- mean(c(Yaw_1, Yaw_2, Yaw_3))

}

```

### Anteroposterior


```{r Mann-Whitney-U-test_SD_AP, echo=FALSE}

# Extract SD_AP values for HYclass 2 and 3
SD_AP_HYclass2 <- features$SD_AP[features$HYclass == group_A]
SD_AP_HYclass3 <- features$SD_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SD_AP <- wilcox.test(SD_AP_HYclass2, SD_AP_HYclass3)$p.value


```


```{r SD_AP_plot, echo=FALSE}

boxplot(SD_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "SD_AP", 
        main = "Acceleration SD AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r SD_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SD_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SD_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SD_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SD_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral


```{r Mann-Whitney-U-test_SD_ML, echo=FALSE}

# Extract SD_ML values for HYclass 2 and 3
SD_ML_HYclass2 <- features$SD_ML[features$HYclass == group_A]
SD_ML_HYclass3 <- features$SD_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SD_ML <- wilcox.test(SD_ML_HYclass2, SD_ML_HYclass3)$p.value


```


```{r SD_ML_plot, echo=FALSE}

boxplot(SD_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "SD_ML", 
        main = "Acceleration SD ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r SD_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SD_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SD_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SD_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SD_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Vertical


```{r Mann-Whitney-U-test_SD_VT, echo=FALSE}

# Extract SD_VT values for HYclass 2 and 3
SD_VT_HYclass2 <- features$SD_VT[features$HYclass == group_A]
SD_VT_HYclass3 <- features$SD_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SD_VT <- wilcox.test(SD_VT_HYclass2, SD_VT_HYclass3)$p.value


```


```{r SD_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SD_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SD_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SD_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SD_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch


```{r Mann-Whitney-U-test_SD_Pitch, echo=FALSE}

# Extract SD_Pitch values for HYclass 2 and 3
SD_Pitch_HYclass2 <- features$SD_Pitch[features$HYclass == group_A]
SD_Pitch_HYclass3 <- features$SD_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SD_Pitch <- wilcox.test(SD_Pitch_HYclass2, SD_Pitch_HYclass3)$p.value


```


```{r SD_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SD_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SD_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SD_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SD_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll


```{r Mann-Whitney-U-test_SD_Roll, echo=FALSE}

# Extract SD_Roll values for HYclass 2 and 3
SD_Roll_HYclass2 <- features$SD_Roll[features$HYclass == group_A]
SD_Roll_HYclass3 <- features$SD_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SD_Roll <- wilcox.test(SD_Roll_HYclass2, SD_Roll_HYclass3)$p.value


```


```{r SD_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SD_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SD_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SD_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SD_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw


```{r Mann-Whitney-U-test_SD_Yaw, echo=FALSE}

# Extract SD_Yaw values for HYclass 2 and 3
SD_Yaw_HYclass2 <- features$SD_Yaw[features$HYclass == group_A]
SD_Yaw_HYclass3 <- features$SD_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SD_Yaw <- wilcox.test(SD_Yaw_HYclass2, SD_Yaw_HYclass3)$p.value


```


```{r SD_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SD_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SD_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SD_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SD_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Sway Area 95

### AP x ML

```{r sway_area_95, echo=FALSE}
# Initialize the new column for Sway Area 95
features$SA_95_AP.ML <- NA

# compute the chi-squared distribution value for a 95% confidence interval and 2 degrees of freedom
chi_sq_value <- qchisq(0.95, df = 2)

for(i in 1:nrow(features)) {
  
  # Combine AP and ML data into a matrix
  data_matrix_1 <- cbind(pull_segments$AP_1[[i]], pull_segments$ML_1[[i]])
  data_matrix_2 <- cbind(pull_segments$AP_2[[i]], pull_segments$ML_2[[i]])
  data_matrix_3 <- cbind(pull_segments$AP_3[[i]], pull_segments$ML_3[[i]])
  
  # Compute the covariance matrix
  cov_matrix_1 <- cov(data_matrix_1, use = "complete.obs")
  cov_matrix_2 <- cov(data_matrix_2, use = "complete.obs")
  cov_matrix_3 <- cov(data_matrix_3, use = "complete.obs")
  
  # Compute the eigenvalues of the covariance matrix
  eigenvalues_1 <- eigen(cov_matrix_1)$values
  eigenvalues_2 <- eigen(cov_matrix_2)$values
  eigenvalues_3 <- eigen(cov_matrix_3)$values
  
  # Calculate the sway area using the eigenvalues and the chi-squared value
  sa_95_1 <- pi * sqrt(eigenvalues_1[1] * eigenvalues_1[2]) * chi_sq_value
  sa_95_2 <- pi * sqrt(eigenvalues_2[1] * eigenvalues_2[2]) * chi_sq_value
  sa_95_3 <- pi * sqrt(eigenvalues_3[1] * eigenvalues_3[2]) * chi_sq_value
  
  features$SA_95_AP.ML[i] <- mean(c(sa_95_1, sa_95_2, sa_95_3))
}

```   

```{r Mann-Whitney-U-test_SA_95, echo=FALSE}

# Extract SA_95_AP values for HYclass 2 and 3
SA_95_AP.ML_HYclass2 <- features$SA_95_AP.ML[features$HYclass == group_A]
SA_95_AP.ML_HYclass3 <- features$SA_95_AP.ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SA_95_AP.ML <- wilcox.test(SA_95_AP.ML_HYclass2, SA_95_AP.ML_HYclass3)$p.value

```


```{r SA_95_plot, echo=FALSE}

boxplot(SA_95_AP.ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "SA_95_AP.ML", 
        main = "Sway Area 95% (AP x ML)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r SA_95_plot_no_outlier, echo=FALSE}

boxplot(SA_95_AP.ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "SA_95_AP.ML", 
        outline = FALSE,
        main = "Sway Area 95% (AP x ML) (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r SA_95_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SA_95_AP.ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SA_95_AP.ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SA_95_AP.ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SA_95_AP.ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### VT x ML

```{r sway_area_95_VT_ML, echo=FALSE}
# Initialize the new column for Sway Area 95
features$SA_95_VT.ML <- NA

# compute the chi-squared distribution value for a 95% confidence interval and 2 degrees of freedom
chi_sq_value <- qchisq(0.95, df = 2)

for(i in 1:nrow(features)) {
  
  # Combine AP and ML data into a matrix
  data_matrix_1 <- cbind(pull_segments$VT_1[[i]], pull_segments$ML_1[[i]])
  data_matrix_2 <- cbind(pull_segments$VT_2[[i]], pull_segments$ML_2[[i]])
  data_matrix_3 <- cbind(pull_segments$VT_3[[i]], pull_segments$ML_3[[i]])
  
  # Compute the covariance matrix
  cov_matrix_1 <- cov(data_matrix_1, use = "complete.obs")
  cov_matrix_2 <- cov(data_matrix_2, use = "complete.obs")
  cov_matrix_3 <- cov(data_matrix_3, use = "complete.obs")
  
  # Compute the eigenvalues of the covariance matrix
  eigenvalues_1 <- eigen(cov_matrix_1)$values
  eigenvalues_2 <- eigen(cov_matrix_2)$values
  eigenvalues_3 <- eigen(cov_matrix_3)$values
  
  # Calculate the sway area using the eigenvalues and the chi-squared value
  sa_95_1 <- pi * sqrt(eigenvalues_1[1] * eigenvalues_1[2]) * chi_sq_value
  sa_95_2 <- pi * sqrt(eigenvalues_2[1] * eigenvalues_2[2]) * chi_sq_value
  sa_95_3 <- pi * sqrt(eigenvalues_3[1] * eigenvalues_3[2]) * chi_sq_value
  
  features$SA_95_VT.ML[i] <- mean(c(sa_95_1, sa_95_2, sa_95_3))
}

```   

```{r Mann-Whitney-U-test_SA_95_VT_ML, echo=FALSE}

# Extract AP_AP values for HYclass 2 and 3
SA_95_VT.ML_HYclass2 <- features$SA_95_VT.ML[features$HYclass == group_A]
SA_95_VT.ML_HYclass3 <- features$SA_95_VT.ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SA_95_VT.ML <- wilcox.test(SA_95_VT.ML_HYclass2, SA_95_VT.ML_HYclass3)$p.value

```


```{r SA_95_plot_VT_ML, echo=FALSE}

boxplot(SA_95_VT.ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "SA_95_VT.ML", 
        main = "Sway Area 95% (VT x ML)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r SA_95_outliers_VT_ML, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SA_95_VT.ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SA_95_VT.ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SA_95_VT.ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SA_95_VT.ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Minor semi-axis of sway area (AP x ML)


```{r minor_semi_axis_of_sway_area, echo = FALSE}

features$mSA_SA_AP.ML <- NA

chi_sq_value <- qchisq(0.95, df = 2)

# semi-minor axis length
for(i in 1:nrow(features)) {
  
  # Combine AP and ML data into a matrix
  data_matrix_1 <- cbind(pull_segments$AP_1[[i]], pull_segments$ML_1[[i]])
  data_matrix_2 <- cbind(pull_segments$AP_2[[i]], pull_segments$ML_2[[i]])
  data_matrix_3 <- cbind(pull_segments$AP_3[[i]], pull_segments$ML_3[[i]])
  
  # Compute the covariance matrix
  cov_matrix_1 <- cov(data_matrix_1, use = "complete.obs")
  cov_matrix_2 <- cov(data_matrix_2, use = "complete.obs")
  cov_matrix_3 <- cov(data_matrix_3, use = "complete.obs")
  
  # Compute the eigenvalues of the covariance matrix
  eigenvalues_1 <- eigen(cov_matrix_1)$values
  eigenvalues_2 <- eigen(cov_matrix_2)$values
  eigenvalues_3 <- eigen(cov_matrix_3)$values
  
  # Calculate the semi-minor axis for each segment
  # the smaller eigenvalue corresponds to the semi-minor axis
  semi_minor_1 <- sqrt(min(eigenvalues_1)) * sqrt(chi_sq_value)
  semi_minor_2 <- sqrt(min(eigenvalues_2)) * sqrt(chi_sq_value)
  semi_minor_3 <- sqrt(min(eigenvalues_3)) * sqrt(chi_sq_value)

  # Optionally, store the average semi-minor axis lengths
  features$mSA_SA_AP.ML[i] <- mean(c(semi_minor_1, semi_minor_2, semi_minor_3))
}


```

```{r Mann-Whitney-U-test_mSA_SA_AP.ML, echo=FALSE}

# Extract AP_AP values for HYclass 2 and 3
mSA_SA_AP.ML_HYclass2 <- features$mSA_SA_AP.ML[features$HYclass == group_A]
mSA_SA_AP.ML_HYclass3 <- features$mSA_SA_AP.ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$mSA_SA_AP.ML <- wilcox.test(mSA_SA_AP.ML_HYclass2, mSA_SA_AP.ML_HYclass3)$p.value


```


```{r mSA_SA_AP.ML_plot, echo=FALSE}

boxplot(mSA_SA_AP.ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "mSA_SA_AP.ML", 
        main = "Minor Semiaxis of Sway Area - AP x ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r mSA_SA_AP.ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$mSA_SA_AP.ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$mSA_SA_AP.ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$mSA_SA_AP.ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$mSA_SA_AP.ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Angle of the semi major axis of sway area

```{r angle_semi_major_axis, echo = FALSE}
# Angle of acceleration sway area 95
features$Ang_MSA_SA_AP.ML <- NA

# Loop through each subject
for(i in 1:nrow(features)) {
  
  # Combine AP and ML data into matrices for each segment
  data_matrix_1 <- cbind(pull_segments$AP_1[[i]], pull_segments$ML_1[[i]])
  data_matrix_2 <- cbind(pull_segments$AP_2[[i]], pull_segments$ML_2[[i]])
  data_matrix_3 <- cbind(pull_segments$AP_3[[i]], pull_segments$ML_3[[i]])
  
  # Compute the covariance matrix for each segment
  cov_matrix_1 <- cov(data_matrix_1, use = "complete.obs")
  cov_matrix_2 <- cov(data_matrix_2, use = "complete.obs")
  cov_matrix_3 <- cov(data_matrix_3, use = "complete.obs")
  
  # Compute the eigenvalues and eigenvectors of the covariance matrix
  eigen_1 <- eigen(cov_matrix_1)
  eigen_2 <- eigen(cov_matrix_2)
  eigen_3 <- eigen(cov_matrix_3)
  
  # Calculate the angle of the semi-major axis for each segment
  angle_1 <- atan2(eigen_1$vectors[2, which.max(eigen_1$values)], 
                   eigen_1$vectors[1, which.max(eigen_1$values)])
  angle_2 <- atan2(eigen_2$vectors[2, which.max(eigen_2$values)], 
                   eigen_2$vectors[1, which.max(eigen_2$values)])
  angle_3 <- atan2(eigen_3$vectors[2, which.max(eigen_3$values)], 
                   eigen_3$vectors[1, which.max(eigen_3$values)])
  
  # Convert the angles from radians to degrees
  angle_1_deg <- (angle_1 * 180 / pi)
  angle_2_deg <- (angle_2 * 180 / pi)
  angle_3_deg <- (angle_3 * 180 / pi)

  # Store the average angle of the semi-major axis in degrees
  features$Ang_MSA_SA_AP.ML[i] <- mean(c(angle_1_deg, angle_2_deg, angle_3_deg))
}


```



```{r Mann-Whitney-U-test_Ang_MSA_SA_AP.ML, echo=FALSE}

# Extract AP_AP values for HYclass 2 and 3
Ang_MSA_SA_AP.ML_HYclass2 <- features$Ang_MSA_SA_AP.ML[features$HYclass == group_A]
Ang_MSA_SA_AP.ML_HYclass3 <- features$Ang_MSA_SA_AP.ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Ang_MSA_SA_AP.ML <- wilcox.test(Ang_MSA_SA_AP.ML_HYclass2, Ang_MSA_SA_AP.ML_HYclass3)$p.value


```


```{r Ang_MSA_SA_AP.ML_plot, echo=FALSE}

boxplot(Ang_MSA_SA_AP.ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "Ang_MSA_SA_AP.ML", 
        main = "Angle Semi major axis of Sway Area - AP x ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r Ang_MSA_SA_AP.ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Ang_MSA_SA_AP.ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Ang_MSA_SA_AP.ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Ang_MSA_SA_AP.ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Ang_MSA_SA_AP.ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Root Mean Square (RMS)


```{r RMSa, echo =FALSE}
features$RMS_AP <- NA
features$RMS_ML <- NA
features$RMS_VT <- NA
features$RMS_Pitch <- NA
features$RMS_Roll <- NA
features$RMS_Yaw <- NA

# Loop through each subject to calculate RMS relative to the mean
for(i in 1:nrow(features)) {

  rms_AP_1 <- sqrt(mean((pull_segments$AP_1[[i]])^2, na.rm = TRUE))
  rms_AP_2 <- sqrt(mean((pull_segments$AP_2[[i]])^2, na.rm = TRUE))
  rms_AP_3 <- sqrt(mean((pull_segments$AP_3[[i]])^2, na.rm = TRUE))
  
  features$RMS_AP[i] <- mean(c(rms_AP_1, rms_AP_2, rms_AP_3))
  
  rms_ML_1 <- sqrt(mean((pull_segments$ML_1[[i]])^2, na.rm = TRUE))
  rms_ML_2 <- sqrt(mean((pull_segments$ML_2[[i]])^2, na.rm = TRUE))
  rms_ML_3 <- sqrt(mean((pull_segments$ML_3[[i]])^2, na.rm = TRUE))
  
  features$RMS_ML[i] <- mean(c(rms_ML_1, rms_ML_2, rms_ML_3))
  
  rms_VT_1 <- sqrt(mean((pull_segments$VT_1[[i]])^2, na.rm = TRUE))
  rms_VT_2 <- sqrt(mean((pull_segments$VT_2[[i]])^2, na.rm = TRUE))
  rms_VT_3 <- sqrt(mean((pull_segments$VT_3[[i]])^2, na.rm = TRUE))
  
  features$RMS_VT[i] <- mean(c(rms_VT_1, rms_VT_2, rms_VT_3))

  rms_Pitch_1 <- sqrt(mean((pull_segments$Pitch_1[[i]])^2, na.rm = TRUE))
  rms_Pitch_2 <- sqrt(mean((pull_segments$Pitch_2[[i]])^2, na.rm = TRUE))
  rms_Pitch_3 <- sqrt(mean((pull_segments$Pitch_3[[i]])^2, na.rm = TRUE))
  
  features$RMS_Pitch[i] <- mean(c(rms_Pitch_1, rms_Pitch_2, rms_Pitch_3))

  rms_Roll_1 <- sqrt(mean((pull_segments$Roll_1[[i]])^2, na.rm = TRUE))
  rms_Roll_2 <- sqrt(mean((pull_segments$Roll_2[[i]])^2, na.rm = TRUE))
  rms_Roll_3 <- sqrt(mean((pull_segments$Roll_3[[i]])^2, na.rm = TRUE))
  
  features$RMS_Roll[i] <- mean(c(rms_Roll_1, rms_Roll_2, rms_Roll_3))

  rms_Yaw_1 <- sqrt(mean((pull_segments$Yaw_1[[i]])^2, na.rm = TRUE))
  rms_Yaw_2 <- sqrt(mean((pull_segments$Yaw_2[[i]])^2, na.rm = TRUE))
  rms_Yaw_3 <- sqrt(mean((pull_segments$Yaw_3[[i]])^2, na.rm = TRUE))
  
  features$RMS_Yaw[i] <- mean(c(rms_Yaw_1, rms_Yaw_2, rms_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_RMS_AP, echo=FALSE}

# Extract RMS_AP values for HYclass 2 and 3
RMS_AP_HYclass2 <- features$RMS_AP[features$HYclass == group_A]
RMS_AP_HYclass3 <- features$RMS_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$RMS_AP <- wilcox.test(RMS_AP_HYclass2, RMS_AP_HYclass3)$p.value



```


```{r RMS_AP_plot, echo=FALSE}

boxplot(RMS_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "RMS_AP", 
        main = "RMS - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r RMS_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$RMS_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$RMS_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$RMS_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$RMS_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_RMS_ML, echo=FALSE}

# Extract RMS_ML values for HYclass 2 and 3
RMS_ML_HYclass2 <- features$RMS_ML[features$HYclass == group_A]
RMS_ML_HYclass3 <- features$RMS_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$RMS_ML <- wilcox.test(RMS_ML_HYclass2, RMS_ML_HYclass3)$p.value


```


```{r RMS_ML_plot, echo=FALSE}

boxplot(RMS_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "RMS_ML", 
        #ylim = c(0.15, 1.3),
        main = "RMS - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r RMS_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$RMS_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$RMS_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$RMS_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$RMS_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_RMS_VT, echo=FALSE}

# Extract RMS_VT values for HYclass 2 and 3
RMS_VT_HYclass2 <- features$RMS_VT[features$HYclass == group_A]
RMS_VT_HYclass3 <- features$RMS_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$RMS_VT <- wilcox.test(RMS_VT_HYclass2, RMS_VT_HYclass3)$p.value


```


```{r RMS_VT_plot, echo=FALSE}

boxplot(RMS_VT ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "RMS_VT", 
        main = "RMS - VT", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r RMS_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$RMS_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$RMS_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$RMS_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$RMS_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```



### Pitch

```{r Mann-Whitney-U-test_RMS_Pitch, echo=FALSE}

# Extract RMS_Pitch values for HYclass 2 and 3
RMS_Pitch_HYclass2 <- features$RMS_Pitch[features$HYclass == group_A]
RMS_Pitch_HYclass3 <- features$RMS_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$RMS_Pitch <- wilcox.test(RMS_Pitch_HYclass2, RMS_Pitch_HYclass3)$p.value



```


```{r RMS_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$RMS_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$RMS_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$RMS_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$RMS_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_RMS_Roll, echo=FALSE}

# Extract RMS_Roll values for HYclass 2 and 3
RMS_Roll_HYclass2 <- features$RMS_Roll[features$HYclass == group_A]
RMS_Roll_HYclass3 <- features$RMS_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$RMS_Roll <- wilcox.test(RMS_Roll_HYclass2, RMS_Roll_HYclass3)$p.value



```


```{r RMS_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$RMS_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$RMS_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$RMS_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$RMS_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_RMS_Yaw, echo=FALSE}

# Extract RMS_Yaw values for HYclass 2 and 3
RMS_Yaw_HYclass2 <- features$RMS_Yaw[features$HYclass == group_A]
RMS_Yaw_HYclass3 <- features$RMS_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$RMS_Yaw <- wilcox.test(RMS_Yaw_HYclass2, RMS_Yaw_HYclass3)$p.value



```


```{r RMS_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$RMS_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$RMS_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$RMS_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$RMS_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## RMS Deviation (sway dispersion)

```{r RMS_relative_to_mean, echo =FALSE}
features$RMSD_AP <- NA
features$RMSD_ML <- NA
features$RMSD_VT <- NA
features$RMSD_Pitch <- NA
features$RMSD_Roll <- NA
features$RMSD_Yaw <- NA

# Loop through each subject to calculate RMS relative to the mean
for(i in 1:nrow(features)) {
  # Calculate the RMS relative to the mean for AP
  mean_AP_1 <- mean(pull_segments$AP_1[[i]], na.rm = TRUE)
  mean_AP_2 <- mean(pull_segments$AP_2[[i]], na.rm = TRUE)
  mean_AP_3 <- mean(pull_segments$AP_3[[i]], na.rm = TRUE)

  rms_rel_AP_1 <- sqrt(mean((pull_segments$AP_1[[i]] - mean_AP_1)^2, na.rm = TRUE))
  rms_rel_AP_2 <- sqrt(mean((pull_segments$AP_2[[i]] - mean_AP_2)^2, na.rm = TRUE))
  rms_rel_AP_3 <- sqrt(mean((pull_segments$AP_3[[i]] - mean_AP_3)^2, na.rm = TRUE))
  
  features$RMSD_AP[i] <- mean(c(rms_rel_AP_1, rms_rel_AP_2, rms_rel_AP_3))
  
  # Calculate the RMS relative to the mean for ML
  mean_ML_1 <- mean(pull_segments$ML_1[[i]], na.rm = TRUE)
  mean_ML_2 <- mean(pull_segments$ML_2[[i]], na.rm = TRUE)
  mean_ML_3 <- mean(pull_segments$ML_3[[i]], na.rm = TRUE)

  rms_rel_ML_1 <- sqrt(mean((pull_segments$ML_1[[i]] - mean_ML_1)^2, na.rm = TRUE))
  rms_rel_ML_2 <- sqrt(mean((pull_segments$ML_2[[i]] - mean_ML_2)^2, na.rm = TRUE))
  rms_rel_ML_3 <- sqrt(mean((pull_segments$ML_3[[i]] - mean_ML_3)^2, na.rm = TRUE))
  
  features$RMSD_ML[i] <- mean(c(rms_rel_ML_1, rms_rel_ML_2, rms_rel_ML_3))
  
  
  # Calculate the RMS relative to the mean for VT
  mean_VT_1 <- mean(pull_segments$VT_1[[i]], na.rm = TRUE)
  mean_VT_2 <- mean(pull_segments$VT_2[[i]], na.rm = TRUE)
  mean_VT_3 <- mean(pull_segments$VT_3[[i]], na.rm = TRUE)

  rms_rel_VT_1 <- sqrt(mean((pull_segments$VT_1[[i]] - mean_VT_1)^2, na.rm = TRUE))
  rms_rel_VT_2 <- sqrt(mean((pull_segments$VT_2[[i]] - mean_VT_2)^2, na.rm = TRUE))
  rms_rel_VT_3 <- sqrt(mean((pull_segments$VT_3[[i]] - mean_VT_3)^2, na.rm = TRUE))
  
  features$RMSD_VT[i] <- mean(c(rms_rel_VT_1, rms_rel_VT_2, rms_rel_VT_3))
  
  
  # Calculate the RMS relative to the mean for Pitch
  mean_Pitch_1 <- mean(pull_segments$Pitch_1[[i]], na.rm = TRUE)
  mean_Pitch_2 <- mean(pull_segments$Pitch_2[[i]], na.rm = TRUE)
  mean_Pitch_3 <- mean(pull_segments$Pitch_3[[i]], na.rm = TRUE)

  rms_rel_Pitch_1 <- sqrt(mean((pull_segments$Pitch_1[[i]] - mean_Pitch_1)^2, na.rm = TRUE))
  rms_rel_Pitch_2 <- sqrt(mean((pull_segments$Pitch_2[[i]] - mean_Pitch_2)^2, na.rm = TRUE))
  rms_rel_Pitch_3 <- sqrt(mean((pull_segments$Pitch_3[[i]] - mean_Pitch_3)^2, na.rm = TRUE))
  
  features$RMSD_Pitch[i] <- mean(c(rms_rel_Pitch_1, rms_rel_Pitch_2, rms_rel_Pitch_3))
  
  
  # Calculate the RMS relative to the mean for Roll
  mean_Roll_1 <- mean(pull_segments$Roll_1[[i]], na.rm = TRUE)
  mean_Roll_2 <- mean(pull_segments$Roll_2[[i]], na.rm = TRUE)
  mean_Roll_3 <- mean(pull_segments$Roll_3[[i]], na.rm = TRUE)

  rms_rel_Roll_1 <- sqrt(mean((pull_segments$Roll_1[[i]] - mean_Roll_1)^2, na.rm = TRUE))
  rms_rel_Roll_2 <- sqrt(mean((pull_segments$Roll_2[[i]] - mean_Roll_2)^2, na.rm = TRUE))
  rms_rel_Roll_3 <- sqrt(mean((pull_segments$Roll_3[[i]] - mean_Roll_3)^2, na.rm = TRUE))
  
  features$RMSD_Roll[i] <- mean(c(rms_rel_Roll_1, rms_rel_Roll_2, rms_rel_Roll_3))
  
  
  # Calculate the RMS relative to the mean for Yaw
  mean_Yaw_1 <- mean(pull_segments$Yaw_1[[i]], na.rm = TRUE)
  mean_Yaw_2 <- mean(pull_segments$Yaw_2[[i]], na.rm = TRUE)
  mean_Yaw_3 <- mean(pull_segments$Yaw_3[[i]], na.rm = TRUE)

  rms_rel_Yaw_1 <- sqrt(mean((pull_segments$Yaw_1[[i]] - mean_Yaw_1)^2, na.rm = TRUE))
  rms_rel_Yaw_2 <- sqrt(mean((pull_segments$Yaw_2[[i]] - mean_Yaw_2)^2, na.rm = TRUE))
  rms_rel_Yaw_3 <- sqrt(mean((pull_segments$Yaw_3[[i]] - mean_Yaw_3)^2, na.rm = TRUE))
  
  features$RMSD_Yaw[i] <- mean(c(rms_rel_Yaw_1, rms_rel_Yaw_2, rms_rel_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_RMSD_AP, echo=FALSE}

# Extract RMSD_AP values for HYclass 2 and 3
RMSD_AP_HYclass2 <- features$RMSD_AP[features$HYclass == group_A]
RMSD_AP_HYclass3 <- features$RMSD_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$RMSD_AP <- wilcox.test(RMSD_AP_HYclass2, RMSD_AP_HYclass3)$p.value


```


```{r RMSD_AP_plot, echo=FALSE}

boxplot(RMSD_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "RMSD_AP", 
        main = "RMS deviation - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r RMSD_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$RMSD_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$RMSD_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$RMSD_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$RMSD_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_RMSD_ML, echo=FALSE}

# Extract RMSD_ML values for HYclass 2 and 3
RMSD_ML_HYclass2 <- features$RMSD_ML[features$HYclass == group_A]
RMSD_ML_HYclass3 <- features$RMSD_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$RMSD_ML <- wilcox.test(RMSD_ML_HYclass2, RMSD_ML_HYclass3)$p.value


```


```{r RMSD_ML_plot, echo=FALSE}

boxplot(RMSD_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "RMSD_ML", 
        main = "RMS deviation - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r RMSD_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$RMSD_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$RMSD_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$RMSD_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$RMSD_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Vertical

```{r Mann-Whitney-U-test_RMSD_VT, echo=FALSE}

# Extract RMSD_VT values for HYclass 2 and 3
RMSD_VT_HYclass2 <- features$RMSD_VT[features$HYclass == group_A]
RMSD_VT_HYclass3 <- features$RMSD_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$RMSD_VT <- wilcox.test(RMSD_VT_HYclass2, RMSD_VT_HYclass3)$p.value


```



```{r RMSD_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$RMSD_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$RMSD_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$RMSD_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$RMSD_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_RMSD_Pitch, echo=FALSE}

# Extract RMSD_Pitch values for HYclass 2 and 3
RMSD_Pitch_HYclass2 <- features$RMSD_Pitch[features$HYclass == group_A]
RMSD_Pitch_HYclass3 <- features$RMSD_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$RMSD_Pitch <- wilcox.test(RMSD_Pitch_HYclass2, RMSD_Pitch_HYclass3)$p.value


```



```{r RMSD_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$RMSD_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$RMSD_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$RMSD_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$RMSD_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_RMSD_Roll, echo=FALSE}

# Extract RMSD_Roll values for HYclass 2 and 3
RMSD_Roll_HYclass2 <- features$RMSD_Roll[features$HYclass == group_A]
RMSD_Roll_HYclass3 <- features$RMSD_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$RMSD_Roll <- wilcox.test(RMSD_Roll_HYclass2, RMSD_Roll_HYclass3)$p.value


```



```{r RMSD_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$RMSD_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$RMSD_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$RMSD_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$RMSD_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_RMSD_Yaw, echo=FALSE}

# Extract RMSD_Yaw values for HYclass 2 and 3
RMSD_Yaw_HYclass2 <- features$RMSD_Yaw[features$HYclass == group_A]
RMSD_Yaw_HYclass3 <- features$RMSD_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$RMSD_Yaw <- wilcox.test(RMSD_Yaw_HYclass2, RMSD_Yaw_HYclass3)$p.value


```



```{r RMSD_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$RMSD_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$RMSD_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$RMSD_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$RMSD_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Median Squared Energy


```{r RMS, echo =FALSE}
features$MSE_AP <- NA
features$MSE_ML <- NA
features$MSE_VT <- NA
features$MSE_Pitch <- NA
features$MSE_Roll <- NA
features$MSE_Yaw <- NA

# Loop through each subject to calculate RMS relative to the mean
for(i in 1:nrow(features)) {

  mse_AP_1 <- (median((pull_segments$AP_1[[i]])^2, na.rm = TRUE))
  mse_AP_2 <- (median((pull_segments$AP_2[[i]])^2, na.rm = TRUE))
  mse_AP_3 <- (median((pull_segments$AP_3[[i]])^2, na.rm = TRUE))
  
  features$MSE_AP[i] <- mean(c(mse_AP_1, mse_AP_2, mse_AP_3))
  
  mse_ML_1 <- (median((pull_segments$ML_1[[i]])^2, na.rm = TRUE))
  mse_ML_2 <- (median((pull_segments$ML_2[[i]])^2, na.rm = TRUE))
  mse_ML_3 <- (median((pull_segments$ML_3[[i]])^2, na.rm = TRUE))
  
  features$MSE_ML[i] <- mean(c(mse_ML_1, mse_ML_2, mse_ML_3))
  
  mse_VT_1 <- (median((pull_segments$VT_1[[i]])^2, na.rm = TRUE))
  mse_VT_2 <- (median((pull_segments$VT_2[[i]])^2, na.rm = TRUE))
  mse_VT_3 <- (median((pull_segments$VT_3[[i]])^2, na.rm = TRUE))
  
  features$MSE_VT[i] <- mean(c(mse_VT_1, mse_VT_2, mse_VT_3))

  mse_Pitch_1 <- (median((pull_segments$Pitch_1[[i]])^2, na.rm = TRUE))
  mse_Pitch_2 <- (median((pull_segments$Pitch_2[[i]])^2, na.rm = TRUE))
  mse_Pitch_3 <- (median((pull_segments$Pitch_3[[i]])^2, na.rm = TRUE))
  
  features$MSE_Pitch[i] <- mean(c(mse_Pitch_1, mse_Pitch_2, mse_Pitch_3))

  mse_Roll_1 <- (median((pull_segments$Roll_1[[i]])^2, na.rm = TRUE))
  mse_Roll_2 <- (median((pull_segments$Roll_2[[i]])^2, na.rm = TRUE))
  mse_Roll_3 <- (median((pull_segments$Roll_3[[i]])^2, na.rm = TRUE))
  
  features$MSE_Roll[i] <- mean(c(mse_Roll_1, mse_Roll_2, mse_Roll_3))

  mse_Yaw_1 <- (median((pull_segments$Yaw_1[[i]])^2, na.rm = TRUE))
  mse_Yaw_2 <- (median((pull_segments$Yaw_2[[i]])^2, na.rm = TRUE))
  mse_Yaw_3 <- (median((pull_segments$Yaw_3[[i]])^2, na.rm = TRUE))
  
  features$MSE_Yaw[i] <- mean(c(mse_Yaw_1, mse_Yaw_2, mse_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_mse_AP, echo=FALSE}

# Extract MSE_AP values for HYclass 2 and 3
MSE_AP_HYclass2 <- features$MSE_AP[features$HYclass == group_A]
MSE_AP_HYclass3 <- features$MSE_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MSE_AP <- wilcox.test(MSE_AP_HYclass2, MSE_AP_HYclass3)$p.value


```


```{r RMS_AP_plot_1, echo=FALSE}

boxplot(MSE_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "MSE_AP", 
        main = "Median Square Energy - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r MSE_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MSE_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MSE_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MSE_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MSE_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_MSE_ML, echo=FALSE}

# Extract MSE_ML values for HYclass 2 and 3
MSE_ML_HYclass2 <- features$MSE_ML[features$HYclass == group_A]
MSE_ML_HYclass3 <- features$MSE_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MSE_ML <- wilcox.test(MSE_ML_HYclass2, MSE_ML_HYclass3)$p.value



```


```{r RMS_ML_plot_1, echo=FALSE}

boxplot(MSE_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "MSE_ML", 
        ylim = c(0.05, 0.7),
        main = "MSE - ML - focused view", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r MSE_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MSE_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MSE_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MSE_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MSE_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_MSE_VT, echo=FALSE}

# Extract MSE_VT values for HYclass 2 and 3
MSE_VT_HYclass2 <- features$MSE_VT[features$HYclass == group_A]
MSE_VT_HYclass3 <- features$MSE_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MSE_VT <- wilcox.test(MSE_VT_HYclass2, MSE_VT_HYclass3)$p.value



```


```{r RMS_VT_plot_1, echo=FALSE}

boxplot(MSE_VT ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "MSE_VT", 
        main = "MSE - VT", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r MSE_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MSE_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MSE_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MSE_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MSE_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_mse_Pitch, echo=FALSE}

# Extract MSE_Pitch values for HYclass 2 and 3
MSE_Pitch_HYclass2 <- features$MSE_Pitch[features$HYclass == group_A]
MSE_Pitch_HYclass3 <- features$MSE_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MSE_Pitch <- wilcox.test(MSE_Pitch_HYclass2, MSE_Pitch_HYclass3)$p.value


```


```{r MSE_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MSE_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MSE_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MSE_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MSE_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_mse_Roll, echo=FALSE}

# Extract MSE_Roll values for HYclass 2 and 3
MSE_Roll_HYclass2 <- features$MSE_Roll[features$HYclass == group_A]
MSE_Roll_HYclass3 <- features$MSE_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MSE_Roll <- wilcox.test(MSE_Roll_HYclass2, MSE_Roll_HYclass3)$p.value


```


```{r MSE_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MSE_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MSE_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MSE_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MSE_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_mse_Yaw, echo=FALSE}

# Extract MSE_Yaw values for HYclass 2 and 3
MSE_Yaw_HYclass2 <- features$MSE_Yaw[features$HYclass == group_A]
MSE_Yaw_HYclass3 <- features$MSE_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MSE_Yaw <- wilcox.test(MSE_Yaw_HYclass2, MSE_Yaw_HYclass3)$p.value


```


```{r MSE_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MSE_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MSE_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MSE_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MSE_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Foot Median Squared Energy


```{r RMS, echo =FALSE}
features$Foot_MSE_AP <- NA
features$Foot_MSE_ML <- NA
features$Foot_MSE_VT <- NA
features$Foot_MSE_Pitch <- NA
features$Foot_MSE_Roll <- NA
features$Foot_MSE_Yaw <- NA

# Loop through each subject to calculate RMS relative to the mean
for(i in 1:nrow(features)) {

  mse_AP_1 <- sqrt(median((left_foot_pull_segments$AP_1[[i]])^2, na.rm = TRUE))
  mse_AP_2 <- sqrt(median((left_foot_pull_segments$AP_2[[i]])^2, na.rm = TRUE))
  mse_AP_3 <- sqrt(median((left_foot_pull_segments$AP_3[[i]])^2, na.rm = TRUE))
  
  features$Foot_MSE_AP[i] <- mean(c(mse_AP_1, mse_AP_2, mse_AP_3))

  mse_ML_1 <- sqrt(median((left_foot_pull_segments$ML_1[[i]])^2, na.rm = TRUE))
  mse_ML_2 <- sqrt(median((left_foot_pull_segments$ML_2[[i]])^2, na.rm = TRUE))
  mse_ML_3 <- sqrt(median((left_foot_pull_segments$ML_3[[i]])^2, na.rm = TRUE))
  
  features$Foot_MSE_ML[i] <- mean(c(mse_ML_1, mse_ML_2, mse_ML_3))
  
  mse_VT_1 <- sqrt(median((left_foot_pull_segments$VT_1[[i]])^2, na.rm = TRUE))
  mse_VT_2 <- sqrt(median((left_foot_pull_segments$VT_2[[i]])^2, na.rm = TRUE))
  mse_VT_3 <- sqrt(median((left_foot_pull_segments$VT_3[[i]])^2, na.rm = TRUE))
  
  features$Foot_MSE_VT[i] <- mean(c(mse_VT_1, mse_VT_2, mse_VT_3))

  mse_Pitch_1 <- sqrt(median((left_foot_pull_segments$Pitch_1[[i]])^2, na.rm = TRUE))
  mse_Pitch_2 <- sqrt(median((left_foot_pull_segments$Pitch_2[[i]])^2, na.rm = TRUE))
  mse_Pitch_3 <- sqrt(median((left_foot_pull_segments$Pitch_3[[i]])^2, na.rm = TRUE))
  
  features$Foot_MSE_Pitch[i] <- mean(c(mse_Pitch_1, mse_Pitch_2, mse_Pitch_3))

  mse_Roll_1 <- sqrt(median((left_foot_pull_segments$Roll_1[[i]])^2, na.rm = TRUE))
  mse_Roll_2 <- sqrt(median((left_foot_pull_segments$Roll_2[[i]])^2, na.rm = TRUE))
  mse_Roll_3 <- sqrt(median((left_foot_pull_segments$Roll_3[[i]])^2, na.rm = TRUE))
  
  features$Foot_MSE_Roll[i] <- mean(c(mse_Roll_1, mse_Roll_2, mse_Roll_3))

  mse_Yaw_1 <- sqrt(median((left_foot_pull_segments$Yaw_1[[i]])^2, na.rm = TRUE))
  mse_Yaw_2 <- sqrt(median((left_foot_pull_segments$Yaw_2[[i]])^2, na.rm = TRUE))
  mse_Yaw_3 <- sqrt(median((left_foot_pull_segments$Yaw_3[[i]])^2, na.rm = TRUE))
  
  features$Foot_MSE_Yaw[i] <- mean(c(mse_Yaw_1, mse_Yaw_2, mse_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_foot_MSE_AP, echo=FALSE}

# Extract foot MSE_AP values for HYclass 2 and 3
Foot_MSE_AP_HYclass2 <- features$Foot_MSE_AP[features$HYclass == group_A]
Foot_MSE_AP_HYclass3 <- features$Foot_MSE_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Foot_MSE_AP <- wilcox.test(Foot_MSE_AP_HYclass2, Foot_MSE_AP_HYclass3)$p.value


```


```{r RMS_AP_plot_1, echo=FALSE}

boxplot(Foot_MSE_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "Foot_MSE_AP", 
        main = "Foot Median Square Energy - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r Foot_MSE_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Foot_MSE_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Foot_MSE_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Foot_MSE_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Foot_MSE_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_foot_MSE_ML, echo=FALSE}

# Extract foot MSE_ML values for HYclass 2 and 3
Foot_MSE_ML_HYclass2 <- features$Foot_MSE_ML[features$HYclass == group_A]
Foot_MSE_ML_HYclass3 <- features$Foot_MSE_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Foot_MSE_ML <- wilcox.test(Foot_MSE_ML_HYclass2, Foot_MSE_ML_HYclass3)$p.value


```


```{r Foot_MSE_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Foot_MSE_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Foot_MSE_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Foot_MSE_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Foot_MSE_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Vertical

```{r Mann-Whitney-U-test_Foot_MSE_VT, echo=FALSE}

# Extract foot MSE_VT values for HYclass 2 and 3
Foot_MSE_VT_HYclass2 <- features$Foot_MSE_VT[features$HYclass == group_A]
Foot_MSE_VT_HYclass3 <- features$Foot_MSE_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Foot_MSE_VT <- wilcox.test(Foot_MSE_VT_HYclass2, Foot_MSE_VT_HYclass3)$p.value


```


```{r RMS_VT_plot_1, echo=FALSE}

boxplot(Foot_MSE_VT ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "Foot_MSE_VT", 
        main = "Foot MSE - VT", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r Foot_Foot_MSE_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Foot_MSE_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Foot_MSE_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Foot_MSE_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Foot_MSE_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_foot_MSE_Pitch, echo=FALSE}

# Extract foot MSE_Pitch values for HYclass 2 and 3
Foot_MSE_Pitch_HYclass2 <- features$Foot_MSE_Pitch[features$HYclass == group_A]
Foot_MSE_Pitch_HYclass3 <- features$Foot_MSE_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Foot_MSE_Pitch <- wilcox.test(Foot_MSE_Pitch_HYclass2, Foot_MSE_Pitch_HYclass3)$p.value


```


```{r Foot_MSE_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Foot_MSE_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Foot_MSE_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Foot_MSE_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Foot_MSE_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_foot_MSE_Roll, echo=FALSE}

# Extract foot MSE_Roll values for HYclass 2 and 3
Foot_MSE_Roll_HYclass2 <- features$Foot_MSE_Roll[features$HYclass == group_A]
Foot_MSE_Roll_HYclass3 <- features$Foot_MSE_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Foot_MSE_Roll <- wilcox.test(Foot_MSE_Roll_HYclass2, Foot_MSE_Roll_HYclass3)$p.value


```


```{r Foot_MSE_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Foot_MSE_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Foot_MSE_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Foot_MSE_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Foot_MSE_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_foot_MSE_Yaw, echo=FALSE}

# Extract foot MSE_Yaw values for HYclass 2 and 3
Foot_MSE_Yaw_HYclass2 <- features$Foot_MSE_Yaw[features$HYclass == group_A]
Foot_MSE_Yaw_HYclass3 <- features$Foot_MSE_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Foot_MSE_Yaw <- wilcox.test(Foot_MSE_Yaw_HYclass2, Foot_MSE_Yaw_HYclass3)$p.value


```


```{r Foot_MSE_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Foot_MSE_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Foot_MSE_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Foot_MSE_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Foot_MSE_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Mean Peak Amptitude (mean amplitude fluctuation)

### Anteroposterior

```{r mean_amplitude, echo = FALSE}

features$AMP_Mean_AP <- NA
  
for(i in 1:nrow(features)) {
  # Find Peaks
  peaks_data_1 <- findpeaks(pull_segments$AP_1[[i]])
  peaks_indices_1 <- peaks_data_1[, 2]  # Indices of the peaks
  
  peaks_data_2 <- findpeaks(pull_segments$AP_2[[i]])
  peaks_indices_2 <- peaks_data_2[, 2]
  
  peaks_data_3 <- findpeaks(pull_segments$AP_3[[i]])
  peaks_indices_3 <- peaks_data_3[, 2]
  
  # Find Troughs (by finding peaks in the inverted signal)
  troughs_data_1 <- findpeaks(-pull_segments$AP_1[[i]])
  troughs_indices_1 <- troughs_data_1[, 2]  # Indices of the troughs
  
  troughs_data_2 <- findpeaks(-pull_segments$AP_2[[i]])
  troughs_indices_2 <- troughs_data_2[, 2]
  
  troughs_data_3 <- findpeaks(-pull_segments$AP_3[[i]])
  troughs_indices_3 <- troughs_data_3[, 2]
  
  # Ensure the first trough is after the first peak and the last peak is before the last trough
  if (length(troughs_indices_1) > 0 && length(peaks_indices_1) > 0) {
    if (troughs_indices_1[1] < peaks_indices_1[1]) {
      troughs_indices_1 <- troughs_indices_1[-1]
    }
    if (length(troughs_indices_1) > 0 && 
        peaks_indices_1[length(peaks_indices_1)] > troughs_indices_1[length(troughs_indices_1)]) {
      peaks_indices_1 <- peaks_indices_1[-length(peaks_indices_1)]
    }
  
    # Calculate amplitude differences between each peak and its subsequent trough
    amplitude_differences_1 <- sapply(1:length(peaks_indices_1), function(x) {
      if (x <= length(troughs_indices_1)) {
        peak_amplitude_1 <- pull_segments$AP_1[[i]][peaks_indices_1[x]]
        trough_amplitude_1 <- pull_segments$AP_1[[i]][troughs_indices_1[x]]
        return(peak_amplitude_1 - trough_amplitude_1)
      }
    })
  }
    
      # 2
  if (length(troughs_indices_2) > 0 && length(peaks_indices_2) > 0) {
    if (troughs_indices_2[1] < peaks_indices_2[1]) {
      troughs_indices_2 <- troughs_indices_2[-1]
    }
    if (length(troughs_indices_2) > 0 &&
        peaks_indices_2[length(peaks_indices_2)] > troughs_indices_2[length(troughs_indices_2)]) {
      peaks_indices_2 <- peaks_indices_2[-length(peaks_indices_2)]
    }

    # 2
    amplitude_differences_2 <- sapply(1:length(peaks_indices_2), function(x) {
      if (x <= length(troughs_indices_2)) {
        peak_amplitude_2 <- pull_segments$AP_2[[i]][peaks_indices_2[x]]
        trough_amplitude_2 <- pull_segments$AP_2[[i]][troughs_indices_2[x]]
        return(peak_amplitude_2 - trough_amplitude_2)
      }
    })
  }

    # 3
  if (length(troughs_indices_3) > 0 && length(peaks_indices_3) > 0) {
    if (troughs_indices_3[1] < peaks_indices_3[1]) {
      troughs_indices_3 <- troughs_indices_3[-1]
    }
    if (length(troughs_indices_3) > 0 &&
        peaks_indices_3[length(peaks_indices_3)] > troughs_indices_3[length(troughs_indices_3)]) {
      peaks_indices_3 <- peaks_indices_3[-length(peaks_indices_3)]
    }

    # 3
    amplitude_differences_3 <- sapply(1:length(peaks_indices_3), function(x) {
      if (x <= length(troughs_indices_3)) {
        peak_amplitude_3 <- pull_segments$AP_3[[i]][peaks_indices_3[x]]
        trough_amplitude_3 <- pull_segments$AP_3[[i]][troughs_indices_3[x]]
        return(peak_amplitude_3 - trough_amplitude_3)
      }
    })
  }
    
    mean_1 <- mean(amplitude_differences_1, na.rm = TRUE)
    mean_2 <- mean(amplitude_differences_2, na.rm = TRUE)
    mean_3 <- mean(amplitude_differences_3, na.rm = TRUE)
    
    # Compute the Mean of these differences
    features$AMP_Mean_AP[i] <- mean(c(mean_1, mean_2, mean_3))

}
  



```

```{r Mann-Whitney-U-test_AMP_Mean, echo=FALSE}

# Extract values for HYclass 2 and 3
AMP_Mean_AP_HYclass2 <- features$AMP_Mean_AP[features$HYclass == group_A]
AMP_Mean_AP_HYclass3 <- features$AMP_Mean_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AMP_Mean_AP <- 
  wilcox.test(AMP_Mean_AP_HYclass2, AMP_Mean_AP_HYclass3)$p.value

```

```{r AMP_Mean_plot, echo=FALSE}

boxplot(AMP_Mean_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AMP_Mean_AP",
        #ylim = c(0.15,2.35),
        main = "Amplitude mean - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r mean_amp_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AMP_Mean_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AMP_Mean_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AMP_Mean_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AMP_Mean_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r mean_amplitude_ml, echo = FALSE}

features$AMP_Mean_ML <- NA
  
for(i in 1:nrow(features)) {
  # Find Peaks
  peaks_data_1 <- findpeaks(pull_segments$ML_1[[i]])
  peaks_indices_1 <- peaks_data_1[, 2]  # Indices of the peaks
  
  peaks_data_2 <- findpeaks(pull_segments$ML_2[[i]])
  peaks_indices_2 <- peaks_data_2[, 2]
  
  peaks_data_3 <- findpeaks(pull_segments$ML_3[[i]])
  peaks_indices_3 <- peaks_data_3[, 2]
  
  # Find Troughs (by finding peaks in the inverted signal)
  troughs_data_1 <- findpeaks(-pull_segments$ML_1[[i]])
  troughs_indices_1 <- troughs_data_1[, 2]  # Indices of the troughs
  
  troughs_data_2 <- findpeaks(-pull_segments$ML_2[[i]])
  troughs_indices_2 <- troughs_data_2[, 2]
  
  troughs_data_3 <- findpeaks(-pull_segments$ML_3[[i]])
  troughs_indices_3 <- troughs_data_3[, 2]
  
  
  # Ensure the first trough is after the first peak and the last peak is before the last trough
  if (length(troughs_indices_1) > 0 && length(peaks_indices_1) > 0) {
    if (troughs_indices_1[1] < peaks_indices_1[1]) {
      troughs_indices_1 <- troughs_indices_1[-1]
    }
    if (length(troughs_indices_1) > 0 && 
        peaks_indices_1[length(peaks_indices_1)] > troughs_indices_1[length(troughs_indices_1)]) {
      peaks_indices_1 <- peaks_indices_1[-length(peaks_indices_1)]
    }
  
    # Calculate amplitude differences between each peak and its subsequent trough
    amplitude_differences_1 <- sapply(1:length(peaks_indices_1), function(x) {
      if (x <= length(troughs_indices_1)) {
        peak_amplitude_1 <- pull_segments$ML_1[[i]][peaks_indices_1[x]]
        trough_amplitude_1 <- pull_segments$ML_1[[i]][troughs_indices_1[x]]
        return(peak_amplitude_1 - trough_amplitude_1)
      }
    })
  }
    
      # 2
  if (length(troughs_indices_2) > 0 && length(peaks_indices_2) > 0) {
    if (troughs_indices_2[1] < peaks_indices_2[1]) {
      troughs_indices_2 <- troughs_indices_2[-1]
    }
    if (length(troughs_indices_2) > 0 &&
        peaks_indices_2[length(peaks_indices_2)] > troughs_indices_2[length(troughs_indices_2)]) {
      peaks_indices_2 <- peaks_indices_2[-length(peaks_indices_2)]
    }

    # 2
    ## This line is added, as for i = 54, as the length for peak/trough is 1 different
    ## for only the second pull of this subject. If any other combinations produce
    ## NA warning, re-use this code for #1 and #3 also...
    min_length <- min(length(peaks_indices_2), length(troughs_indices_2))
    amplitude_differences_2 <- sapply(1:min_length, function(x) {
      peak_amplitude_2 <- pull_segments$ML_2[[i]][peaks_indices_2[x]]
      trough_amplitude_2 <- pull_segments$ML_2[[i]][troughs_indices_2[x]]
      return(peak_amplitude_2 - trough_amplitude_2)
    })
  }

    # 3
  if (length(troughs_indices_3) > 0 && length(peaks_indices_3) > 0) {
    if (troughs_indices_3[1] < peaks_indices_3[1]) {
      troughs_indices_3 <- troughs_indices_3[-1]
    }
    if (length(troughs_indices_3) > 0 &&
        peaks_indices_3[length(peaks_indices_3)] > troughs_indices_3[length(troughs_indices_3)]) {
      peaks_indices_3 <- peaks_indices_3[-length(peaks_indices_3)]
    }

    # 3
    amplitude_differences_3 <- sapply(1:length(peaks_indices_3), function(x) {
      if (x <= length(troughs_indices_3)) {
        peak_amplitude_3 <- pull_segments$ML_3[[i]][peaks_indices_3[x]]
        trough_amplitude_3 <- pull_segments$ML_3[[i]][troughs_indices_3[x]]
        return(peak_amplitude_3 - trough_amplitude_3)
      }
    })
  }
    
    mean_1 <- mean(amplitude_differences_1, na.rm = TRUE)
    mean_2 <- mean(amplitude_differences_2, na.rm = TRUE)
    mean_3 <- mean(amplitude_differences_3, na.rm = TRUE)
    
    # Compute the Mean of these differences
    features$AMP_Mean_ML[i] <- mean(c(mean_1, mean_2, mean_3))

}
  



```

```{r Mann-Whitney-U-test_AMP_Mean_ml, echo=FALSE}

# Extract values for HYclass 2 and 3
AMP_Mean_ML_HYclass2 <- features$AMP_Mean_ML[features$HYclass == group_A]
AMP_Mean_ML_HYclass3 <- features$AMP_Mean_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AMP_Mean_ML <- 
  wilcox.test(AMP_Mean_ML_HYclass2, AMP_Mean_ML_HYclass3)$p.value

```

```{r AMP_Mean_plot_ML, echo=FALSE}

boxplot(AMP_Mean_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AMP_Mean_ML",
        #ylim = c(0.15,2.6),
        main = "Amplitude mean - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r mean_amp_outliers_ML, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AMP_Mean_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AMP_Mean_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AMP_Mean_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AMP_Mean_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r mean_amplitude, echo = FALSE}

features$AMP_Mean_VT <- NA
  
for(i in 1:nrow(features)) {
  # Find Peaks
  peaks_data_1 <- findpeaks(pull_segments$VT_1[[i]])
  peaks_indices_1 <- peaks_data_1[, 2]  # Indices of the peaks
  
  peaks_data_2 <- findpeaks(pull_segments$VT_2[[i]])
  peaks_indices_2 <- peaks_data_2[, 2]
  
  peaks_data_3 <- findpeaks(pull_segments$VT_3[[i]])
  peaks_indices_3 <- peaks_data_3[, 2]
  
  # Find Troughs (by finding peaks in the inverted signal)
  troughs_data_1 <- findpeaks(-pull_segments$VT_1[[i]])
  troughs_indices_1 <- troughs_data_1[, 2]  # Indices of the troughs
  
  troughs_data_2 <- findpeaks(-pull_segments$VT_2[[i]])
  troughs_indices_2 <- troughs_data_2[, 2]
  
  troughs_data_3 <- findpeaks(-pull_segments$VT_3[[i]])
  troughs_indices_3 <- troughs_data_3[, 2]
  
  # Ensure the first trough is after the first peak and the last peak is before the last trough
  if (length(troughs_indices_1) > 0 && length(peaks_indices_1) > 0) {
    if (troughs_indices_1[1] < peaks_indices_1[1]) {
      troughs_indices_1 <- troughs_indices_1[-1]
    }
    if (length(troughs_indices_1) > 0 && 
        peaks_indices_1[length(peaks_indices_1)] > troughs_indices_1[length(troughs_indices_1)]) {
      peaks_indices_1 <- peaks_indices_1[-length(peaks_indices_1)]
    }
  
    # Calculate amplitude differences between each peak and its subsequent trough
    amplitude_differences_1 <- sapply(1:length(peaks_indices_1), function(x) {
      if (x <= length(troughs_indices_1)) {
        peak_amplitude_1 <- pull_segments$VT_1[[i]][peaks_indices_1[x]]
        trough_amplitude_1 <- pull_segments$VT_1[[i]][troughs_indices_1[x]]
        return(peak_amplitude_1 - trough_amplitude_1)
      }
    })
  }
    
      # 2
  if (length(troughs_indices_2) > 0 && length(peaks_indices_2) > 0) {
    if (troughs_indices_2[1] < peaks_indices_2[1]) {
      troughs_indices_2 <- troughs_indices_2[-1]
    }
    if (length(troughs_indices_2) > 0 &&
        peaks_indices_2[length(peaks_indices_2)] > troughs_indices_2[length(troughs_indices_2)]) {
      peaks_indices_2 <- peaks_indices_2[-length(peaks_indices_2)]
    }

    # 2
    amplitude_differences_2 <- sapply(1:length(peaks_indices_2), function(x) {
      if (x <= length(troughs_indices_2)) {
        peak_amplitude_2 <- pull_segments$VT_2[[i]][peaks_indices_2[x]]
        trough_amplitude_2 <- pull_segments$VT_2[[i]][troughs_indices_2[x]]
        return(peak_amplitude_2 - trough_amplitude_2)
      }
    })
  }

    # 3
  if (length(troughs_indices_3) > 0 && length(peaks_indices_3) > 0) {
    if (troughs_indices_3[1] < peaks_indices_3[1]) {
      troughs_indices_3 <- troughs_indices_3[-1]
    }
    if (length(troughs_indices_3) > 0 &&
        peaks_indices_3[length(peaks_indices_3)] > troughs_indices_3[length(troughs_indices_3)]) {
      peaks_indices_3 <- peaks_indices_3[-length(peaks_indices_3)]
    }

    # 3
    amplitude_differences_3 <- sapply(1:length(peaks_indices_3), function(x) {
      if (x <= length(troughs_indices_3)) {
        peak_amplitude_3 <- pull_segments$VT_3[[i]][peaks_indices_3[x]]
        trough_amplitude_3 <- pull_segments$VT_3[[i]][troughs_indices_3[x]]
        return(peak_amplitude_3 - trough_amplitude_3)
      }
    })
  }
    
    mean_1 <- mean(amplitude_differences_1, na.rm = TRUE)
    mean_2 <- mean(amplitude_differences_2, na.rm = TRUE)
    mean_3 <- mean(amplitude_differences_3, na.rm = TRUE)
    
    # Compute the Mean of these differences
    features$AMP_Mean_VT[i] <- mean(c(mean_1, mean_2, mean_3))

}
  



```

```{r Mann-Whitney-U-test_AMP_Mean, echo=FALSE}

# Extract values for HYclass 2 and 3
AMP_Mean_VT_HYclass2 <- features$AMP_Mean_VT[features$HYclass == group_A]
AMP_Mean_VT_HYclass3 <- features$AMP_Mean_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AMP_Mean_VT <- 
  wilcox.test(AMP_Mean_VT_HYclass2, AMP_Mean_VT_HYclass3)$p.value

```


```{r mean_amp_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AMP_Mean_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AMP_Mean_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AMP_Mean_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AMP_Mean_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch

```{r mean_amplitude, echo = FALSE}

features$AMP_Mean_Pitch <- NA
  
for(i in 1:nrow(features)) {
  # Find Peaks
  peaks_data_1 <- findpeaks(pull_segments$Pitch_1[[i]])
  peaks_indices_1 <- peaks_data_1[, 2]  # Indices of the peaks
  
  peaks_data_2 <- findpeaks(pull_segments$Pitch_2[[i]])
  peaks_indices_2 <- peaks_data_2[, 2]
  
  peaks_data_3 <- findpeaks(pull_segments$Pitch_3[[i]])
  peaks_indices_3 <- peaks_data_3[, 2]
  
  # Find Troughs (by finding peaks in the inverted signal)
  troughs_data_1 <- findpeaks(-pull_segments$Pitch_1[[i]])
  troughs_indices_1 <- troughs_data_1[, 2]  # Indices of the troughs
  
  troughs_data_2 <- findpeaks(-pull_segments$Pitch_2[[i]])
  troughs_indices_2 <- troughs_data_2[, 2]
  
  troughs_data_3 <- findpeaks(-pull_segments$Pitch_3[[i]])
  troughs_indices_3 <- troughs_data_3[, 2]
  
  # Ensure the first trough is after the first peak and the last peak is before the last trough
  if (length(troughs_indices_1) > 0 && length(peaks_indices_1) > 0) {
    if (troughs_indices_1[1] < peaks_indices_1[1]) {
      troughs_indices_1 <- troughs_indices_1[-1]
    }
    if (length(troughs_indices_1) > 0 && 
        peaks_indices_1[length(peaks_indices_1)] > troughs_indices_1[length(troughs_indices_1)]) {
      peaks_indices_1 <- peaks_indices_1[-length(peaks_indices_1)]
    }
  
    # Calculate amplitude differences between each peak and its subsequent trough
    amplitude_differences_1 <- sapply(1:length(peaks_indices_1), function(x) {
      if (x <= length(troughs_indices_1)) {
        peak_amplitude_1 <- pull_segments$Pitch_1[[i]][peaks_indices_1[x]]
        trough_amplitude_1 <- pull_segments$Pitch_1[[i]][troughs_indices_1[x]]
        return(peak_amplitude_1 - trough_amplitude_1)
      }
    })
  }
    
      # 2
  if (length(troughs_indices_2) > 0 && length(peaks_indices_2) > 0) {
    if (troughs_indices_2[1] < peaks_indices_2[1]) {
      troughs_indices_2 <- troughs_indices_2[-1]
    }
    if (length(troughs_indices_2) > 0 &&
        peaks_indices_2[length(peaks_indices_2)] > troughs_indices_2[length(troughs_indices_2)]) {
      peaks_indices_2 <- peaks_indices_2[-length(peaks_indices_2)]
    }

    # 2
    amplitude_differences_2 <- sapply(1:length(peaks_indices_2), function(x) {
      if (x <= length(troughs_indices_2)) {
        peak_amplitude_2 <- pull_segments$Pitch_2[[i]][peaks_indices_2[x]]
        trough_amplitude_2 <- pull_segments$Pitch_2[[i]][troughs_indices_2[x]]
        return(peak_amplitude_2 - trough_amplitude_2)
      }
    })
  }

    # 3
  if (length(troughs_indices_3) > 0 && length(peaks_indices_3) > 0) {
    if (troughs_indices_3[1] < peaks_indices_3[1]) {
      troughs_indices_3 <- troughs_indices_3[-1]
    }
    if (length(troughs_indices_3) > 0 &&
        peaks_indices_3[length(peaks_indices_3)] > troughs_indices_3[length(troughs_indices_3)]) {
      peaks_indices_3 <- peaks_indices_3[-length(peaks_indices_3)]
    }

    # 3
    amplitude_differences_3 <- sapply(1:length(peaks_indices_3), function(x) {
      if (x <= length(troughs_indices_3)) {
        peak_amplitude_3 <- pull_segments$Pitch_3[[i]][peaks_indices_3[x]]
        trough_amplitude_3 <- pull_segments$Pitch_3[[i]][troughs_indices_3[x]]
        return(peak_amplitude_3 - trough_amplitude_3)
      }
    })
  }
    
    mean_1 <- mean(amplitude_differences_1, na.rm = TRUE)
    mean_2 <- mean(amplitude_differences_2, na.rm = TRUE)
    mean_3 <- mean(amplitude_differences_3, na.rm = TRUE)
    
    # Compute the Mean of these differences
    features$AMP_Mean_Pitch[i] <- mean(c(mean_1, mean_2, mean_3))

}
  



```

```{r Mann-Whitney-U-test_AMP_Mean, echo=FALSE}

# Extract values for HYclass 2 and 3
AMP_Mean_Pitch_HYclass2 <- features$AMP_Mean_Pitch[features$HYclass == group_A]
AMP_Mean_Pitch_HYclass3 <- features$AMP_Mean_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AMP_Mean_Pitch <- 
  wilcox.test(AMP_Mean_Pitch_HYclass2, AMP_Mean_Pitch_HYclass3)$p.value

```


```{r mean_amp_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AMP_Mean_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AMP_Mean_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AMP_Mean_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AMP_Mean_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r mean_amplitude_Roll, echo = FALSE}

features$AMP_Mean_Roll <- NA
  
for(i in 1:nrow(features)) {
  # Find Peaks
  peaks_data_1 <- findpeaks(pull_segments$Roll_1[[i]])
  peaks_indices_1 <- peaks_data_1[, 2]  # Indices of the peaks
  
  peaks_data_2 <- findpeaks(pull_segments$Roll_2[[i]])
  peaks_indices_2 <- peaks_data_2[, 2]
  
  peaks_data_3 <- findpeaks(pull_segments$Roll_3[[i]])
  peaks_indices_3 <- peaks_data_3[, 2]
  
  # Find Troughs (by finding peaks in the inverted signal)
  troughs_data_1 <- findpeaks(-pull_segments$Roll_1[[i]])
  troughs_indices_1 <- troughs_data_1[, 2]  # Indices of the troughs
  
  troughs_data_2 <- findpeaks(-pull_segments$Roll_2[[i]])
  troughs_indices_2 <- troughs_data_2[, 2]
  
  troughs_data_3 <- findpeaks(-pull_segments$Roll_3[[i]])
  troughs_indices_3 <- troughs_data_3[, 2]
  
  
  # Ensure the first trough is after the first peak and the last peak is before the last trough
  if (length(troughs_indices_1) > 0 && length(peaks_indices_1) > 0) {
    if (troughs_indices_1[1] < peaks_indices_1[1]) {
      troughs_indices_1 <- troughs_indices_1[-1]
    }
    if (length(troughs_indices_1) > 0 && 
        peaks_indices_1[length(peaks_indices_1)] > troughs_indices_1[length(troughs_indices_1)]) {
      peaks_indices_1 <- peaks_indices_1[-length(peaks_indices_1)]
    }
  
    # Calculate amplitude differences between each peak and its subsequent trough
    amplitude_differences_1 <- sapply(1:length(peaks_indices_1), function(x) {
      if (x <= length(troughs_indices_1)) {
        peak_amplitude_1 <- pull_segments$Roll_1[[i]][peaks_indices_1[x]]
        trough_amplitude_1 <- pull_segments$Roll_1[[i]][troughs_indices_1[x]]
        return(peak_amplitude_1 - trough_amplitude_1)
      }
    })
  }
    
      # 2
  if (length(troughs_indices_2) > 0 && length(peaks_indices_2) > 0) {
    if (troughs_indices_2[1] < peaks_indices_2[1]) {
      troughs_indices_2 <- troughs_indices_2[-1]
    }
    if (length(troughs_indices_2) > 0 &&
        peaks_indices_2[length(peaks_indices_2)] > troughs_indices_2[length(troughs_indices_2)]) {
      peaks_indices_2 <- peaks_indices_2[-length(peaks_indices_2)]
    }

    # 2
    ## This line is added, as for i = 54, as the length for peak/trough is 1 different
    ## for only the second pull of this subject. If any other combinations produce
    ## NA warning, re-use this code for #1 and #3 also...
    min_length <- min(length(peaks_indices_2), length(troughs_indices_2))
    amplitude_differences_2 <- sapply(1:min_length, function(x) {
      peak_amplitude_2 <- pull_segments$Roll_2[[i]][peaks_indices_2[x]]
      trough_amplitude_2 <- pull_segments$Roll_2[[i]][troughs_indices_2[x]]
      return(peak_amplitude_2 - trough_amplitude_2)
    })
  }

    # 3
  if (length(troughs_indices_3) > 0 && length(peaks_indices_3) > 0) {
    if (troughs_indices_3[1] < peaks_indices_3[1]) {
      troughs_indices_3 <- troughs_indices_3[-1]
    }
    if (length(troughs_indices_3) > 0 &&
        peaks_indices_3[length(peaks_indices_3)] > troughs_indices_3[length(troughs_indices_3)]) {
      peaks_indices_3 <- peaks_indices_3[-length(peaks_indices_3)]
    }

    # 3
    amplitude_differences_3 <- sapply(1:length(peaks_indices_3), function(x) {
      if (x <= length(troughs_indices_3)) {
        peak_amplitude_3 <- pull_segments$Roll_3[[i]][peaks_indices_3[x]]
        trough_amplitude_3 <- pull_segments$Roll_3[[i]][troughs_indices_3[x]]
        return(peak_amplitude_3 - trough_amplitude_3)
      }
    })
  }
    
    mean_1 <- mean(amplitude_differences_1, na.rm = TRUE)
    mean_2 <- mean(amplitude_differences_2, na.rm = TRUE)
    mean_3 <- mean(amplitude_differences_3, na.rm = TRUE)
    
    # Compute the Mean of these differences
    features$AMP_Mean_Roll[i] <- mean(c(mean_1, mean_2, mean_3))

}
  



```

```{r Mann-Whitney-U-test_AMP_Mean_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
AMP_Mean_Roll_HYclass2 <- features$AMP_Mean_Roll[features$HYclass == group_A]
AMP_Mean_Roll_HYclass3 <- features$AMP_Mean_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AMP_Mean_Roll <- 
  wilcox.test(AMP_Mean_Roll_HYclass2, AMP_Mean_Roll_HYclass3)$p.value

```

```{r AMP_Mean_plot_Roll, echo=FALSE}

boxplot(AMP_Mean_Roll ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AMP_Mean_Roll",
        #ylim = c(0.15,2.6),
        main = "Amplitude mean - Roll", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r mean_amp_outliers_Roll, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AMP_Mean_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AMP_Mean_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AMP_Mean_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AMP_Mean_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Yaw

```{r mean_amplitude, echo = FALSE}

features$AMP_Mean_Yaw <- NA
  
for(i in 1:nrow(features)) {
  # Find Peaks
  peaks_data_1 <- findpeaks(pull_segments$Yaw_1[[i]])
  peaks_indices_1 <- peaks_data_1[, 2]  # Indices of the peaks
  
  peaks_data_2 <- findpeaks(pull_segments$Yaw_2[[i]])
  peaks_indices_2 <- peaks_data_2[, 2]
  
  peaks_data_3 <- findpeaks(pull_segments$Yaw_3[[i]])
  peaks_indices_3 <- peaks_data_3[, 2]
  
  # Find Troughs (by finding peaks in the inverted signal)
  troughs_data_1 <- findpeaks(-pull_segments$Yaw_1[[i]])
  troughs_indices_1 <- troughs_data_1[, 2]  # Indices of the troughs
  
  troughs_data_2 <- findpeaks(-pull_segments$Yaw_2[[i]])
  troughs_indices_2 <- troughs_data_2[, 2]
  
  troughs_data_3 <- findpeaks(-pull_segments$Yaw_3[[i]])
  troughs_indices_3 <- troughs_data_3[, 2]
  
  # Ensure the first trough is after the first peak and the last peak is before the last trough
  if (length(troughs_indices_1) > 0 && length(peaks_indices_1) > 0) {
    if (troughs_indices_1[1] < peaks_indices_1[1]) {
      troughs_indices_1 <- troughs_indices_1[-1]
    }
    if (length(troughs_indices_1) > 0 && 
        peaks_indices_1[length(peaks_indices_1)] > troughs_indices_1[length(troughs_indices_1)]) {
      peaks_indices_1 <- peaks_indices_1[-length(peaks_indices_1)]
    }
  
    # Calculate amplitude differences between each peak and its subsequent trough
    amplitude_differences_1 <- sapply(1:length(peaks_indices_1), function(x) {
      if (x <= length(troughs_indices_1)) {
        peak_amplitude_1 <- pull_segments$Yaw_1[[i]][peaks_indices_1[x]]
        trough_amplitude_1 <- pull_segments$Yaw_1[[i]][troughs_indices_1[x]]
        return(peak_amplitude_1 - trough_amplitude_1)
      }
    })
  }
    
      # 2
  if (length(troughs_indices_2) > 0 && length(peaks_indices_2) > 0) {
    if (troughs_indices_2[1] < peaks_indices_2[1]) {
      troughs_indices_2 <- troughs_indices_2[-1]
    }
    if (length(troughs_indices_2) > 0 &&
        peaks_indices_2[length(peaks_indices_2)] > troughs_indices_2[length(troughs_indices_2)]) {
      peaks_indices_2 <- peaks_indices_2[-length(peaks_indices_2)]
    }

    # 2
    amplitude_differences_2 <- sapply(1:length(peaks_indices_2), function(x) {
      if (x <= length(troughs_indices_2)) {
        peak_amplitude_2 <- pull_segments$Yaw_2[[i]][peaks_indices_2[x]]
        trough_amplitude_2 <- pull_segments$Yaw_2[[i]][troughs_indices_2[x]]
        return(peak_amplitude_2 - trough_amplitude_2)
      }
    })
  }

    # 3
  if (length(troughs_indices_3) > 0 && length(peaks_indices_3) > 0) {
    if (troughs_indices_3[1] < peaks_indices_3[1]) {
      troughs_indices_3 <- troughs_indices_3[-1]
    }
    if (length(troughs_indices_3) > 0 &&
        peaks_indices_3[length(peaks_indices_3)] > troughs_indices_3[length(troughs_indices_3)]) {
      peaks_indices_3 <- peaks_indices_3[-length(peaks_indices_3)]
    }

    # 3
    amplitude_differences_3 <- sapply(1:length(peaks_indices_3), function(x) {
      if (x <= length(troughs_indices_3)) {
        peak_amplitude_3 <- pull_segments$Yaw_3[[i]][peaks_indices_3[x]]
        trough_amplitude_3 <- pull_segments$Yaw_3[[i]][troughs_indices_3[x]]
        return(peak_amplitude_3 - trough_amplitude_3)
      }
    })
  }
    
    mean_1 <- mean(amplitude_differences_1, na.rm = TRUE)
    mean_2 <- mean(amplitude_differences_2, na.rm = TRUE)
    mean_3 <- mean(amplitude_differences_3, na.rm = TRUE)
    
    # Compute the Mean of these differences
    features$AMP_Mean_Yaw[i] <- mean(c(mean_1, mean_2, mean_3))

}
  



```

```{r Mann-Whitney-U-test_AMP_Mean, echo=FALSE}

# Extract values for HYclass 2 and 3
AMP_Mean_Yaw_HYclass2 <- features$AMP_Mean_Yaw[features$HYclass == group_A]
AMP_Mean_Yaw_HYclass3 <- features$AMP_Mean_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AMP_Mean_Yaw <- 
  wilcox.test(AMP_Mean_Yaw_HYclass2, AMP_Mean_Yaw_HYclass3)$p.value

```


```{r mean_amp_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AMP_Mean_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AMP_Mean_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AMP_Mean_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AMP_Mean_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage

## Autocorrelation (First lag)

```{r autocorrelation, echo=FALSE}
# Initialize the new columns
features$AC_AP <- NA
features$AC_ML <- NA
features$AC_VT <- NA
features$AC_Pitch <- NA
features$AC_Roll <- NA
features$AC_Yaw <- NA


for(i in 1:nrow(features)) {
  
  # do the ACF but omit NA as some segment series not a full 100 cycles...
  auto_AP_1 <- acf(na.omit(as.ts(pull_segments$AP_1[[i]])), plot = FALSE)
  auto_AP_2 <- acf(na.omit(as.ts(pull_segments$AP_2[[i]])), plot = FALSE)
  auto_AP_3 <- acf(na.omit(as.ts(pull_segments$AP_3[[i]])), plot = FALSE)
  
  first_lag_AP_1 <- auto_AP_1$acf[2]
  first_lag_AP_2 <- auto_AP_2$acf[2]
  first_lag_AP_3 <- auto_AP_3$acf[2]

  features$AC_AP[i] <- mean(c(first_lag_AP_1, first_lag_AP_2, first_lag_AP_3))
  
  auto_ML_1 <- acf(na.omit(as.ts(pull_segments$ML_1[[i]])), plot = FALSE)
  auto_ML_2 <- acf(na.omit(as.ts(pull_segments$ML_2[[i]])), plot = FALSE)
  auto_ML_3 <- acf(na.omit(as.ts(pull_segments$ML_3[[i]])), plot = FALSE)
  
  first_lag_ML_1 <- auto_ML_1$acf[2]
  first_lag_ML_2 <- auto_ML_2$acf[2]
  first_lag_ML_3 <- auto_ML_3$acf[2]
  
  features$AC_ML[i] <- mean(c(first_lag_ML_1, first_lag_ML_2, first_lag_ML_3))
  
  auto_VT_1 <- acf(na.omit(as.ts(pull_segments$VT_1[[i]])), plot = FALSE)
  auto_VT_2 <- acf(na.omit(as.ts(pull_segments$VT_2[[i]])), plot = FALSE)
  auto_VT_3 <- acf(na.omit(as.ts(pull_segments$VT_3[[i]])), plot = FALSE)
  
  first_lag_VT_1 <- auto_VT_1$acf[2]
  first_lag_VT_2 <- auto_VT_2$acf[2]
  first_lag_VT_3 <- auto_VT_3$acf[2]

  features$AC_VT[i] <- mean(c(first_lag_VT_1, first_lag_VT_2, first_lag_VT_3))
  
  auto_Pitch_1 <- acf(na.omit(as.ts(pull_segments$Pitch_1[[i]])), plot = FALSE)
  auto_Pitch_2 <- acf(na.omit(as.ts(pull_segments$Pitch_2[[i]])), plot = FALSE)
  auto_Pitch_3 <- acf(na.omit(as.ts(pull_segments$Pitch_3[[i]])), plot = FALSE)
  
  first_lag_Pitch_1 <- auto_Pitch_1$acf[2]
  first_lag_Pitch_2 <- auto_Pitch_2$acf[2]
  first_lag_Pitch_3 <- auto_Pitch_3$acf[2]

  features$AC_Pitch[i] <- mean(c(first_lag_Pitch_1, first_lag_Pitch_2, first_lag_Pitch_3))
  
  auto_Roll_1 <- acf(na.omit(as.ts(pull_segments$Roll_1[[i]])), plot = FALSE)
  auto_Roll_2 <- acf(na.omit(as.ts(pull_segments$Roll_2[[i]])), plot = FALSE)
  auto_Roll_3 <- acf(na.omit(as.ts(pull_segments$Roll_3[[i]])), plot = FALSE)
  
  first_lag_Roll_1 <- auto_Roll_1$acf[2]
  first_lag_Roll_2 <- auto_Roll_2$acf[2]
  first_lag_Roll_3 <- auto_Roll_3$acf[2]

  features$AC_Roll[i] <- mean(c(first_lag_Roll_1, first_lag_Roll_2, first_lag_Roll_3))
  
  auto_Yaw_1 <- acf(na.omit(as.ts(pull_segments$Yaw_1[[i]])), plot = FALSE)
  auto_Yaw_2 <- acf(na.omit(as.ts(pull_segments$Yaw_2[[i]])), plot = FALSE)
  auto_Yaw_3 <- acf(na.omit(as.ts(pull_segments$Yaw_3[[i]])), plot = FALSE)
  
  first_lag_Yaw_1 <- auto_Yaw_1$acf[2]
  first_lag_Yaw_2 <- auto_Yaw_2$acf[2]
  first_lag_Yaw_3 <- auto_Yaw_3$acf[2]

  features$AC_Yaw[i] <- mean(c(first_lag_Yaw_1, first_lag_Yaw_2, first_lag_Yaw_3))

}

```   

### Anteroposterior

```{r Mann-Whitney-U-test_autocorro, echo=FALSE}

# Extract values for HYclass 2 and 3
AC_AP_HYclass2 <- features$AC_AP[features$HYclass == group_A]
AC_AP_HYclass3 <- features$AC_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AC_AP <- wilcox.test(AC_AP_HYclass2, AC_AP_HYclass3)$p.value


```


```{r autocorro_plot, echo=FALSE}

boxplot(AC_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AC_AP", 
        main = "First lag AC - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r autocorro_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AC_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AC_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AC_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AC_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_autocorro_ml, echo=FALSE}

# Extract values for HYclass 2 and 3
AC_ML_HYclass2 <- features$AC_ML[features$HYclass == group_A]
AC_ML_HYclass3 <- features$AC_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AC_ML <- wilcox.test(AC_ML_HYclass2, AC_ML_HYclass3)$p.value


```


```{r autocorro_plot_ml, echo=FALSE}

boxplot(AC_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AC_ML",
        main = "First lag AC - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r autocorro_plot_ml_no_outlier, echo=FALSE}

boxplot(AC_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "AC_ML",
        main = "First lag AC - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r autocorro_outliers_ML, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AC_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AC_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AC_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AC_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_autocorro, echo=FALSE}

# Extract values for HYclass 2 and 3
AC_VT_HYclass2 <- features$AC_VT[features$HYclass == group_A]
AC_VT_HYclass3 <- features$AC_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AC_VT <- wilcox.test(AC_VT_HYclass2, AC_VT_HYclass3)$p.value


```


```{r autocorro_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AC_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AC_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AC_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AC_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_autocorro, echo=FALSE}

# Extract values for HYclass 2 and 3
AC_Pitch_HYclass2 <- features$AC_Pitch[features$HYclass == group_A]
AC_Pitch_HYclass3 <- features$AC_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AC_Pitch <- wilcox.test(AC_Pitch_HYclass2, AC_Pitch_HYclass3)$p.value


```


```{r autocorro_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AC_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AC_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AC_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AC_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_autocorro, echo=FALSE}

# Extract values for HYclass 2 and 3
AC_Roll_HYclass2 <- features$AC_Roll[features$HYclass == group_A]
AC_Roll_HYclass3 <- features$AC_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AC_Roll <- wilcox.test(AC_Roll_HYclass2, AC_Roll_HYclass3)$p.value


```


```{r autocorro_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AC_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AC_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AC_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AC_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_autocorro, echo=FALSE}

# Extract values for HYclass 2 and 3
AC_Yaw_HYclass2 <- features$AC_Yaw[features$HYclass == group_A]
AC_Yaw_HYclass3 <- features$AC_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$AC_Yaw <- wilcox.test(AC_Yaw_HYclass2, AC_Yaw_HYclass3)$p.value


```


```{r autocorro_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$AC_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$AC_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$AC_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$AC_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Skewness

```{r skewness, echo=FALSE}
features$skew_AP <- NA
features$skew_ML <- NA
features$skew_VT <- NA
features$skew_Pitch <- NA
features$skew_Roll <- NA
features$skew_Yaw <- NA


for(i in 1:nrow(features)) {
  skew_AP_1 <- e1071::skewness(pull_segments$AP_1[[i]], na.rm = TRUE)
  skew_AP_2 <- e1071::skewness(pull_segments$AP_2[[i]], na.rm = TRUE)
  skew_AP_3 <- e1071::skewness(pull_segments$AP_3[[i]], na.rm = TRUE)
  
  features$skew_AP[i] <- mean(c(skew_AP_1, skew_AP_2, skew_AP_3))
  
  skew_ML_1 <- e1071::skewness(pull_segments$ML_1[[i]], na.rm = TRUE)
  skew_ML_2 <- e1071::skewness(pull_segments$ML_2[[i]], na.rm = TRUE)
  skew_ML_3 <- e1071::skewness(pull_segments$ML_3[[i]], na.rm = TRUE)
  
  features$skew_ML[i] <- mean(c(skew_ML_1, skew_ML_2, skew_ML_3))
  
  skew_VT_1 <- e1071::skewness(pull_segments$VT_1[[i]], na.rm = TRUE)
  skew_VT_2 <- e1071::skewness(pull_segments$VT_2[[i]], na.rm = TRUE)
  skew_VT_3 <- e1071::skewness(pull_segments$VT_3[[i]], na.rm = TRUE)
  
  features$skew_VT[i] <- mean(c(skew_VT_1, skew_VT_2, skew_VT_3))
  
  skew_Pitch_1 <- e1071::skewness(pull_segments$Pitch_1[[i]], na.rm = TRUE)
  skew_Pitch_2 <- e1071::skewness(pull_segments$Pitch_2[[i]], na.rm = TRUE)
  skew_Pitch_3 <- e1071::skewness(pull_segments$Pitch_3[[i]], na.rm = TRUE)
  
  features$skew_Pitch[i] <- mean(c(skew_Pitch_1, skew_Pitch_2, skew_Pitch_3))
  
  skew_Roll_1 <- e1071::skewness(pull_segments$Roll_1[[i]], na.rm = TRUE)
  skew_Roll_2 <- e1071::skewness(pull_segments$Roll_2[[i]], na.rm = TRUE)
  skew_Roll_3 <- e1071::skewness(pull_segments$Roll_3[[i]], na.rm = TRUE)
  
  features$skew_Roll[i] <- mean(c(skew_Roll_1, skew_Roll_2, skew_Roll_3))
  
  skew_Yaw_1 <- e1071::skewness(pull_segments$Yaw_1[[i]], na.rm = TRUE)
  skew_Yaw_2 <- e1071::skewness(pull_segments$Yaw_2[[i]], na.rm = TRUE)
  skew_Yaw_3 <- e1071::skewness(pull_segments$Yaw_3[[i]], na.rm = TRUE)
  
  features$skew_Yaw[i] <- mean(c(skew_Yaw_1, skew_Yaw_2, skew_Yaw_3))

}

```   

### Anteroposterior

```{r Mann-Whitney-U-test_skew_AP, echo=FALSE}

# Extract values for HYclass 2 and 3
skew_AP_HYclass2 <- features$skew_AP[features$HYclass == group_A]
skew_AP_HYclass3 <- features$skew_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$skew_AP <- wilcox.test(skew_AP_HYclass2, skew_AP_HYclass3)$p.value

```


```{r skew_plot_AP, echo=FALSE}

boxplot(skew_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "skew_AP",
        main = "Skewness - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r skew_outliers_AP, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$skew_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$skew_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$skew_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$skew_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_skew_ml, echo=FALSE}

# Extract values for HYclass 2 and 3
skew_ML_HYclass2 <- features$skew_ML[features$HYclass == group_A]
skew_ML_HYclass3 <- features$skew_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$skew_ML <- wilcox.test(skew_ML_HYclass2, skew_ML_HYclass3)$p.value

```


```{r skew_plot_ml, echo=FALSE}

boxplot(skew_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "skew_ML",
        main = "Skewness - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r skew_outliers_ml, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$skew_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$skew_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$skew_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$skew_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Vertical

```{r Mann-Whitney-U-test_skew_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
skew_VT_HYclass2 <- features$skew_VT[features$HYclass == group_A]
skew_VT_HYclass3 <- features$skew_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$skew_VT <- wilcox.test(skew_VT_HYclass2, skew_VT_HYclass3)$p.value

```


```{r skew_plot_vt, echo=FALSE}

boxplot(skew_VT ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "skew_VT",
        main = "Skewness - VT", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r skew_outliers_vt, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$skew_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$skew_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$skew_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$skew_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch

```{r Mann-Whitney-U-test_skew_pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
skew_Pitch_HYclass2 <- features$skew_Pitch[features$HYclass == group_A]
skew_Pitch_HYclass3 <- features$skew_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$skew_Pitch <- wilcox.test(skew_Pitch_HYclass2, skew_Pitch_HYclass3)$p.value

```


```{r skew_outliers_pitch, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$skew_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$skew_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$skew_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$skew_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_skew_roll, echo=FALSE}

# Extract values for HYclass 2 and 3
skew_Roll_HYclass2 <- features$skew_Roll[features$HYclass == group_A]
skew_Roll_HYclass3 <- features$skew_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$skew_Roll <- wilcox.test(skew_Roll_HYclass2, skew_Roll_HYclass3)$p.value

```


```{r skew_outliers_roll, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$skew_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$skew_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$skew_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$skew_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_skew_yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
skew_Yaw_HYclass2 <- features$skew_Yaw[features$HYclass == group_A]
skew_Yaw_HYclass3 <- features$skew_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$skew_Yaw <- wilcox.test(skew_Yaw_HYclass2, skew_Yaw_HYclass3)$p.value

```


```{r skew_outliers_yaw, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$skew_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$skew_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$skew_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$skew_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Kurtosis

```{r kurtosis, echo=FALSE}
features$kurt_AP <- NA
features$kurt_ML <- NA
features$kurt_VT <- NA
features$kurt_Pitch <- NA
features$kurt_Roll <- NA
features$kurt_Yaw <- NA

### VT works well here... why not use all.

for(i in 1:nrow(features)) {
  kurt_AP_1 <- e1071::kurtosis(pull_segments$AP_1[[i]], na.rm = TRUE)
  kurt_AP_2 <- e1071::kurtosis(pull_segments$AP_2[[i]], na.rm = TRUE)
  kurt_AP_3 <- e1071::kurtosis(pull_segments$AP_3[[i]], na.rm = TRUE)
  
  features$kurt_AP[i] <- mean(c(kurt_AP_1, kurt_AP_2, kurt_AP_3))
  
  kurt_ML_1 <- e1071::kurtosis(pull_segments$ML_1[[i]], na.rm = TRUE)
  kurt_ML_2 <- e1071::kurtosis(pull_segments$ML_2[[i]], na.rm = TRUE)
  kurt_ML_3 <- e1071::kurtosis(pull_segments$ML_3[[i]], na.rm = TRUE)
  
  features$kurt_ML[i] <- mean(c(kurt_ML_1, kurt_ML_2, kurt_ML_3))
  
  kurt_VT_1 <- e1071::kurtosis(pull_segments$VT_1[[i]], na.rm = TRUE)
  kurt_VT_2 <- e1071::kurtosis(pull_segments$VT_2[[i]], na.rm = TRUE)
  kurt_VT_3 <- e1071::kurtosis(pull_segments$VT_3[[i]], na.rm = TRUE)
  
  features$kurt_VT[i] <- mean(c(kurt_VT_1, kurt_VT_2, kurt_VT_3))
  
  kurt_Pitch_1 <- e1071::kurtosis(pull_segments$Pitch_1[[i]], na.rm = TRUE)
  kurt_Pitch_2 <- e1071::kurtosis(pull_segments$Pitch_2[[i]], na.rm = TRUE)
  kurt_Pitch_3 <- e1071::kurtosis(pull_segments$Pitch_3[[i]], na.rm = TRUE)
  
  features$kurt_Pitch[i] <- mean(c(kurt_Pitch_1, kurt_Pitch_2, kurt_Pitch_3))
  
  kurt_Roll_1 <- e1071::kurtosis(pull_segments$Roll_1[[i]], na.rm = TRUE)
  kurt_Roll_2 <- e1071::kurtosis(pull_segments$Roll_2[[i]], na.rm = TRUE)
  kurt_Roll_3 <- e1071::kurtosis(pull_segments$Roll_3[[i]], na.rm = TRUE)
  
  features$kurt_Roll[i] <- mean(c(kurt_Roll_1, kurt_Roll_2, kurt_Roll_3))
  
  kurt_Yaw_1 <- e1071::kurtosis(pull_segments$Yaw_1[[i]], na.rm = TRUE)
  kurt_Yaw_2 <- e1071::kurtosis(pull_segments$Yaw_2[[i]], na.rm = TRUE)
  kurt_Yaw_3 <- e1071::kurtosis(pull_segments$Yaw_3[[i]], na.rm = TRUE)
  
  features$kurt_Yaw[i] <- mean(c(kurt_Yaw_1, kurt_Yaw_2, kurt_Yaw_3))

}

```   

### Anteroposterior

```{r Mann-Whitney-U-test_kurt, echo=FALSE}

# Extract values for HYclass 2 and 3
kurt_AP_HYclass2 <- features$kurt_AP[features$HYclass == group_A]
kurt_AP_HYclass3 <- features$kurt_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$kurt_AP <- wilcox.test(kurt_AP_HYclass2, kurt_AP_HYclass3)$p.value

```


```{r kurt_plot, echo=FALSE}

boxplot(kurt_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "kurt_AP",
        main = "kurtosis - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r kurt_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$kurt_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$kurt_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$kurt_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$kurt_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_kurt_ml, echo=FALSE}

# Extract values for HYclass 2 and 3
kurt_ML_HYclass2 <- features$kurt_ML[features$HYclass == group_A]
kurt_ML_HYclass3 <- features$kurt_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$kurt_ML <- wilcox.test(kurt_ML_HYclass2, kurt_ML_HYclass3)$p.value

```


```{r kurt_plot_ml, echo=FALSE}

boxplot(kurt_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "kurt_ML",
        main = "kurtosis - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r kurt_outliers_ml, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$kurt_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$kurt_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$kurt_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$kurt_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_kurt_vt, echo=FALSE}

# Extract values for HYclass 2 and 3
kurt_VT_HYclass2 <- features$kurt_VT[features$HYclass == group_A]
kurt_VT_HYclass3 <- features$kurt_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$kurt_VT <- wilcox.test(kurt_VT_HYclass2, kurt_VT_HYclass3)$p.value

```


```{r kurt_plot_vt, echo=FALSE}

boxplot(kurt_VT ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "kurt_VT",
        main = "kurtosis - VT", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r kurt_outliers_vt, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$kurt_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$kurt_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$kurt_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$kurt_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_kurt_pi, echo=FALSE}

# Extract values for HYclass 2 and 3
kurt_Pitch_HYclass2 <- features$kurt_Pitch[features$HYclass == group_A]
kurt_Pitch_HYclass3 <- features$kurt_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$kurt_Pitch <- wilcox.test(kurt_Pitch_HYclass2, kurt_Pitch_HYclass3)$p.value

```


```{r kurt_outliers_pi, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$kurt_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$kurt_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$kurt_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$kurt_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_kurt_ro, echo=FALSE}

# Extract values for HYclass 2 and 3
kurt_Roll_HYclass2 <- features$kurt_Roll[features$HYclass == group_A]
kurt_Roll_HYclass3 <- features$kurt_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$kurt_Roll <- wilcox.test(kurt_Roll_HYclass2, kurt_Roll_HYclass3)$p.value

```


```{r kurt_outliers_ro, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$kurt_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$kurt_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$kurt_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$kurt_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_kurt_ya, echo=FALSE}

# Extract values for HYclass 2 and 3
kurt_Yaw_HYclass2 <- features$kurt_Yaw[features$HYclass == group_A]
kurt_Yaw_HYclass3 <- features$kurt_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$kurt_Yaw <- wilcox.test(kurt_Yaw_HYclass2, kurt_Yaw_HYclass3)$p.value

```


```{r kurt_outliers_ya, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$kurt_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$kurt_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$kurt_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$kurt_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


## TS Entropy

```{r entropy, echo = FALSE}

features$H_TS_AP <- NA
features$H_TS_ML <- NA
features$H_TS_VT <- NA
features$H_TS_Pitch <- NA
features$H_TS_Roll <- NA
features$H_TS_Yaw <- NA

for(i in 1:nrow(features)) {
  # Calculate Sample Entropy for each time series segment
  entropy_ap_1 <- entropy(pull_segments$AP_1[[i]]+18, method="ML")
  entropy_ap_2 <- entropy(pull_segments$AP_2[[i]]+18, method="ML")
  entropy_ap_3 <- entropy(pull_segments$AP_3[[i]]+18, method="ML")
  
  entropy_ml_1 <- entropy(pull_segments$ML_1[[i]]+15, method="ML")
  entropy_ml_2 <- entropy(pull_segments$ML_2[[i]]+15, method="ML")
  entropy_ml_3 <- entropy(pull_segments$ML_3[[i]]+15, method="ML")
  
  entropy_vt_1 <- entropy(pull_segments$VT_1[[i]]+15, method="ML")
  entropy_vt_2 <- entropy(pull_segments$VT_2[[i]]+15, method="ML")
  entropy_vt_3 <- entropy(pull_segments$VT_3[[i]]+15, method="ML")
  
  entropy_Pitch_1 <- entropy(pull_segments$Pitch_1[[i]]+18, method="ML")
  entropy_Pitch_2 <- entropy(pull_segments$Pitch_2[[i]]+18, method="ML")
  entropy_Pitch_3 <- entropy(pull_segments$Pitch_3[[i]]+18, method="ML")
  
  entropy_Roll_1 <- entropy(pull_segments$Roll_1[[i]]+15, method="ML")
  entropy_Roll_2 <- entropy(pull_segments$Roll_2[[i]]+15, method="ML")
  entropy_Roll_3 <- entropy(pull_segments$Roll_3[[i]]+15, method="ML")
  
  entropy_Yaw_1 <- entropy(pull_segments$Yaw_1[[i]]+15, method="ML")
  entropy_Yaw_2 <- entropy(pull_segments$Yaw_2[[i]]+15, method="ML")
  entropy_Yaw_3 <- entropy(pull_segments$Yaw_3[[i]]+15, method="ML")

  # Average for the three pulls
  features$H_TS_AP[i] <- mean(c(entropy_ap_1, entropy_ap_2, entropy_ap_3))
  features$H_TS_ML[i] <- mean(c(entropy_ml_1, entropy_ml_2, entropy_ml_3))
  features$H_TS_VT[i] <- mean(c(entropy_vt_1, entropy_vt_2, entropy_vt_3))
  features$H_TS_Pitch[i] <- mean(c(entropy_Pitch_1, entropy_Pitch_2, entropy_Pitch_3))
  features$H_TS_Roll[i] <- mean(c(entropy_Roll_1, entropy_Roll_2, entropy_Roll_3))
  features$H_TS_Yaw[i] <- mean(c(entropy_Yaw_1, entropy_Yaw_2, entropy_Yaw_3))
}

```

### Anteroposterior

```{r Mann-Whitney-U-test_Ent_TS_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
H_TS_AP_HYclass2 <- features$H_TS_AP[features$HYclass == group_A]
H_TS_AP_HYclass3 <- features$H_TS_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$H_TS_AP <- wilcox.test(H_TS_AP_HYclass2, H_TS_AP_HYclass3)$p.value

```

```{r Freq_entropy_plot_ap, echo=FALSE}

boxplot(H_TS_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "H_TS_AP",
        outline = FALSE,
        main = "TS entropy - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r H_TS_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$H_TS_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$H_TS_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$H_TS_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$H_TS_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_Ent_TS_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
H_TS_ML_HYclass2 <- features$H_TS_ML[features$HYclass == group_A]
H_TS_ML_HYclass3 <- features$H_TS_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$H_TS_ML <- wilcox.test(H_TS_ML_HYclass2, H_TS_ML_HYclass3)$p.value

```

```{r ts_entropy_ml_plot, echo=FALSE}

boxplot(H_TS_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "H_TS_ML",
        outline = FALSE,
        main = "TS entropy - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r H_TS_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$H_TS_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$H_TS_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$H_TS_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$H_TS_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_Ent_TS_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
H_TS_VT_HYclass2 <- features$H_TS_VT[features$HYclass == group_A]
H_TS_VT_HYclass3 <- features$H_TS_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$H_TS_VT <- wilcox.test(H_TS_VT_HYclass2, H_TS_VT_HYclass3)$p.value

```

```{r TS_entropy_vt_plot, echo=FALSE}

boxplot(H_TS_VT ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "H_TS_VT",
        outline = FALSE,
        main = "TS entropy - VT", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r H_TS_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$H_TS_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$H_TS_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$H_TS_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$H_TS_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_Ent_TS_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
H_TS_Pitch_HYclass2 <- features$H_TS_Pitch[features$HYclass == group_A]
H_TS_Pitch_HYclass3 <- features$H_TS_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$H_TS_Pitch <- wilcox.test(H_TS_Pitch_HYclass2, H_TS_Pitch_HYclass3)$p.value

```


```{r H_TS_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$H_TS_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mPitch them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$H_TS_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$H_TS_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$H_TS_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_Ent_TS_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
H_TS_Roll_HYclass2 <- features$H_TS_Roll[features$HYclass == group_A]
H_TS_Roll_HYclass3 <- features$H_TS_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$H_TS_Roll <- wilcox.test(H_TS_Roll_HYclass2, H_TS_Roll_HYclass3)$p.value

```


```{r H_TS_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$H_TS_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mRoll them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$H_TS_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$H_TS_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$H_TS_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_Ent_TS_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
H_TS_Yaw_HYclass2 <- features$H_TS_Yaw[features$HYclass == group_A]
H_TS_Yaw_HYclass3 <- features$H_TS_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$H_TS_Yaw <- wilcox.test(H_TS_Yaw_HYclass2, H_TS_Yaw_HYclass3)$p.value

```


```{r H_TS_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$H_TS_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mYaw them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$H_TS_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$H_TS_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$H_TS_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## GAM Dispersion

```{r test_model, echo = FALSE}

## Proxy for shape of data

features$gam_disp_AP <- NA
features$gam_disp_ML <- NA
features$gam_disp_VT <- NA
features$gam_disp_Pitch <- NA
features$gam_disp_Roll <- NA
features$gam_disp_Yaw <- NA

for(i in 1:nrow(features)) {
  ### AP ###
  response_1 <- pull_segments$AP_1[[i]]
  response_2 <- pull_segments$AP_2[[i]]
  response_3 <- pull_segments$AP_3[[i]]

  time1 <- seq_along(response_1) - 1  # Time vector
  time2 <- seq_along(response_2) - 1
  time3 <- seq_along(response_3) - 1

  # Fit a GAM model
  gam_model_1 <- gam(response_1 ~ s(time1), method = "REML", data = data.frame(time1, response_1))
  gam_model_2 <- gam(response_2 ~ s(time2), method = "REML", data = data.frame(time2, response_2))
  gam_model_3 <- gam(response_3 ~ s(time3), method = "REML", data = data.frame(time3, response_3))

  features$gam_disp_AP[i] <- mean(c(summary(gam_model_1)$dispersion,
                            summary(gam_model_2)$dispersion,
                            summary(gam_model_3)$dispersion))
  ### ML ###
  response_1 <- pull_segments$ML_1[[i]]
  response_2 <- pull_segments$ML_2[[i]]
  response_3 <- pull_segments$ML_3[[i]]

  time1 <- seq_along(response_1) - 1  # Time vector
  time2 <- seq_along(response_2) - 1
  time3 <- seq_along(response_3) - 1

  # Fit a GAM model
  gam_model_1 <- gam(response_1 ~ s(time1), method = "REML", data = data.frame(time1, response_1))
  gam_model_2 <- gam(response_2 ~ s(time2), method = "REML", data = data.frame(time2, response_2))
  gam_model_3 <- gam(response_3 ~ s(time3), method = "REML", data = data.frame(time3, response_3))

  features$gam_disp_ML[i] <- mean(c(summary(gam_model_1)$dispersion,
                            summary(gam_model_2)$dispersion,
                            summary(gam_model_3)$dispersion))
  
  ### VT ###
  response_1 <- pull_segments$VT_1[[i]]
  response_2 <- pull_segments$VT_2[[i]]
  response_3 <- pull_segments$VT_3[[i]]

  time1 <- seq_along(response_1) - 1  # Time vector
  time2 <- seq_along(response_2) - 1
  time3 <- seq_along(response_3) - 1

  # Fit a GAM model
  gam_model_1 <- gam(response_1 ~ s(time1), method = "REML", data = data.frame(time1, response_1))
  gam_model_2 <- gam(response_2 ~ s(time2), method = "REML", data = data.frame(time2, response_2))
  gam_model_3 <- gam(response_3 ~ s(time3), method = "REML", data = data.frame(time3, response_3))

  features$gam_disp_VT[i] <- mean(c(summary(gam_model_1)$dispersion,
                            summary(gam_model_2)$dispersion,
                            summary(gam_model_3)$dispersion))
  
  ### Pitch ###
  response_1 <- pull_segments$Pitch_1[[i]]
  response_2 <- pull_segments$Pitch_2[[i]]
  response_3 <- pull_segments$Pitch_3[[i]]

  time1 <- seq_along(response_1) - 1  # Time vector
  time2 <- seq_along(response_2) - 1
  time3 <- seq_along(response_3) - 1

  # Fit a GAM model
  gam_model_1 <- gam(response_1 ~ s(time1), method = "REML", data = data.frame(time1, response_1))
  gam_model_2 <- gam(response_2 ~ s(time2), method = "REML", data = data.frame(time2, response_2))
  gam_model_3 <- gam(response_3 ~ s(time3), method = "REML", data = data.frame(time3, response_3))

  features$gam_disp_Pitch[i] <- mean(c(summary(gam_model_1)$dispersion,
                            summary(gam_model_2)$dispersion,
                            summary(gam_model_3)$dispersion))
  
  ### Roll ###
  response_1 <- pull_segments$Roll_1[[i]]
  response_2 <- pull_segments$Roll_2[[i]]
  response_3 <- pull_segments$Roll_3[[i]]

  time1 <- seq_along(response_1) - 1  # Time vector
  time2 <- seq_along(response_2) - 1
  time3 <- seq_along(response_3) - 1

  # Fit a GAM model
  gam_model_1 <- gam(response_1 ~ s(time1), method = "REML", data = data.frame(time1, response_1))
  gam_model_2 <- gam(response_2 ~ s(time2), method = "REML", data = data.frame(time2, response_2))
  gam_model_3 <- gam(response_3 ~ s(time3), method = "REML", data = data.frame(time3, response_3))

  features$gam_disp_Roll[i] <- mean(c(summary(gam_model_1)$dispersion,
                            summary(gam_model_2)$dispersion,
                            summary(gam_model_3)$dispersion))
  
  ### Yaw ###
  response_1 <- pull_segments$Yaw_1[[i]]
  response_2 <- pull_segments$Yaw_2[[i]]
  response_3 <- pull_segments$Yaw_3[[i]]

  time1 <- seq_along(response_1) - 1  # Time vector
  time2 <- seq_along(response_2) - 1
  time3 <- seq_along(response_3) - 1

  # Fit a GAM model
  gam_model_1 <- gam(response_1 ~ s(time1), method = "REML", data = data.frame(time1, response_1))
  gam_model_2 <- gam(response_2 ~ s(time2), method = "REML", data = data.frame(time2, response_2))
  gam_model_3 <- gam(response_3 ~ s(time3), method = "REML", data = data.frame(time3, response_3))

  features$gam_disp_Yaw[i] <- mean(c(summary(gam_model_1)$dispersion,
                            summary(gam_model_2)$dispersion,
                            summary(gam_model_3)$dispersion))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_disp_AP, echo=FALSE}

# Extract values for HYclass 2 and 3
gam_disp_AP_HYclass2 <- features$gam_disp_AP[features$HYclass == group_A]
gam_disp_AP_HYclass3 <- features$gam_disp_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$gam_disp_AP <- wilcox.test(gam_disp_AP_HYclass2, gam_disp_AP_HYclass3)$p.value

```

```{r dispersion_plot_AP, echo=FALSE}

boxplot(gam_disp_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "gam_disp_AP",
        outline = FALSE,
        main = "Dispersion - AP - focused view", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r disp_outliers_AP, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$gam_disp_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$gam_disp_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$gam_disp_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$gam_disp_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_disp_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
gam_disp_ML_HYclass2 <- features$gam_disp_ML[features$HYclass == group_A]
gam_disp_ML_HYclass3 <- features$gam_disp_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$gam_disp_ML <- wilcox.test(gam_disp_ML_HYclass2, gam_disp_ML_HYclass3)$p.value

```

```{r dispersion_plot_ML, echo=FALSE}

boxplot(gam_disp_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "gam_disp_ML",
        main = "Dispersion - ML - focused view", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r disp_outliers_ML, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$gam_disp_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$gam_disp_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$gam_disp_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$gam_disp_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_disp_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
gam_disp_VT_HYclass2 <- features$gam_disp_VT[features$HYclass == group_A]
gam_disp_VT_HYclass3 <- features$gam_disp_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$gam_disp_VT <- wilcox.test(gam_disp_VT_HYclass2, gam_disp_VT_HYclass3)$p.value

```

```{r dispersion_plot_VT, echo=FALSE}

boxplot(gam_disp_VT ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "gam_disp_VT",
        main = "Dispersion - VT - focused view", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r disp_outliers_VT, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$gam_disp_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$gam_disp_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$gam_disp_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$gam_disp_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_disp_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
gam_disp_Pitch_HYclass2 <- features$gam_disp_Pitch[features$HYclass == group_A]
gam_disp_Pitch_HYclass3 <- features$gam_disp_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$gam_disp_Pitch <- wilcox.test(gam_disp_Pitch_HYclass2, gam_disp_Pitch_HYclass3)$p.value

```


```{r disp_outliers_Pitch, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$gam_disp_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$gam_disp_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$gam_disp_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$gam_disp_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_disp_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
gam_disp_Roll_HYclass2 <- features$gam_disp_Roll[features$HYclass == group_A]
gam_disp_Roll_HYclass3 <- features$gam_disp_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$gam_disp_Roll <- wilcox.test(gam_disp_Roll_HYclass2, gam_disp_Roll_HYclass3)$p.value

```


```{r disp_outliers_Roll, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$gam_disp_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$gam_disp_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$gam_disp_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$gam_disp_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_disp_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
gam_disp_Yaw_HYclass2 <- features$gam_disp_Yaw[features$HYclass == group_A]
gam_disp_Yaw_HYclass3 <- features$gam_disp_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$gam_disp_Yaw <- wilcox.test(gam_disp_Yaw_HYclass2, gam_disp_Yaw_HYclass3)$p.value

```


```{r disp_outliers_Yaw, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$gam_disp_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$gam_disp_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$gam_disp_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$gam_disp_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Chest to Lumbar max acceleration ratio


### Anteroposterior

```{r ratio_max_lum_chest_max_ap, echo = FALSE}
# Initialize the new columns for the two different chest/lumbar acceleration ratios
features$che_lum_max_rat_AP <- NA

# Loop through each subject
for(i in 1:nrow(features)) {
  # mean accelerations for chest and lumbar for each segment
  max_chest_1 <- max(chest_pull_segments$AP_1[[i]], na.rm = TRUE)
  max_chest_2 <- max(chest_pull_segments$AP_2[[i]], na.rm = TRUE)
  max_chest_3 <- max(chest_pull_segments$AP_3[[i]], na.rm = TRUE)

  max_lumbar_1 <- max(pull_segments$AP_1[[i]], na.rm = TRUE)
  max_lumbar_2 <- max(pull_segments$AP_2[[i]], na.rm = TRUE)
  max_lumbar_3 <- max(pull_segments$AP_3[[i]], na.rm = TRUE)
  
  # Store the ratio of the means of the chest and lumbar
  max_chest_all <- mean(c(max_chest_1, max_chest_2, max_chest_3), na.rm = TRUE)
  max_lumbar_all <- mean(c(max_lumbar_1, max_lumbar_2, max_lumbar_3), na.rm = TRUE)
  
  features$che_lum_max_rat_AP[i] <- max_chest_all / max_lumbar_all
}



```


```{r Mann-Whitney-U-test_lum_chest_max_AP, echo=FALSE}

# Extract chest lumbar ratio_AP values for HYclass 2 and 3
che_lum_max_rat_AP_HYclass2 <- features$che_lum_max_rat_AP[features$HYclass == group_A]
che_lum_max_rat_AP_HYclass3 <- features$che_lum_max_rat_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$che_lum_max_rat_AP <- 
  wilcox.test(che_lum_max_rat_AP_HYclass2, che_lum_max_rat_AP_HYclass3)$p.value


```


```{r lum_chest_plot_max_AP, echo=FALSE}

boxplot(che_lum_max_rat_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "che_lum_max_rat_AP", 
        #ylim = c(0.5, 3.5),
        main = "Chest to lumbar max ratio - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r lum_chest_outliers_max_AP, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$che_lum_max_rat_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$che_lum_max_rat_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$che_lum_max_rat_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$che_lum_max_rat_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```



### Mediolateral

```{r ratio_lum_chest_max_ml, echo = FALSE}
# Initialize the new columns for the two different chest/lumbar acceleration ratios
features$che_lum_max_rat_ML <- NA

# Loop through each subject
for(i in 1:nrow(features)) {
  # mean accelerations for chest and lumbar for each segment
  max_chest_1 <- max(chest_pull_segments$ML_1[[i]], na.rm = TRUE)
  max_chest_2 <- max(chest_pull_segments$ML_2[[i]], na.rm = TRUE)
  max_chest_3 <- max(chest_pull_segments$ML_3[[i]], na.rm = TRUE)

  max_lumbar_1 <- max(pull_segments$ML_1[[i]], na.rm = TRUE)
  max_lumbar_2 <- max(pull_segments$ML_2[[i]], na.rm = TRUE)
  max_lumbar_3 <- max(pull_segments$ML_3[[i]], na.rm = TRUE)
  
  ratio_1 <- max_chest_1 / max_lumbar_1
  ratio_2 <- max_chest_2 / max_lumbar_2
  ratio_3 <- max_chest_3 / max_lumbar_3
  
  # Store the ratio of the means of the chest and lumbar
  max_chest_all <- mean(c(max_chest_1, max_chest_2, max_chest_3), na.rm = TRUE)
  max_lumbar_all <- mean(c(max_lumbar_1, max_lumbar_2, max_lumbar_3), na.rm = TRUE)
  
  features$che_lum_max_rat_ML[i] <- max_chest_all / max_lumbar_all
}


```


```{r Mann-Whitney-U-test_lum_chest_max_ml, echo=FALSE}

# Extract chest lumbar ratio max_ML values for HYclass 2 and 3
che_lum_max_rat_ML_HYclass2 <- features$che_lum_max_rat_ML[features$HYclass == group_A]
che_lum_max_rat_ML_HYclass3 <- features$che_lum_max_rat_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$che_lum_max_rat_ML <- 
  wilcox.test(che_lum_max_rat_ML_HYclass2, che_lum_max_rat_ML_HYclass3)$p.value


```


```{r lum_chest_plot_max_ml, echo=FALSE}

boxplot(che_lum_max_rat_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "che_lum_max_rat_ML", 
        #ylim = c(0, 2.5),
        main = "Chest to lumbar max ratio - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r lum_chest_outliers_max_ml, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$che_lum_max_rat_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$che_lum_max_rat_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$che_lum_max_rat_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$che_lum_max_rat_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r ratio_lum_mean_chest_VT, echo = FALSE}
# Initialize the new columns for the two different chest/lumbar acceleration ratios
features$che_lum_mean_rat_VT <- NA

# Loop through each subject
for(i in 1:nrow(features)) {
  # mean accelerations for chest and lumbar for each segment
  mean_chest_1 <- mean(chest_pull_segments$VT_1[[i]]+2, na.rm = TRUE)
  mean_chest_2 <- mean(chest_pull_segments$VT_2[[i]]+2, na.rm = TRUE)
  mean_chest_3 <- mean(chest_pull_segments$VT_3[[i]]+2, na.rm = TRUE)

  mean_lumbar_1 <- mean(pull_segments$VT_1[[i]]+2, na.rm = TRUE)
  mean_lumbar_2 <- mean(pull_segments$VT_2[[i]]+2, na.rm = TRUE)
  mean_lumbar_3 <- mean(pull_segments$VT_3[[i]]+2, na.rm = TRUE)
  
  # Store the ratio of the means of the chest and lumbar
  mean_chest_all <- mean(c(mean_chest_1, mean_chest_2, mean_chest_3), na.rm = TRUE)
  mean_lumbar_all <- mean(c(mean_lumbar_1, mean_lumbar_2, mean_lumbar_3), na.rm = TRUE)
  
  features$che_lum_mean_rat_VT[i] <- mean_chest_all / mean_lumbar_all
}



```


```{r Mann-Whitney-U-test_lum_chest_mean_VT, echo=FALSE}

# Extract chest lumber ratio values for HYclass 2 and 3
che_lum_mean_rat_VT_HYclass2 <- features$che_lum_mean_rat_VT[features$HYclass == group_A]
che_lum_mean_rat_VT_HYclass3 <- features$che_lum_mean_rat_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$che_lum_mean_rat_VT <- 
  wilcox.test(che_lum_mean_rat_VT_HYclass2, che_lum_mean_rat_VT_HYclass3)$p.value


```



```{r lum_chest_outliers_mean_VT, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$che_lum_mean_rat_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mVT them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$che_lum_mean_rat_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$che_lum_mean_rat_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$che_lum_mean_rat_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch

```{r ratio_lum_mean_chest_Pitch, echo = FALSE}
# Initialize the new columns for the two different chest/lumbar acceleration ratios
features$che_lum_mean_rat_Pitch <- NA

# Loop through each subject
for(i in 1:nrow(features)) {
  # mean accelerations for chest and lumbar for each segment
  mean_chest_1 <- mean(chest_pull_segments$Pitch_1[[i]]+2, na.rm = TRUE)
  mean_chest_2 <- mean(chest_pull_segments$Pitch_2[[i]]+2, na.rm = TRUE)
  mean_chest_3 <- mean(chest_pull_segments$Pitch_3[[i]]+2, na.rm = TRUE)

  mean_lumbar_1 <- mean(pull_segments$Pitch_1[[i]]+2, na.rm = TRUE)
  mean_lumbar_2 <- mean(pull_segments$Pitch_2[[i]]+2, na.rm = TRUE)
  mean_lumbar_3 <- mean(pull_segments$Pitch_3[[i]]+2, na.rm = TRUE)
  
  # Store the ratio of the means of the chest and lumbar
  mean_chest_all <- mean(c(mean_chest_1, mean_chest_2, mean_chest_3), na.rm = TRUE)
  mean_lumbar_all <- mean(c(mean_lumbar_1, mean_lumbar_2, mean_lumbar_3), na.rm = TRUE)
  
  features$che_lum_mean_rat_Pitch[i] <- mean_chest_all / mean_lumbar_all
}



```


```{r Mann-Whitney-U-test_lum_chest_mean_Pitch, echo=FALSE}

# Extract chest lumber ratio values for HYclass 2 and 3
che_lum_mean_rat_Pitch_HYclass2 <- features$che_lum_mean_rat_Pitch[features$HYclass == group_A]
che_lum_mean_rat_Pitch_HYclass3 <- features$che_lum_mean_rat_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$che_lum_mean_rat_Pitch <- 
  wilcox.test(che_lum_mean_rat_Pitch_HYclass2, che_lum_mean_rat_Pitch_HYclass3)$p.value


```



```{r lum_chest_outliers_mean_Pitch, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$che_lum_mean_rat_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mPitch them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$che_lum_mean_rat_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$che_lum_mean_rat_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$che_lum_mean_rat_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r ratio_lum_mean_chest_Roll, echo = FALSE}
# Initialize the new columns for the two different chest/lumbar acceleration ratios
features$che_lum_mean_rat_Roll <- NA

# Loop through each subject
for(i in 1:nrow(features)) {
  # mean accelerations for chest and lumbar for each segment
  mean_chest_1 <- mean(chest_pull_segments$Roll_1[[i]]+2, na.rm = TRUE)
  mean_chest_2 <- mean(chest_pull_segments$Roll_2[[i]]+2, na.rm = TRUE)
  mean_chest_3 <- mean(chest_pull_segments$Roll_3[[i]]+2, na.rm = TRUE)

  mean_lumbar_1 <- mean(pull_segments$Roll_1[[i]]+2, na.rm = TRUE)
  mean_lumbar_2 <- mean(pull_segments$Roll_2[[i]]+2, na.rm = TRUE)
  mean_lumbar_3 <- mean(pull_segments$Roll_3[[i]]+2, na.rm = TRUE)
  
  # Store the ratio of the means of the chest and lumbar
  mean_chest_all <- mean(c(mean_chest_1, mean_chest_2, mean_chest_3), na.rm = TRUE)
  mean_lumbar_all <- mean(c(mean_lumbar_1, mean_lumbar_2, mean_lumbar_3), na.rm = TRUE)
  
  features$che_lum_mean_rat_Roll[i] <- mean_chest_all / mean_lumbar_all
}



```


```{r Mann-Whitney-U-test_lum_chest_mean_Roll, echo=FALSE}

# Extract chest lumber ratio values for HYclass 2 and 3
che_lum_mean_rat_Roll_HYclass2 <- features$che_lum_mean_rat_Roll[features$HYclass == group_A]
che_lum_mean_rat_Roll_HYclass3 <- features$che_lum_mean_rat_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$che_lum_mean_rat_Roll <- 
  wilcox.test(che_lum_mean_rat_Roll_HYclass2, che_lum_mean_rat_Roll_HYclass3)$p.value


```



```{r lum_chest_outliers_mean_Roll, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$che_lum_mean_rat_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mRoll them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$che_lum_mean_rat_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$che_lum_mean_rat_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$che_lum_mean_rat_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r ratio_lum_mean_chest_Yaw, echo = FALSE}
# Initialize the new columns for the two different chest/lumbar acceleration ratios
features$che_lum_mean_rat_Yaw <- NA

# Loop through each subject
for(i in 1:nrow(features)) {
  # mean accelerations for chest and lumbar for each segment
  mean_chest_1 <- mean(chest_pull_segments$Yaw_1[[i]]+2, na.rm = TRUE)
  mean_chest_2 <- mean(chest_pull_segments$Yaw_2[[i]]+2, na.rm = TRUE)
  mean_chest_3 <- mean(chest_pull_segments$Yaw_3[[i]]+2, na.rm = TRUE)

  mean_lumbar_1 <- mean(pull_segments$Yaw_1[[i]]+2, na.rm = TRUE)
  mean_lumbar_2 <- mean(pull_segments$Yaw_2[[i]]+2, na.rm = TRUE)
  mean_lumbar_3 <- mean(pull_segments$Yaw_3[[i]]+2, na.rm = TRUE)
  
  # Store the ratio of the means of the chest and lumbar
  mean_chest_all <- mean(c(mean_chest_1, mean_chest_2, mean_chest_3), na.rm = TRUE)
  mean_lumbar_all <- mean(c(mean_lumbar_1, mean_lumbar_2, mean_lumbar_3), na.rm = TRUE)
  
  features$che_lum_mean_rat_Yaw[i] <- mean_chest_all / mean_lumbar_all
}



```


```{r Mann-Whitney-U-test_lum_chest_mean_Yaw, echo=FALSE}

# Extract chest lumber ratio values for HYclass 2 and 3
che_lum_mean_rat_Yaw_HYclass2 <- features$che_lum_mean_rat_Yaw[features$HYclass == group_A]
che_lum_mean_rat_Yaw_HYclass3 <- features$che_lum_mean_rat_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$che_lum_mean_rat_Yaw <- 
  wilcox.test(che_lum_mean_rat_Yaw_HYclass2, che_lum_mean_rat_Yaw_HYclass3)$p.value


```



```{r lum_chest_outliers_mean_Yaw, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$che_lum_mean_rat_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$che_lum_mean_rat_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$che_lum_mean_rat_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$che_lum_mean_rat_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```




\newpage
## Angular velocity Sway Area 95


```{r ang_sway_area_95, echo=FALSE}
# Initialize the new column for Sway Area 95
features$ASA_95_Pitch.Roll <- NA

# compute the chi-squared distribution value for a 95% confidence interval and 2 degrees of freedom
chi_sq_value <- qchisq(0.95, df = 2)

for(i in 1:nrow(features)) {
  
  # Combine AP and ML data into a matrix
  data_matrix_1 <- cbind(pull_segments$Roll_1[[i]], pull_segments$Pitch_1[[i]])
  data_matrix_2 <- cbind(pull_segments$Roll_2[[i]], pull_segments$Pitch_2[[i]])
  data_matrix_3 <- cbind(pull_segments$Roll_3[[i]], pull_segments$Pitch_3[[i]])
  
  # Compute the covariance matrix
  cov_matrix_1 <- cov(data_matrix_1, use = "complete.obs")
  cov_matrix_2 <- cov(data_matrix_2, use = "complete.obs")
  cov_matrix_3 <- cov(data_matrix_3, use = "complete.obs")
  
  # Compute the eigenvalues of the covariance matrix
  eigenvalues_1 <- eigen(cov_matrix_1)$values
  eigenvalues_2 <- eigen(cov_matrix_2)$values
  eigenvalues_3 <- eigen(cov_matrix_3)$values
  
  # Calculate the sway area using the eigenvalues and the chi-squared value
  asa_95_1 <- pi * sqrt(eigenvalues_1[1] * eigenvalues_1[2]) * chi_sq_value
  asa_95_2 <- pi * sqrt(eigenvalues_2[1] * eigenvalues_2[2]) * chi_sq_value
  asa_95_3 <- pi * sqrt(eigenvalues_3[1] * eigenvalues_3[2]) * chi_sq_value
  
  features$ASA_95_Pitch.Roll[i] <- mean(c(asa_95_1, asa_95_2, asa_95_3))
}

```   

```{r Mann-Whitney-U-test_ASA_95_Pitch.Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
ASA_95_Pitch.Roll_HYclass2 <- features$ASA_95_Pitch.Roll[features$HYclass == group_A]
ASA_95_Pitch.Roll_HYclass3 <- features$ASA_95_Pitch.Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$ASA_95_Pitch.Roll <- wilcox.test(ASA_95_Pitch.Roll_HYclass2, ASA_95_Pitch.Roll_HYclass3)$p.value


```


```{r ASA_95_Pitch.Roll_plot, echo=FALSE}

boxplot(ASA_95_Pitch.Roll ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "ASA_95_Pitch.Roll", 
        ylim = c(0, 2.9),
        main = "Angular velocity Sway Area 95% - focused view", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r ASA_95_Pitch.Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$ASA_95_Pitch.Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$ASA_95_Pitch.Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$ASA_95_Pitch.Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$ASA_95_Pitch.Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Major semi-axis of angular velocity sway area


```{r minor_semi_axis_of_sway_area, echo = FALSE}
features$MSA_Ang_SA_AP.ML<- NA
features$MSA_Ang_SA_Pitch.Roll<- NA

chi_sq_value <- qchisq(0.95, df = 2)

# semi-minor axis length
for(i in 1:nrow(features)) {
  
  # Combine AP and ML data into a matrix
  data_matrix_1 <- cbind(pull_segments$AP_1[[i]], pull_segments$ML_1[[i]])
  data_matrix_2 <- cbind(pull_segments$AP_2[[i]], pull_segments$ML_2[[i]])
  data_matrix_3 <- cbind(pull_segments$AP_3[[i]], pull_segments$ML_3[[i]])
  
  # Compute the covariance matrix
  cov_matrix_1 <- cov(data_matrix_1, use = "complete.obs")
  cov_matrix_2 <- cov(data_matrix_2, use = "complete.obs")
  cov_matrix_3 <- cov(data_matrix_3, use = "complete.obs")
  
  # Compute the eigenvalues of the covariance matrix
  eigenvalues_1 <- eigen(cov_matrix_1)$values
  eigenvalues_2 <- eigen(cov_matrix_2)$values
  eigenvalues_3 <- eigen(cov_matrix_3)$values
  
  # Calculate the semi-major axis for each segment
  # the larger eigenvalue corresponds to the semi-major axis
  semi_major_1 <- sqrt(max(eigenvalues_1)) * sqrt(chi_sq_value)
  semi_major_2 <- sqrt(max(eigenvalues_2)) * sqrt(chi_sq_value)
  semi_major_3 <- sqrt(max(eigenvalues_3)) * sqrt(chi_sq_value)

  # store the average semi-minor axis lengths
  features$MSA_Ang_SA_AP.ML[i] <- mean(c(semi_major_1, semi_major_2, semi_major_3))
  
  # Combine Pitch and Roll data into a matrix
  data_matrix_1 <- cbind(pull_segments$Pitch_1[[i]], pull_segments$Roll_1[[i]])
  data_matrix_2 <- cbind(pull_segments$Pitch_2[[i]], pull_segments$Roll_2[[i]])
  data_matrix_3 <- cbind(pull_segments$Pitch_3[[i]], pull_segments$Roll_3[[i]])
  
  # Compute the covariance matrix
  cov_matrix_1 <- cov(data_matrix_1, use = "complete.obs")
  cov_matrix_2 <- cov(data_matrix_2, use = "complete.obs")
  cov_matrix_3 <- cov(data_matrix_3, use = "complete.obs")
  
  # Compute the eigenvalues of the covariance matrix
  eigenvalues_1 <- eigen(cov_matrix_1)$values
  eigenvalues_2 <- eigen(cov_matrix_2)$values
  eigenvalues_3 <- eigen(cov_matrix_3)$values
  
  # Calculate the semi-major axis for each segment
  # the larger eigenvalue corresponds to the semi-major axis
  semi_major_1 <- sqrt(max(eigenvalues_1)) * sqrt(chi_sq_value)
  semi_major_2 <- sqrt(max(eigenvalues_2)) * sqrt(chi_sq_value)
  semi_major_3 <- sqrt(max(eigenvalues_3)) * sqrt(chi_sq_value)

  # Optionally, store the average semi-minor axis lengths
  features$MSA_Ang_SA_Pitch.Roll[i] <- mean(c(semi_major_1, semi_major_2, semi_major_3))
}


```

### AP x ML

```{r Mann-Whitney-U-test_MSA_Ang_SA_AP.ML, echo=FALSE}

# Extract AP_AP values for HYclass 2 and 3
MSA_Ang_SA_AP.ML_HYclass2 <- features$MSA_Ang_SA_AP.ML[features$HYclass == group_A]
MSA_Ang_SA_AP.ML_HYclass3 <- features$MSA_Ang_SA_AP.ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MSA_Ang_SA_AP.ML<- wilcox.test(MSA_Ang_SA_AP.ML_HYclass2, MSA_Ang_SA_AP.ML_HYclass3)$p.value


```


```{r MSA_Ang_SA_AP.ML_plot, echo=FALSE}

boxplot(MSA_Ang_SA_AP.ML~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "MSA_Ang_SA_AP.ML", 
        main = "Major Semiaxis of Sway Area - AP x ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r MSA_Ang_SA_AP.ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MSA_Ang_SA_AP.ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MSA_Ang_SA_AP.ML%in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MSA_Ang_SA_AP.ML<- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MSA_Ang_SA_AP.ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch x Roll

```{r Mann-Whitney-U-test_MSA_Ang_SA_Pitch.Roll, echo=FALSE}

# Extract AP_AP values for HYclass 2 and 3
MSA_Ang_SA_Pitch.Roll_HYclass2 <- features$MSA_Ang_SA_Pitch.Roll[features$HYclass == group_A]
MSA_Ang_SA_Pitch.Roll_HYclass3 <- features$MSA_Ang_SA_Pitch.Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MSA_Ang_SA_Pitch.Roll<- wilcox.test(MSA_Ang_SA_Pitch.Roll_HYclass2, MSA_Ang_SA_Pitch.Roll_HYclass3)$p.value


```


```{r MSA_Ang_SA_Pitch.Roll_plot, echo=FALSE}

boxplot(MSA_Ang_SA_Pitch.Roll~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "MSA_Ang_SA_Pitch.Roll", 
        main = "Major Semiaxis of Sway Area - Pitch x Roll", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r MSA_Ang_SA_Pitch.Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MSA_Ang_SA_Pitch.Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MSA_Ang_SA_Pitch.Roll%in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MSA_Ang_SA_Pitch.Roll<- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MSA_Ang_SA_Pitch.Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Sway Area Fluctuation Ratio


### AP x ML

```{r SA_fluc_rattuation, echo = FALSE}
# Initialize the new column for tremor fluctuation
features$SA_fluc_rat_AP.ML <- NA

# compute the chi-squared distribution value for a 95% confidence interval and 2 degrees of freedom
chi_sq_value <- qchisq(0.95, df = 2)

for(i in 1:nrow(features)) {
  
  # Combine AP and ML data into a matrix
  data_matrix_1 <- cbind(pull_segments$AP_1[[i]], pull_segments$ML_1[[i]])
  data_matrix_2 <- cbind(pull_segments$AP_2[[i]], pull_segments$ML_2[[i]])
  data_matrix_3 <- cbind(pull_segments$AP_3[[i]], pull_segments$ML_3[[i]])
  
  # pre-fluctuation value
  data_matrix_0 <- cbind(lumbar_sorted[[i]]$AP[1:90], lumbar_sorted[[i]]$ML[1:90])
  
  # Compute the covariance matrix
  cov_matrix_1 <- cov(data_matrix_1, use = "complete.obs")
  cov_matrix_2 <- cov(data_matrix_2, use = "complete.obs")
  cov_matrix_3 <- cov(data_matrix_3, use = "complete.obs")
  
  cov_matrix_0 <- cov(data_matrix_0, use = "complete.obs")
  
  # Compute the eigenvalues of the covariance matrix
  eigenvalues_1 <- eigen(cov_matrix_1)$values
  eigenvalues_2 <- eigen(cov_matrix_2)$values
  eigenvalues_3 <- eigen(cov_matrix_3)$values
  
  eigenvalues_0 <- eigen(cov_matrix_0)$values
  
  # Calculate the sway area using the eigenvalues and the chi-squared value
  sa_95_1 <- pi * sqrt(eigenvalues_1[1] * eigenvalues_1[2]) * chi_sq_value
  sa_95_2 <- pi * sqrt(eigenvalues_2[1] * eigenvalues_2[2]) * chi_sq_value
  sa_95_3 <- pi * sqrt(eigenvalues_3[1] * eigenvalues_3[2]) * chi_sq_value
  
  sa_95_0 <- pi * sqrt(eigenvalues_0[1] * eigenvalues_0[2]) * chi_sq_value
  
  features$SA_fluc_rat_AP.ML[i] <- mean(c(sa_95_1, sa_95_2, sa_95_3))/sa_95_0
}


```


```{r Mann-Whitney-U-test_SA_fluc_rat, echo=FALSE}

# Extract values for HYclass 2 and 3
SA_fluc_rat_AP.ML_HYclass2 <- features$SA_fluc_rat_AP.ML[features$HYclass == group_A]
SA_fluc_rat_AP.ML_HYclass3 <- features$SA_fluc_rat_AP.ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SA_fluc_rat_AP.ML <- 
  wilcox.test(SA_fluc_rat_AP.ML_HYclass2, SA_fluc_rat_AP.ML_HYclass3)$p.value

```

```{r sway_fluc_rat_plot, echo=FALSE}

boxplot(SA_fluc_rat_AP.ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "SA_fluc_rat_AP.ML",
        main = "Sway Area Fluctuation Ratio - AP x ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r sway_fluc_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SA_fluc_rat_AP.ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SA_fluc_rat_AP.ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SA_fluc_rat <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SA_fluc_rat[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch x Roll

```{r SA_fluc_rattuation, echo = FALSE}
# Initialize the new column for tremor fluctuation
features$SA_fluc_rat_Pitch.Roll <- NA

# compute the chi-squared distribution value for a 95% confidence interval and 2 degrees of freedom
chi_sq_value <- qchisq(0.95, df = 2)

for(i in 1:nrow(features)) {
  
  # Combine AP and ML data into a matrix
  data_matrix_1 <- cbind(pull_segments$Pitch_1[[i]], pull_segments$Roll_1[[i]])
  data_matrix_2 <- cbind(pull_segments$Pitch_2[[i]], pull_segments$Roll_2[[i]])
  data_matrix_3 <- cbind(pull_segments$Pitch_3[[i]], pull_segments$Roll_3[[i]])
  
  # pre-fluctuation value
  data_matrix_0 <- cbind(lumbar_sorted[[i]]$AP[1:90], lumbar_sorted[[i]]$ML[1:90])
  
  # Compute the covariance matrix
  cov_matrix_1 <- cov(data_matrix_1, use = "complete.obs")
  cov_matrix_2 <- cov(data_matrix_2, use = "complete.obs")
  cov_matrix_3 <- cov(data_matrix_3, use = "complete.obs")
  
  cov_matrix_0 <- cov(data_matrix_0, use = "complete.obs")
  
  # Compute the eigenvalues of the covariance matrix
  eigenvalues_1 <- eigen(cov_matrix_1)$values
  eigenvalues_2 <- eigen(cov_matrix_2)$values
  eigenvalues_3 <- eigen(cov_matrix_3)$values
  
  eigenvalues_0 <- eigen(cov_matrix_0)$values
  
  # Calculate the sway area using the eigenvalues and the chi-squared value
  sa_95_1 <- pi * sqrt(eigenvalues_1[1] * eigenvalues_1[2]) * chi_sq_value
  sa_95_2 <- pi * sqrt(eigenvalues_2[1] * eigenvalues_2[2]) * chi_sq_value
  sa_95_3 <- pi * sqrt(eigenvalues_3[1] * eigenvalues_3[2]) * chi_sq_value
  
  sa_95_0 <- pi * sqrt(eigenvalues_0[1] * eigenvalues_0[2]) * chi_sq_value
  
  features$SA_fluc_rat_Pitch.Roll[i] <- mean(c(sa_95_1, sa_95_2, sa_95_3))/sa_95_0
}


```


```{r Mann-Whitney-U-test_SA_fluc_rat_Pitch.Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
SA_fluc_rat_Pitch.Roll_HYclass2 <- features$SA_fluc_rat_Pitch.Roll[features$HYclass == group_A]
SA_fluc_rat_Pitch.Roll_HYclass3 <- features$SA_fluc_rat_Pitch.Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SA_fluc_rat_Pitch.Roll <- 
  wilcox.test(SA_fluc_rat_Pitch.Roll_HYclass2, SA_fluc_rat_Pitch.Roll_HYclass3)$p.value

```

```{r sway_fluc_rat_plot, echo=FALSE}

boxplot(SA_fluc_rat_Pitch.Roll ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "SA_fluc_rat_Pitch.Roll",
        main = "Sway Area Fluctuation Ratio - Pitch x Roll", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r sway_fluc_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SA_fluc_rat_Pitch.Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SA_fluc_rat_Pitch.Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SA_fluc_rat_Pitch.Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SA_fluc_rat_Pitch.Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```



\newpage
## Frequency Dispersion


```{r frequency_dispersion, echo = FALSE}

features$FSD_AP <- NA
features$FSD_ML <- NA
features$FSD_VT <- NA
features$FSD_Pitch <- NA
features$FSD_Roll <- NA
features$FSD_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_Pitch_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_Pitch_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_Pitch_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right"))
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right"))
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_Pitch_1 <- Mod(fft_Pitch_1[1:(n1/2)])^2
  psd_Pitch_2 <- Mod(fft_Pitch_2[1:(n2/2)])^2
  psd_Pitch_3 <- Mod(fft_Pitch_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2
  
  # Calculate Frequency Dispersion (SD of weighted frequencies)
  FSD_AP_1 <- sqrt(wtd.var(freq1, weights = psd_ap_1))
  FSD_AP_2 <- sqrt(wtd.var(freq2, weights = psd_ap_2))
  FSD_AP_3 <- sqrt(wtd.var(freq3, weights = psd_ap_3))
  
  FSD_ML_1 <- sqrt(wtd.var(freq1, weights = psd_ml_1))
  FSD_ML_2 <- sqrt(wtd.var(freq2, weights = psd_ml_2))
  FSD_ML_3 <- sqrt(wtd.var(freq3, weights = psd_ml_3))
  
  FSD_VT_1 <- sqrt(wtd.var(freq1, weights = psd_VT_1))
  FSD_VT_2 <- sqrt(wtd.var(freq2, weights = psd_VT_2))
  FSD_VT_3 <- sqrt(wtd.var(freq3, weights = psd_VT_3))
  
  FSD_Pitch_1 <- sqrt(wtd.var(freq1, weights = psd_Pitch_1))
  FSD_Pitch_2 <- sqrt(wtd.var(freq2, weights = psd_Pitch_2))
  FSD_Pitch_3 <- sqrt(wtd.var(freq3, weights = psd_Pitch_3))
  
  FSD_Roll_1 <- sqrt(wtd.var(freq1, weights = psd_Roll_1))
  FSD_Roll_2 <- sqrt(wtd.var(freq2, weights = psd_Roll_2))
  FSD_Roll_3 <- sqrt(wtd.var(freq3, weights = psd_Roll_3))
  
  FSD_Yaw_1 <- sqrt(wtd.var(freq1, weights = psd_Yaw_1))
  FSD_Yaw_2 <- sqrt(wtd.var(freq2, weights = psd_Yaw_2))
  FSD_Yaw_3 <- sqrt(wtd.var(freq3, weights = psd_Yaw_3))
  
  # average for the three pulls:
  features$FSD_AP[[i]] <- mean(c(FSD_AP_1, FSD_AP_2, FSD_AP_3))
  features$FSD_ML[[i]] <- mean(c(FSD_ML_1, FSD_ML_2, FSD_ML_3))
  features$FSD_VT[[i]] <- mean(c(FSD_VT_1, FSD_VT_2, FSD_VT_3))
  features$FSD_Pitch[[i]] <- mean(c(FSD_Pitch_1, FSD_Pitch_2, FSD_Pitch_3))
  features$FSD_Roll[[i]] <- mean(c(FSD_Roll_1, FSD_Roll_2, FSD_Roll_3))
  features$FSD_Yaw[[i]] <- mean(c(FSD_Yaw_1, FSD_Yaw_2, FSD_Yaw_3))
}

# some of the variances in ROll are unable to be obtained resulting in NaN, but
# this should be just zero variance in these cases.
for (i in seq_along(features$FSD_Roll)) {
  features$FSD_Roll[[i]][is.nan(features$FSD_Roll[[i]])] <- 0
}


```
```{r}

plot(freq3, 10 * log10(psd_ap_3), type = 'l', xlab = 'Frequency (Hz)', 
     ylab = 'Power (dB)', main = "example PSD for last subject")

```

### Anteroposterior

```{r Mann-Whitney-U-test_FD, echo=FALSE}

# Extract values for HYclass 2 and 3
FSD_AP_HYclass2 <- features$FSD_AP[features$HYclass == group_A]
FSD_AP_HYclass3 <- features$FSD_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$FSD_AP <- wilcox.test(FSD_AP_HYclass2, FSD_AP_HYclass3)$p.value

```

```{r Freq_dispersion_plot, echo=FALSE}

boxplot(FSD_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "FSD_AP",
        #ylim = c(0,1.6),
        main = "Frequency Dispersion (SD) - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r FSD_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$FSD_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$FSD_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$FSD_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$FSD_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_FSD_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
FSD_ML_HYclass2 <- features$FSD_ML[features$HYclass == group_A]
FSD_ML_HYclass3 <- features$FSD_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$FSD_ML <- wilcox.test(FSD_ML_HYclass2, FSD_ML_HYclass3)$p.value

```

```{r Freq_dispersion_plot_ML, echo=FALSE}

boxplot(FSD_ML ~ HYclass, data = features,
        xlab = "HYclass", 
        ylab = "FSD_ML",
        #ylim = c(0,1.6),
        main = "Frequency Dispersion (SD) - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r FSD_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$FSD_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$FSD_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$FSD_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$FSD_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_FD_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
FSD_VT_HYclass2 <- features$FSD_VT[features$HYclass == group_A]
FSD_VT_HYclass3 <- features$FSD_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$FSD_VT <- wilcox.test(FSD_VT_HYclass2, FSD_VT_HYclass3)$p.value

```

```{r FSD_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$FSD_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mVT them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$FSD_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$FSD_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$FSD_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_FD_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
FSD_Pitch_HYclass2 <- features$FSD_Pitch[features$HYclass == group_A]
FSD_Pitch_HYclass3 <- features$FSD_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$FSD_Pitch <- wilcox.test(FSD_Pitch_HYclass2, FSD_Pitch_HYclass3)$p.value

```

```{r FSD_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$FSD_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mPitch them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$FSD_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$FSD_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$FSD_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_FD_roll, echo=FALSE}

# Extract values for HYclass 2 and 3
FSD_Roll_HYclass2 <- features$FSD_Roll[features$HYclass == group_A]
FSD_Roll_HYclass3 <- features$FSD_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$FSD_Roll <- wilcox.test(FSD_Roll_HYclass2, FSD_Roll_HYclass3)$p.value

```

```{r FSD_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$FSD_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mRoll them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$FSD_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$FSD_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$FSD_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_FD_yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
FSD_Yaw_HYclass2 <- features$FSD_Yaw[features$HYclass == group_A]
FSD_Yaw_HYclass3 <- features$FSD_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$FSD_Yaw <- wilcox.test(FSD_Yaw_HYclass2, FSD_Yaw_HYclass3)$p.value

```

```{r FSD_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$FSD_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mYaw them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$FSD_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$FSD_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$FSD_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Frequency Range 95

```{r f_95, echo = FALSE}
features$F95_AP <- NA 
features$F95_ML <- NA  
features$F95_VT <- NA 
features$F95_Pitch <- NA 
features$F95_Roll <- NA 
features$F95_Yaw <- NA 

features$F95_max_AP <- NA 
features$F95_max_ML <- NA  
features$F95_max_VT <- NA 
features$F95_max_Pitch <- NA 
features$F95_max_Roll <- NA 
features$F95_max_Yaw <- NA 

features$F95_min_AP <- NA 
features$F95_min_ML <- NA 
features$F95_min_VT <- NA 
features$F95_min_Pitch <- NA 
features$F95_min_Roll <- NA 
features$F95_min_Yaw <- NA  

  # Define a function to find the lower and upper frequency bounds
  # Define a function to find the lower and upper frequency bounds
find_freq_bounds <- function(cum_psd, freq) {
    lower <- min(freq[cum_psd >= 0.025])
    upper <- min(freq[cum_psd > 0.975])  
    return(c(lower, upper))
}

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_Pitch_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_Pitch_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_Pitch_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_Pitch_1 <- Mod(fft_Pitch_1[1:(n1/2)])^2
  psd_Pitch_2 <- Mod(fft_Pitch_2[1:(n2/2)])^2
  psd_Pitch_3 <- Mod(fft_Pitch_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate the cumulative sum of PSD for each axis and pull
  cum_psd_ap_1 <- cumsum(psd_ap_1[1:(n1/2)]) / sum(psd_ap_1[1:(n1/2)])
  cum_psd_ap_2 <- cumsum(psd_ap_2[1:(n2/2)]) / sum(psd_ap_2[1:(n2/2)])
  cum_psd_ap_3 <- cumsum(psd_ap_3[1:(n3/2)]) / sum(psd_ap_3[1:(n3/2)])
  
  cum_psd_ml_1 <- cumsum(psd_ml_1[1:(n1/2)]) / sum(psd_ml_1[1:(n1/2)])
  cum_psd_ml_2 <- cumsum(psd_ml_2[1:(n2/2)]) / sum(psd_ml_2[1:(n2/2)])
  cum_psd_ml_3 <- cumsum(psd_ml_3[1:(n3/2)]) / sum(psd_ml_3[1:(n3/2)])
  
  cum_psd_VT_1 <- cumsum(psd_VT_1[1:(n1/2)]) / sum(psd_VT_1[1:(n1/2)])
  cum_psd_VT_2 <- cumsum(psd_VT_2[1:(n2/2)]) / sum(psd_VT_2[1:(n2/2)])
  cum_psd_VT_3 <- cumsum(psd_VT_3[1:(n3/2)]) / sum(psd_VT_3[1:(n3/2)])
  
  cum_psd_Pitch_1 <- cumsum(psd_Pitch_1[1:(n1/2)]) / sum(psd_Pitch_1[1:(n1/2)])
  cum_psd_Pitch_2 <- cumsum(psd_Pitch_2[1:(n2/2)]) / sum(psd_Pitch_2[1:(n2/2)])
  cum_psd_Pitch_3 <- cumsum(psd_Pitch_3[1:(n3/2)]) / sum(psd_Pitch_3[1:(n3/2)])
  
  cum_psd_Roll_1 <- cumsum(psd_Roll_1[1:(n1/2)]) / sum(psd_Roll_1[1:(n1/2)])
  cum_psd_Roll_2 <- cumsum(psd_Roll_2[1:(n2/2)]) / sum(psd_Roll_2[1:(n2/2)])
  cum_psd_Roll_3 <- cumsum(psd_Roll_3[1:(n3/2)]) / sum(psd_Roll_3[1:(n3/2)])
  
  cum_psd_Yaw_1 <- cumsum(psd_Yaw_1[1:(n1/2)]) / sum(psd_Yaw_1[1:(n1/2)])
  cum_psd_Yaw_2 <- cumsum(psd_Yaw_2[1:(n2/2)]) / sum(psd_Yaw_2[1:(n2/2)])
  cum_psd_Yaw_3 <- cumsum(psd_Yaw_3[1:(n3/2)]) / sum(psd_Yaw_3[1:(n3/2)])

  # Calculate bounds for each pull
  bounds_ap_1 <- find_freq_bounds(cum_psd_ap_1, freq1)
  bounds_ap_2 <- find_freq_bounds(cum_psd_ap_2, freq2)
  bounds_ap_3 <- find_freq_bounds(cum_psd_ap_3, freq3)
  
  bounds_ml_1 <- find_freq_bounds(cum_psd_ml_1, freq1)
  bounds_ml_2 <- find_freq_bounds(cum_psd_ml_2, freq2)
  bounds_ml_3 <- find_freq_bounds(cum_psd_ml_3, freq3)
  
  bounds_VT_1 <- find_freq_bounds(cum_psd_VT_1, freq1)
  bounds_VT_2 <- find_freq_bounds(cum_psd_VT_2, freq2)
  bounds_VT_3 <- find_freq_bounds(cum_psd_VT_3, freq3)
  
  bounds_Pitch_1 <- find_freq_bounds(cum_psd_Pitch_1, freq1)
  bounds_Pitch_2 <- find_freq_bounds(cum_psd_Pitch_2, freq2)
  bounds_Pitch_3 <- find_freq_bounds(cum_psd_Pitch_3, freq3)
  
  bounds_Roll_1 <- find_freq_bounds(cum_psd_Roll_1, freq1)
  bounds_Roll_2 <- find_freq_bounds(cum_psd_Roll_2, freq2)
  bounds_Roll_3 <- find_freq_bounds(cum_psd_Roll_3, freq3)
  
  bounds_Yaw_1 <- find_freq_bounds(cum_psd_Yaw_1, freq1)
  bounds_Yaw_2 <- find_freq_bounds(cum_psd_Yaw_2, freq2)
  bounds_Yaw_3 <- find_freq_bounds(cum_psd_Yaw_3, freq3)

  # Calculate the average range for the three pulls for AP and ML
  features$F95_AP[[i]] <- mean(c(bounds_ap_1[2] - bounds_ap_1[1], 
                                 bounds_ap_2[2] - bounds_ap_2[1], 
                                 bounds_ap_3[2] - bounds_ap_3[1]))
  features$F95_ML[[i]] <- mean(c(bounds_ml_1[2] - bounds_ml_1[1], 
                                 bounds_ml_2[2] - bounds_ml_2[1], 
                                 bounds_ml_3[2] - bounds_ml_3[1]))
  features$F95_VT[[i]] <- mean(c(bounds_VT_1[2] - bounds_VT_1[1], 
                                 bounds_VT_2[2] - bounds_VT_2[1], 
                                 bounds_VT_3[2] - bounds_VT_3[1]))
  features$F95_Pitch[[i]] <- mean(c(bounds_Pitch_1[2] - bounds_Pitch_1[1], 
                                 bounds_Pitch_2[2] - bounds_Pitch_2[1], 
                                 bounds_Pitch_3[2] - bounds_Pitch_3[1]))
  features$F95_Roll[[i]] <- mean(c(bounds_Roll_1[2] - bounds_Roll_1[1], 
                                 bounds_Roll_2[2] - bounds_Roll_2[1], 
                                 bounds_Roll_3[2] - bounds_Roll_3[1]))
  features$F95_Yaw[[i]] <- mean(c(bounds_Yaw_1[2] - bounds_Yaw_1[1], 
                                 bounds_Yaw_2[2] - bounds_Yaw_2[1], 
                                 bounds_Yaw_3[2] - bounds_Yaw_3[1]))
  
  # Optional: Store the min and max frequencies for each pull
  features$F95_min_AP[[i]] <- mean(c(bounds_ap_1[1], bounds_ap_2[1], bounds_ap_3[1]))
  features$F95_max_AP[[i]] <- mean(c(bounds_ap_1[2], bounds_ap_2[2], bounds_ap_3[2]))
  
  features$F95_min_ML[[i]] <- mean(c(bounds_ml_1[1], bounds_ml_2[1], bounds_ml_3[1]))
  features$F95_max_ML[[i]] <- mean(c(bounds_ml_1[2], bounds_ml_2[2], bounds_ml_3[2]))
  
  features$F95_min_VT[[i]] <- mean(c(bounds_VT_1[1], bounds_VT_2[1], bounds_VT_3[1]))
  features$F95_max_VT[[i]] <- mean(c(bounds_VT_1[2], bounds_VT_2[2], bounds_VT_3[2]))
  
  features$F95_min_Pitch[[i]] <- mean(c(bounds_Pitch_1[1], bounds_Pitch_2[1], bounds_Pitch_3[1]))
  features$F95_max_Pitch[[i]] <- mean(c(bounds_Pitch_1[2], bounds_Pitch_2[2], bounds_Pitch_3[2]))
  
  features$F95_min_Roll[[i]] <- mean(c(bounds_Roll_1[1], bounds_Roll_2[1], bounds_Roll_3[1]))
  features$F95_max_Roll[[i]] <- mean(c(bounds_Roll_1[2], bounds_Roll_2[2], bounds_Roll_3[2]))
  
  features$F95_min_Yaw[[i]] <- mean(c(bounds_Yaw_1[1], bounds_Yaw_2[1], bounds_Yaw_3[1]))
  features$F95_max_Yaw[[i]] <- mean(c(bounds_Yaw_1[2], bounds_Yaw_2[2], bounds_Yaw_3[2]))
}



```

### Anteroposterior

#### Range

```{r Mann-Whitney-U-test_F95, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_AP_HYclass2 <- features$F95_AP[features$HYclass == group_A]
F95_AP_HYclass3 <- features$F95_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_AP <- wilcox.test(F95_AP_HYclass2, F95_AP_HYclass3)$p.value

```


```{r F95_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


#### Min

```{r Mann-Whitney-U-test_F95_min, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_min_AP_HYclass2 <- features$F95_min_AP[features$HYclass == group_A]
F95_min_AP_HYclass3 <- features$F95_min_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_min_AP <- wilcox.test(F95_min_AP_HYclass2, F95_min_AP_HYclass3)$p.value

```

```{r F95_min_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_min_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_min_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_min_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_min_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Max

```{r Mann-Whitney-U-test_F95_max, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_max_AP_HYclass2 <- features$F95_max_AP[features$HYclass == group_A]
F95_max_AP_HYclass3 <- features$F95_max_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_max_AP <- wilcox.test(F95_max_AP_HYclass2, F95_max_AP_HYclass3)$p.value

```

```{r F95_max_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_max_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_max_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_max_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_max_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

#### Range

```{r Mann-Whitney-U-test_F95_ml, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_ML_HYclass2 <- features$F95_ML[features$HYclass == group_A]
F95_ML_HYclass3 <- features$F95_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_ML <- wilcox.test(F95_ML_HYclass2, F95_ML_HYclass3)$p.value

```


```{r F95_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Min

```{r Mann-Whitney-U-test_F95_min_ml, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_min_ML_HYclass2 <- features$F95_min_ML[features$HYclass == group_A]
F95_min_ML_HYclass3 <- features$F95_min_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_min_ML <- wilcox.test(F95_min_ML_HYclass2, F95_min_ML_HYclass3)$p.value

```


```{r F95_min_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_min_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_min_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_min_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_min_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Max

```{r Mann-Whitney-U-test_F95_max_ml, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_max_ML_HYclass2 <- features$F95_max_ML[features$HYclass == group_A]
F95_max_ML_HYclass3 <- features$F95_max_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_max_ML <- wilcox.test(F95_max_ML_HYclass2, F95_max_ML_HYclass3)$p.value

```



```{r F95_max_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_max_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_max_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_max_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_max_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

#### Range

```{r Mann-Whitney-U-test_F95_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_VT_HYclass2 <- features$F95_VT[features$HYclass == group_A]
F95_VT_HYclass3 <- features$F95_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_VT <- wilcox.test(F95_VT_HYclass2, F95_VT_HYclass3)$p.value

```


```{r F95_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Min

```{r Mann-Whitney-U-test_F95_min_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_min_VT_HYclass2 <- features$F95_min_VT[features$HYclass == group_A]
F95_min_VT_HYclass3 <- features$F95_min_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_min_VT <- wilcox.test(F95_min_VT_HYclass2, F95_min_VT_HYclass3)$p.value

```


```{r F95_min_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_min_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_min_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_min_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_min_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Max

```{r Mann-Whitney-U-test_F95_max_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_max_VT_HYclass2 <- features$F95_max_VT[features$HYclass == group_A]
F95_max_VT_HYclass3 <- features$F95_max_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_max_VT <- wilcox.test(F95_max_VT_HYclass2, F95_max_VT_HYclass3)$p.value

```



```{r F95_max_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_max_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_max_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_max_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_max_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

#### Range

```{r Mann-Whitney-U-test_F95_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_Pitch_HYclass2 <- features$F95_Pitch[features$HYclass == group_A]
F95_Pitch_HYclass3 <- features$F95_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_Pitch <- wilcox.test(F95_Pitch_HYclass2, F95_Pitch_HYclass3)$p.value

```


```{r F95_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Min

```{r Mann-Whitney-U-test_F95_min_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_min_Pitch_HYclass2 <- features$F95_min_Pitch[features$HYclass == group_A]
F95_min_Pitch_HYclass3 <- features$F95_min_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_min_Pitch <- wilcox.test(F95_min_Pitch_HYclass2, F95_min_Pitch_HYclass3)$p.value

```


```{r F95_min_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_min_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_min_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_min_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_min_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Max

```{r Mann-Whitney-U-test_F95_max_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_max_Pitch_HYclass2 <- features$F95_max_Pitch[features$HYclass == group_A]
F95_max_Pitch_HYclass3 <- features$F95_max_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_max_Pitch <- wilcox.test(F95_max_Pitch_HYclass2, F95_max_Pitch_HYclass3)$p.value

```



```{r F95_max_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_max_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_max_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_max_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_max_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

#### Range

```{r Mann-Whitney-U-test_F95_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_Roll_HYclass2 <- features$F95_Roll[features$HYclass == group_A]
F95_Roll_HYclass3 <- features$F95_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_Roll <- wilcox.test(F95_Roll_HYclass2, F95_Roll_HYclass3)$p.value

```


```{r F95_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Min

```{r Mann-Whitney-U-test_F95_min_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_min_Roll_HYclass2 <- features$F95_min_Roll[features$HYclass == group_A]
F95_min_Roll_HYclass3 <- features$F95_min_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_min_Roll <- wilcox.test(F95_min_Roll_HYclass2, F95_min_Roll_HYclass3)$p.value

```


```{r F95_min_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_min_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_min_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_min_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_min_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Max

```{r Mann-Whitney-U-test_F95_max_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_max_Roll_HYclass2 <- features$F95_max_Roll[features$HYclass == group_A]
F95_max_Roll_HYclass3 <- features$F95_max_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_max_Roll <- wilcox.test(F95_max_Roll_HYclass2, F95_max_Roll_HYclass3)$p.value

```



```{r F95_max_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_max_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_max_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_max_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_max_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

#### Range

```{r Mann-Whitney-U-test_F95_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_Yaw_HYclass2 <- features$F95_Yaw[features$HYclass == group_A]
F95_Yaw_HYclass3 <- features$F95_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_Yaw <- wilcox.test(F95_Yaw_HYclass2, F95_Yaw_HYclass3)$p.value

```


```{r F95_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Min

```{r Mann-Whitney-U-test_F95_min_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_min_Yaw_HYclass2 <- features$F95_min_Yaw[features$HYclass == group_A]
F95_min_Yaw_HYclass3 <- features$F95_min_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_min_Yaw <- wilcox.test(F95_min_Yaw_HYclass2, F95_min_Yaw_HYclass3)$p.value

```


```{r F95_min_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_min_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_min_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_min_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_min_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Max

```{r Mann-Whitney-U-test_F95_max_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
F95_max_Yaw_HYclass2 <- features$F95_max_Yaw[features$HYclass == group_A]
F95_max_Yaw_HYclass3 <- features$F95_max_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F95_max_Yaw <- wilcox.test(F95_max_Yaw_HYclass2, F95_max_Yaw_HYclass3)$p.value

```



```{r F95_max_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F95_max_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F95_max_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F95_max_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F95_max_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Frequency Range 50

```{r f_50, echo = FALSE}
features$F50_AP <- NA 
features$F50_ML <- NA  
features$F50_VT <- NA 
features$F50_Pitch <- NA 
features$F50_Roll <- NA 
features$F50_Yaw <- NA 

features$F50_max_AP <- NA 
features$F50_max_ML <- NA  
features$F50_max_VT <- NA 
features$F50_max_Pitch <- NA 
features$F50_max_Roll <- NA 
features$F50_max_Yaw <- NA 

features$F50_min_AP <- NA 
features$F50_min_ML <- NA 
features$F50_min_VT <- NA 
features$F50_min_Pitch <- NA 
features$F50_min_Roll <- NA 
features$F50_min_Yaw <- NA  

  # Define a function to find the lower and upper frequency bounds
find_freq_bounds <- function(cum_psd, freq) {
    lower <- min(freq[cum_psd >= 0.25])
    upper <- min(freq[cum_psd > 0.75])  
    return(c(lower, upper))
}

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_Pitch_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_Pitch_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_Pitch_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_Pitch_1 <- Mod(fft_Pitch_1[1:(n1/2)])^2
  psd_Pitch_2 <- Mod(fft_Pitch_2[1:(n2/2)])^2
  psd_Pitch_3 <- Mod(fft_Pitch_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate the cumulative sum of PSD for each axis and pull
  cum_psd_ap_1 <- cumsum(psd_ap_1[1:(n1/2)]) / sum(psd_ap_1[1:(n1/2)])
  cum_psd_ap_2 <- cumsum(psd_ap_2[1:(n2/2)]) / sum(psd_ap_2[1:(n2/2)])
  cum_psd_ap_3 <- cumsum(psd_ap_3[1:(n3/2)]) / sum(psd_ap_3[1:(n3/2)])
  
  cum_psd_ml_1 <- cumsum(psd_ml_1[1:(n1/2)]) / sum(psd_ml_1[1:(n1/2)])
  cum_psd_ml_2 <- cumsum(psd_ml_2[1:(n2/2)]) / sum(psd_ml_2[1:(n2/2)])
  cum_psd_ml_3 <- cumsum(psd_ml_3[1:(n3/2)]) / sum(psd_ml_3[1:(n3/2)])
  
  cum_psd_VT_1 <- cumsum(psd_VT_1[1:(n1/2)]) / sum(psd_VT_1[1:(n1/2)])
  cum_psd_VT_2 <- cumsum(psd_VT_2[1:(n2/2)]) / sum(psd_VT_2[1:(n2/2)])
  cum_psd_VT_3 <- cumsum(psd_VT_3[1:(n3/2)]) / sum(psd_VT_3[1:(n3/2)])
  
  cum_psd_Pitch_1 <- cumsum(psd_Pitch_1[1:(n1/2)]) / sum(psd_Pitch_1[1:(n1/2)])
  cum_psd_Pitch_2 <- cumsum(psd_Pitch_2[1:(n2/2)]) / sum(psd_Pitch_2[1:(n2/2)])
  cum_psd_Pitch_3 <- cumsum(psd_Pitch_3[1:(n3/2)]) / sum(psd_Pitch_3[1:(n3/2)])
  
  cum_psd_Roll_1 <- cumsum(psd_Roll_1[1:(n1/2)]) / sum(psd_Roll_1[1:(n1/2)])
  cum_psd_Roll_2 <- cumsum(psd_Roll_2[1:(n2/2)]) / sum(psd_Roll_2[1:(n2/2)])
  cum_psd_Roll_3 <- cumsum(psd_Roll_3[1:(n3/2)]) / sum(psd_Roll_3[1:(n3/2)])
  
  cum_psd_Yaw_1 <- cumsum(psd_Yaw_1[1:(n1/2)]) / sum(psd_Yaw_1[1:(n1/2)])
  cum_psd_Yaw_2 <- cumsum(psd_Yaw_2[1:(n2/2)]) / sum(psd_Yaw_2[1:(n2/2)])
  cum_psd_Yaw_3 <- cumsum(psd_Yaw_3[1:(n3/2)]) / sum(psd_Yaw_3[1:(n3/2)])

  # Calculate bounds for each pull
  bounds_ap_1 <- find_freq_bounds(cum_psd_ap_1, freq1)
  bounds_ap_2 <- find_freq_bounds(cum_psd_ap_2, freq2)
  bounds_ap_3 <- find_freq_bounds(cum_psd_ap_3, freq3)
  
  bounds_ml_1 <- find_freq_bounds(cum_psd_ml_1, freq1)
  bounds_ml_2 <- find_freq_bounds(cum_psd_ml_2, freq2)
  bounds_ml_3 <- find_freq_bounds(cum_psd_ml_3, freq3)
  
  bounds_VT_1 <- find_freq_bounds(cum_psd_VT_1, freq1)
  bounds_VT_2 <- find_freq_bounds(cum_psd_VT_2, freq2)
  bounds_VT_3 <- find_freq_bounds(cum_psd_VT_3, freq3)
  
  bounds_Pitch_1 <- find_freq_bounds(cum_psd_Pitch_1, freq1)
  bounds_Pitch_2 <- find_freq_bounds(cum_psd_Pitch_2, freq2)
  bounds_Pitch_3 <- find_freq_bounds(cum_psd_Pitch_3, freq3)
  
  bounds_Roll_1 <- find_freq_bounds(cum_psd_Roll_1, freq1)
  bounds_Roll_2 <- find_freq_bounds(cum_psd_Roll_2, freq2)
  bounds_Roll_3 <- find_freq_bounds(cum_psd_Roll_3, freq3)
  
  bounds_Yaw_1 <- find_freq_bounds(cum_psd_Yaw_1, freq1)
  bounds_Yaw_2 <- find_freq_bounds(cum_psd_Yaw_2, freq2)
  bounds_Yaw_3 <- find_freq_bounds(cum_psd_Yaw_3, freq3)

  # Calculate the average range for the three pulls for AP and ML
  features$F50_AP[[i]] <- mean(c(bounds_ap_1[2] - bounds_ap_1[1], 
                                 bounds_ap_2[2] - bounds_ap_2[1], 
                                 bounds_ap_3[2] - bounds_ap_3[1]))
  features$F50_ML[[i]] <- mean(c(bounds_ml_1[2] - bounds_ml_1[1], 
                                 bounds_ml_2[2] - bounds_ml_2[1], 
                                 bounds_ml_3[2] - bounds_ml_3[1]))
  features$F50_VT[[i]] <- mean(c(bounds_VT_1[2] - bounds_VT_1[1], 
                                 bounds_VT_2[2] - bounds_VT_2[1], 
                                 bounds_VT_3[2] - bounds_VT_3[1]))
  features$F50_Pitch[[i]] <- mean(c(bounds_Pitch_1[2] - bounds_Pitch_1[1], 
                                 bounds_Pitch_2[2] - bounds_Pitch_2[1], 
                                 bounds_Pitch_3[2] - bounds_Pitch_3[1]))
  features$F50_Roll[[i]] <- mean(c(bounds_Roll_1[2] - bounds_Roll_1[1], 
                                 bounds_Roll_2[2] - bounds_Roll_2[1], 
                                 bounds_Roll_3[2] - bounds_Roll_3[1]))
  features$F50_Yaw[[i]] <- mean(c(bounds_Yaw_1[2] - bounds_Yaw_1[1], 
                                 bounds_Yaw_2[2] - bounds_Yaw_2[1], 
                                 bounds_Yaw_3[2] - bounds_Yaw_3[1]))
  
  # Optional: Store the min and max frequencies for each pull
  features$F50_min_AP[[i]] <- mean(c(bounds_ap_1[1], bounds_ap_2[1], bounds_ap_3[1]))
  features$F50_max_AP[[i]] <- mean(c(bounds_ap_1[2], bounds_ap_2[2], bounds_ap_3[2]))
  
  features$F50_min_ML[[i]] <- mean(c(bounds_ml_1[1], bounds_ml_2[1], bounds_ml_3[1]))
  features$F50_max_ML[[i]] <- mean(c(bounds_ml_1[2], bounds_ml_2[2], bounds_ml_3[2]))
  
  features$F50_min_VT[[i]] <- mean(c(bounds_VT_1[1], bounds_VT_2[1], bounds_VT_3[1]))
  features$F50_max_VT[[i]] <- mean(c(bounds_VT_1[2], bounds_VT_2[2], bounds_VT_3[2]))
  
  features$F50_min_Pitch[[i]] <- mean(c(bounds_Pitch_1[1], bounds_Pitch_2[1], bounds_Pitch_3[1]))
  features$F50_max_Pitch[[i]] <- mean(c(bounds_Pitch_1[2], bounds_Pitch_2[2], bounds_Pitch_3[2]))
  
  features$F50_min_Roll[[i]] <- mean(c(bounds_Roll_1[1], bounds_Roll_2[1], bounds_Roll_3[1]))
  features$F50_max_Roll[[i]] <- mean(c(bounds_Roll_1[2], bounds_Roll_2[2], bounds_Roll_3[2]))
  
  features$F50_min_Yaw[[i]] <- mean(c(bounds_Yaw_1[1], bounds_Yaw_2[1], bounds_Yaw_3[1]))
  features$F50_max_Yaw[[i]] <- mean(c(bounds_Yaw_1[2], bounds_Yaw_2[2], bounds_Yaw_3[2]))
}



```

### Anteroposterior

#### Range

```{r Mann-Whitney-U-test_F50, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_AP_HYclass2 <- features$F50_AP[features$HYclass == group_A]
F50_AP_HYclass3 <- features$F50_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_AP <- wilcox.test(F50_AP_HYclass2, F50_AP_HYclass3)$p.value

```


```{r F50_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


#### Min

```{r Mann-Whitney-U-test_F50_min, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_min_AP_HYclass2 <- features$F50_min_AP[features$HYclass == group_A]
F50_min_AP_HYclass3 <- features$F50_min_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_min_AP <- wilcox.test(F50_min_AP_HYclass2, F50_min_AP_HYclass3)$p.value

```

```{r F50_min_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_min_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_min_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_min_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_min_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Max

```{r Mann-Whitney-U-test_F50_max, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_max_AP_HYclass2 <- features$F50_max_AP[features$HYclass == group_A]
F50_max_AP_HYclass3 <- features$F50_max_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_max_AP <- wilcox.test(F50_max_AP_HYclass2, F50_max_AP_HYclass3)$p.value

```

```{r F50_max_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_max_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_max_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_max_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_max_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

#### Range

```{r Mann-Whitney-U-test_F50_ml, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_ML_HYclass2 <- features$F50_ML[features$HYclass == group_A]
F50_ML_HYclass3 <- features$F50_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_ML <- wilcox.test(F50_ML_HYclass2, F50_ML_HYclass3)$p.value

```


```{r F50_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Min

```{r Mann-Whitney-U-test_F50_min_ml, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_min_ML_HYclass2 <- features$F50_min_ML[features$HYclass == group_A]
F50_min_ML_HYclass3 <- features$F50_min_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_min_ML <- wilcox.test(F50_min_ML_HYclass2, F50_min_ML_HYclass3)$p.value

```


```{r F50_min_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_min_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_min_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_min_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_min_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Max

```{r Mann-Whitney-U-test_F50_max_ml, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_max_ML_HYclass2 <- features$F50_max_ML[features$HYclass == group_A]
F50_max_ML_HYclass3 <- features$F50_max_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_max_ML <- wilcox.test(F50_max_ML_HYclass2, F50_max_ML_HYclass3)$p.value

```



```{r F50_max_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_max_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_max_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_max_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_max_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

#### Range

```{r Mann-Whitney-U-test_F50_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_VT_HYclass2 <- features$F50_VT[features$HYclass == group_A]
F50_VT_HYclass3 <- features$F50_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_VT <- wilcox.test(F50_VT_HYclass2, F50_VT_HYclass3)$p.value

```


```{r F50_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Min

```{r Mann-Whitney-U-test_F50_min_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_min_VT_HYclass2 <- features$F50_min_VT[features$HYclass == group_A]
F50_min_VT_HYclass3 <- features$F50_min_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_min_VT <- wilcox.test(F50_min_VT_HYclass2, F50_min_VT_HYclass3)$p.value

```


```{r F50_min_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_min_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_min_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_min_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_min_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Max

```{r Mann-Whitney-U-test_F50_max_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_max_VT_HYclass2 <- features$F50_max_VT[features$HYclass == group_A]
F50_max_VT_HYclass3 <- features$F50_max_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_max_VT <- wilcox.test(F50_max_VT_HYclass2, F50_max_VT_HYclass3)$p.value

```



```{r F50_max_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_max_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_max_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_max_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_max_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

#### Range

```{r Mann-Whitney-U-test_F50_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_Pitch_HYclass2 <- features$F50_Pitch[features$HYclass == group_A]
F50_Pitch_HYclass3 <- features$F50_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_Pitch <- wilcox.test(F50_Pitch_HYclass2, F50_Pitch_HYclass3)$p.value

```


```{r F50_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Min

```{r Mann-Whitney-U-test_F50_min_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_min_Pitch_HYclass2 <- features$F50_min_Pitch[features$HYclass == group_A]
F50_min_Pitch_HYclass3 <- features$F50_min_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_min_Pitch <- wilcox.test(F50_min_Pitch_HYclass2, F50_min_Pitch_HYclass3)$p.value

```


```{r F50_min_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_min_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_min_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_min_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_min_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Max

```{r Mann-Whitney-U-test_F50_max_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_max_Pitch_HYclass2 <- features$F50_max_Pitch[features$HYclass == group_A]
F50_max_Pitch_HYclass3 <- features$F50_max_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_max_Pitch <- wilcox.test(F50_max_Pitch_HYclass2, F50_max_Pitch_HYclass3)$p.value

```



```{r F50_max_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_max_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_max_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_max_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_max_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

#### Range

```{r Mann-Whitney-U-test_F50_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_Roll_HYclass2 <- features$F50_Roll[features$HYclass == group_A]
F50_Roll_HYclass3 <- features$F50_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_Roll <- wilcox.test(F50_Roll_HYclass2, F50_Roll_HYclass3)$p.value

```


```{r F50_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Min

```{r Mann-Whitney-U-test_F50_min_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_min_Roll_HYclass2 <- features$F50_min_Roll[features$HYclass == group_A]
F50_min_Roll_HYclass3 <- features$F50_min_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_min_Roll <- wilcox.test(F50_min_Roll_HYclass2, F50_min_Roll_HYclass3)$p.value

```


```{r F50_min_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_min_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_min_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_min_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_min_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Max

```{r Mann-Whitney-U-test_F50_max_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_max_Roll_HYclass2 <- features$F50_max_Roll[features$HYclass == group_A]
F50_max_Roll_HYclass3 <- features$F50_max_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_max_Roll <- wilcox.test(F50_max_Roll_HYclass2, F50_max_Roll_HYclass3)$p.value

```



```{r F50_max_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_max_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_max_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_max_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_max_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

#### Range

```{r Mann-Whitney-U-test_F50_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_Yaw_HYclass2 <- features$F50_Yaw[features$HYclass == group_A]
F50_Yaw_HYclass3 <- features$F50_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_Yaw <- wilcox.test(F50_Yaw_HYclass2, F50_Yaw_HYclass3)$p.value

```


```{r F50_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Min

```{r Mann-Whitney-U-test_F50_min_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_min_Yaw_HYclass2 <- features$F50_min_Yaw[features$HYclass == group_A]
F50_min_Yaw_HYclass3 <- features$F50_min_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_min_Yaw <- wilcox.test(F50_min_Yaw_HYclass2, F50_min_Yaw_HYclass3)$p.value

```


```{r F50_min_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_min_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_min_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_min_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_min_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

#### Max

```{r Mann-Whitney-U-test_F50_max_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
F50_max_Yaw_HYclass2 <- features$F50_max_Yaw[features$HYclass == group_A]
F50_max_Yaw_HYclass3 <- features$F50_max_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$F50_max_Yaw <- wilcox.test(F50_max_Yaw_HYclass2, F50_max_Yaw_HYclass3)$p.value

```



```{r F50_max_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$F50_max_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$F50_max_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$F50_max_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$F50_max_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Median Frequency


```{r median_freq, echo = FALSE}
features$MF_AP <- NA
features$MF_ML <- NA
features$MF_VT <- NA
features$MF_Pitch <- NA
features$MF_Roll <- NA
features$MF_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_Pitch_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_Pitch_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_Pitch_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_Pitch_1 <- Mod(fft_Pitch_1[1:(n1/2)])^2
  psd_Pitch_2 <- Mod(fft_Pitch_2[1:(n2/2)])^2
  psd_Pitch_3 <- Mod(fft_Pitch_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate the cumulative sum of the PSD
  cum_psd_ap_1 <- cumsum(psd_ap_1)
  cum_psd_ap_2 <- cumsum(psd_ap_2)
  cum_psd_ap_3 <- cumsum(psd_ap_3)
  
  cum_psd_ml_1 <- cumsum(psd_ml_1)
  cum_psd_ml_2 <- cumsum(psd_ml_2)
  cum_psd_ml_3 <- cumsum(psd_ml_3)
  
  cum_psd_VT_1 <- cumsum(psd_VT_1)
  cum_psd_VT_2 <- cumsum(psd_VT_2)
  cum_psd_VT_3 <- cumsum(psd_VT_3)
  
  cum_psd_Pitch_1 <- cumsum(psd_Pitch_1)
  cum_psd_Pitch_2 <- cumsum(psd_Pitch_2)
  cum_psd_Pitch_3 <- cumsum(psd_Pitch_3)
  
  cum_psd_Roll_1 <- cumsum(psd_Roll_1)
  cum_psd_Roll_2 <- cumsum(psd_Roll_2)
  cum_psd_Roll_3 <- cumsum(psd_Roll_3)
  
  cum_psd_Yaw_1 <- cumsum(psd_Yaw_1)
  cum_psd_Yaw_2 <- cumsum(psd_Yaw_2)
  cum_psd_Yaw_3 <- cumsum(psd_Yaw_3)

  # Calculate median frequency for each pull
  MF_AP_1 <- freq1[which(cum_psd_ap_1 >= (tail(cum_psd_ap_1, 1) / 2))[1]]
  MF_AP_2 <- freq2[which(cum_psd_ap_2 >= (tail(cum_psd_ap_2, 1) / 2))[1]]
  MF_AP_3 <- freq3[which(cum_psd_ap_3 >= (tail(cum_psd_ap_3, 1) / 2))[1]]
  
  MF_ML_1 <- freq1[which(cum_psd_ml_1 >= (tail(cum_psd_ml_1, 1) / 2))[1]]
  MF_ML_2 <- freq2[which(cum_psd_ml_2 >= (tail(cum_psd_ml_2, 1) / 2))[1]]
  MF_ML_3 <- freq3[which(cum_psd_ml_3 >= (tail(cum_psd_ml_3, 1) / 2))[1]]
  
  MF_VT_1 <- freq1[which(cum_psd_VT_1 >= (tail(cum_psd_VT_1, 1) / 2))[1]]
  MF_VT_2 <- freq2[which(cum_psd_VT_2 >= (tail(cum_psd_VT_2, 1) / 2))[1]]
  MF_VT_3 <- freq3[which(cum_psd_VT_3 >= (tail(cum_psd_VT_3, 1) / 2))[1]]
  
  MF_Pitch_1 <- freq1[which(cum_psd_Pitch_1 >= (tail(cum_psd_Pitch_1, 1) / 2))[1]]
  MF_Pitch_2 <- freq2[which(cum_psd_Pitch_2 >= (tail(cum_psd_Pitch_2, 1) / 2))[1]]
  MF_Pitch_3 <- freq3[which(cum_psd_Pitch_3 >= (tail(cum_psd_Pitch_3, 1) / 2))[1]]
  
  MF_Roll_1 <- freq1[which(cum_psd_Roll_1 >= (tail(cum_psd_Roll_1, 1) / 2))[1]]
  MF_Roll_2 <- freq2[which(cum_psd_Roll_2 >= (tail(cum_psd_Roll_2, 1) / 2))[1]]
  MF_Roll_3 <- freq3[which(cum_psd_Roll_3 >= (tail(cum_psd_Roll_3, 1) / 2))[1]]
  
  MF_Yaw_1 <- freq1[which(cum_psd_Yaw_1 >= (tail(cum_psd_Yaw_1, 1) / 2))[1]]
  MF_Yaw_2 <- freq2[which(cum_psd_Yaw_2 >= (tail(cum_psd_Yaw_2, 1) / 2))[1]]
  MF_Yaw_3 <- freq3[which(cum_psd_Yaw_3 >= (tail(cum_psd_Yaw_3, 1) / 2))[1]]

  # Average the median frequency for the three pulls
  features$MF_AP[i] <- mean(c(MF_AP_1, MF_AP_2, MF_AP_3))
  features$MF_ML[i] <- mean(c(MF_ML_1, MF_ML_2, MF_ML_3))
  features$MF_VT[i] <- mean(c(MF_VT_1, MF_VT_2, MF_VT_3))
  features$MF_Pitch[i] <- mean(c(MF_Pitch_1, MF_Pitch_2, MF_Pitch_3))
  features$MF_Roll[i] <- mean(c(MF_Roll_1, MF_Roll_2, MF_Roll_3))
  features$MF_Yaw[i] <- mean(c(MF_Yaw_1, MF_Yaw_2, MF_Yaw_3))
  
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_MF, echo=FALSE}

# Extract values for HYclass 2 and 3
MF_AP_HYclass2 <- features$MF_AP[features$HYclass == group_A]
MF_AP_HYclass3 <- features$MF_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MF_AP <- wilcox.test(MF_AP_HYclass2, MF_AP_HYclass3)$p.value

```

```{r MF_plot, echo=FALSE}

boxplot(MF_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "MF_AP",
        #ylim = c(0,1.6),
        main = "Median Frequency - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r MF_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MF_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MF_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MF_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MF_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_MF_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
MF_ML_HYclass2 <- features$MF_ML[features$HYclass == group_A]
MF_ML_HYclass3 <- features$MF_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MF_ML <- wilcox.test(MF_ML_HYclass2, MF_ML_HYclass3)$p.value

```


```{r MF_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MF_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MF_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MF_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MF_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_MF_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
MF_VT_HYclass2 <- features$MF_VT[features$HYclass == group_A]
MF_VT_HYclass3 <- features$MF_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MF_VT <- wilcox.test(MF_VT_HYclass2, MF_VT_HYclass3)$p.value

```


```{r MF_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MF_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MF_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MF_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MF_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_MF_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
MF_Pitch_HYclass2 <- features$MF_Pitch[features$HYclass == group_A]
MF_Pitch_HYclass3 <- features$MF_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MF_Pitch <- wilcox.test(MF_Pitch_HYclass2, MF_Pitch_HYclass3)$p.value

```


```{r MF_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MF_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MF_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MF_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MF_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_MF_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
MF_Roll_HYclass2 <- features$MF_Roll[features$HYclass == group_A]
MF_Roll_HYclass3 <- features$MF_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MF_Roll <- wilcox.test(MF_Roll_HYclass2, MF_Roll_HYclass3)$p.value

```


```{r MF_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MF_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MF_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MF_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MF_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_MF_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
MF_Yaw_HYclass2 <- features$MF_Yaw[features$HYclass == group_A]
MF_Yaw_HYclass3 <- features$MF_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MF_Yaw <- wilcox.test(MF_Yaw_HYclass2, MF_Yaw_HYclass3)$p.value

```


```{r MF_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MF_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MF_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MF_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MF_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Peak (max) Frequency


```{r peak_frequency, echo = FALSE}
features$PF_AP <- NA
features$PF_ML <- NA
features$PF_VT <- NA
features$PF_Pitch <- NA
features$PF_Roll <- NA
features$PF_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_Pitch_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_Pitch_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_Pitch_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_Pitch_1 <- Mod(fft_Pitch_1[1:(n1/2)])^2
  psd_Pitch_2 <- Mod(fft_Pitch_2[1:(n2/2)])^2
  psd_Pitch_3 <- Mod(fft_Pitch_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate peak frequncy for each pull
  PF_AP_1 <- freq1[6:50][which.max(psd_ap_1[6:50])]
  PF_AP_2 <- freq2[6:50][which.max(psd_ap_2[6:50])]
  PF_AP_3 <- freq3[6:50][which.max(psd_ap_3[6:50])]
  
  PF_ML_1 <- freq1[which.max(psd_ml_1)]
  PF_ML_2 <- freq2[which.max(psd_ml_2)]
  PF_ML_3 <- freq3[which.max(psd_ml_3)]
  
  PF_VT_1 <- freq1[which.max(psd_VT_1)]
  PF_VT_2 <- freq2[which.max(psd_VT_2)]
  PF_VT_3 <- freq3[which.max(psd_VT_3)]
  
  PF_Pitch_1 <- freq1[which.max(psd_Pitch_1)]
  PF_Pitch_2 <- freq2[which.max(psd_Pitch_2)]
  PF_Pitch_3 <- freq3[which.max(psd_Pitch_3)]
  
  PF_Roll_1 <- freq1[which.max(psd_Roll_1)]
  PF_Roll_2 <- freq2[which.max(psd_Roll_2)]
  PF_Roll_3 <- freq3[which.max(psd_Roll_3)]
  
  PF_Yaw_1 <- freq1[which.max(psd_Yaw_1)]
  PF_Yaw_2 <- freq2[which.max(psd_Yaw_2)]
  PF_Yaw_3 <- freq3[which.max(psd_Yaw_3)]
  
  # Average the peak frequency for the three pulls
  features$PF_AP[i] <- mean(c(PF_AP_1, PF_AP_2, PF_AP_3))
  features$PF_ML[i] <- mean(c(PF_ML_1, PF_ML_2, PF_ML_3))
  features$PF_VT[i] <- mean(c(PF_VT_1, PF_VT_2, PF_VT_3))
  features$PF_Pitch[i] <- mean(c(PF_Pitch_1, PF_Pitch_2, PF_Pitch_3))
  features$PF_Roll[i] <- mean(c(PF_Roll_1, PF_Roll_2, PF_Roll_3))
  features$PF_Yaw[i] <- mean(c(PF_Yaw_1, PF_Yaw_2, PF_Yaw_3))

  
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PF, echo=FALSE}

# Extract values for HYclass 2 and 3
PF_AP_HYclass2 <- features$PF_AP[features$HYclass == group_A]
PF_AP_HYclass3 <- features$PF_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PF_AP <- wilcox.test(PF_AP_HYclass2, PF_AP_HYclass3)$p.value

```

```{r PF_plot, echo=FALSE}

boxplot(PF_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PF_AP",
        #ylim = c(0,1.6),
        main = "Peak Frequency - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PF_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PF_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PF_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PF_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PF_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_PF_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PF_ML_HYclass2 <- features$PF_ML[features$HYclass == group_A]
PF_ML_HYclass3 <- features$PF_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PF_ML <- wilcox.test(PF_ML_HYclass2, PF_ML_HYclass3)$p.value

```


```{r PF_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PF_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PF_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PF_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PF_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PF_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PF_VT_HYclass2 <- features$PF_VT[features$HYclass == group_A]
PF_VT_HYclass3 <- features$PF_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PF_VT <- wilcox.test(PF_VT_HYclass2, PF_VT_HYclass3)$p.value

```


```{r PF_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PF_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PF_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PF_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PF_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_PF_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PF_Pitch_HYclass2 <- features$PF_Pitch[features$HYclass == group_A]
PF_Pitch_HYclass3 <- features$PF_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PF_Pitch <- wilcox.test(PF_Pitch_HYclass2, PF_Pitch_HYclass3)$p.value

```


```{r PF_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PF_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PF_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PF_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PF_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PF_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PF_Roll_HYclass2 <- features$PF_Roll[features$HYclass == group_A]
PF_Roll_HYclass3 <- features$PF_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PF_Roll <- wilcox.test(PF_Roll_HYclass2, PF_Roll_HYclass3)$p.value

```


```{r PF_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PF_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PF_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PF_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PF_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PF_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PF_Yaw_HYclass2 <- features$PF_Yaw[features$HYclass == group_A]
PF_Yaw_HYclass3 <- features$PF_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PF_Yaw <- wilcox.test(PF_Yaw_HYclass2, PF_Yaw_HYclass3)$p.value

```


```{r PF_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PF_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PF_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PF_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PF_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Centroidal (mean) Frequency

```{r centroidal_frequency, echo = FALSE}
features$CF_AP <- NA
features$CF_ML <- NA
features$CF_VT <- NA
features$CF_Pitch <- NA
features$CF_Roll <- NA
features$CF_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # first calculate centroidal frequency:
  CF_AP_1 <- sum(freq1 * psd_ap_1) / sum(psd_ap_1)
  CF_AP_2 <- sum(freq2 * psd_ap_2) / sum(psd_ap_2)
  CF_AP_3 <- sum(freq3 * psd_ap_3) / sum(psd_ap_3)
  
  CF_ML_1 <- sum(freq1 * psd_ml_1) / sum(psd_ml_1)
  CF_ML_2 <- sum(freq2 * psd_ml_2) / sum(psd_ml_2)
  CF_ML_3 <- sum(freq3 * psd_ml_3) / sum(psd_ml_3)
  
  CF_VT_1 <- sum(freq1 * psd_VT_1) / sum(psd_VT_1)
  CF_VT_2 <- sum(freq2 * psd_VT_2) / sum(psd_VT_2)
  CF_VT_3 <- sum(freq3 * psd_VT_3) / sum(psd_VT_3)
  
  CF_Pitch_1 <- sum(freq1 * psd_pi_1) / sum(psd_pi_1)
  CF_Pitch_2 <- sum(freq2 * psd_pi_2) / sum(psd_pi_2)
  CF_Pitch_3 <- sum(freq3 * psd_pi_3) / sum(psd_pi_3)
  
  CF_Roll_1 <- sum(freq1 * psd_Roll_1) / sum(psd_Roll_1)
  CF_Roll_2 <- sum(freq2 * psd_Roll_2) / sum(psd_Roll_2)
  CF_Roll_3 <- sum(freq3 * psd_Roll_3) / sum(psd_Roll_3)
  
  CF_Yaw_1 <- sum(freq1 * psd_Yaw_1) / sum(psd_Yaw_1)
  CF_Yaw_2 <- sum(freq2 * psd_Yaw_2) / sum(psd_Yaw_2)
  CF_Yaw_3 <- sum(freq3 * psd_Yaw_3) / sum(psd_Yaw_3)

  # Average for the three pulls taking
  features$CF_AP[i] <- mean(c(CF_AP_1, CF_AP_2, CF_AP_3))
  features$CF_ML[i] <- mean(c(CF_ML_1, CF_ML_2, CF_ML_3))
  features$CF_VT[i] <- mean(c(CF_VT_1, CF_VT_2, CF_VT_3))
  features$CF_Pitch[i] <- mean(c(CF_Pitch_1, CF_Pitch_2, CF_Pitch_3))
  features$CF_Roll[i] <- mean(c(CF_Roll_1, CF_Roll_2, CF_Roll_3))
  features$CF_Yaw[i] <- mean(c(CF_Yaw_1, CF_Yaw_2, CF_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_CF_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_AP_HYclass2 <- features$CF_AP[features$HYclass == group_A]
CF_AP_HYclass3 <- features$CF_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_AP <- wilcox.test(CF_AP_HYclass2, CF_AP_HYclass3)$p.value

```

```{r CF_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```



### Mediolateral

```{r Mann-Whitney-U-test_CF_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_ML_HYclass2 <- features$CF_ML[features$HYclass == group_A]
CF_ML_HYclass3 <- features$CF_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_ML <- wilcox.test(CF_ML_HYclass2, CF_ML_HYclass3)$p.value

```

```{r CF_ML_plot_ML, echo=FALSE}

boxplot(CF_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CF_ML",
        #ylim = c(0,1.6),
        main = "Centroidal Frequency - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CF_ML_plot_ML_no_outlier, echo=FALSE}

boxplot(CF_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CF_ML",
        outline = FALSE,
        main = "Centroidal Frequency - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CF_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_CF_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_VT_HYclass2 <- features$CF_VT[features$HYclass == group_A]
CF_VT_HYclass3 <- features$CF_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_VT <- wilcox.test(CF_VT_HYclass2, CF_VT_HYclass3)$p.value

```

```{r CF_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mVT them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch (AV)

```{r Mann-Whitney-U-test_CF_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_Pitch_HYclass2 <- features$CF_Pitch[features$HYclass == group_A]
CF_Pitch_HYclass3 <- features$CF_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_Pitch <- wilcox.test(CF_Pitch_HYclass2, CF_Pitch_HYclass3)$p.value

```

```{r CF_plot_Pitch, echo=FALSE}

boxplot(CF_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CF_Pitch",
        main = "Centroidal Frequency - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CF_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_CF_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_Roll_HYclass2 <- features$CF_Roll[features$HYclass == group_A]
CF_Roll_HYclass3 <- features$CF_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_Roll <- wilcox.test(CF_Roll_HYclass2, CF_Roll_HYclass3)$p.value

```

```{r CF_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_CF_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_Yaw_HYclass2 <- features$CF_Yaw[features$HYclass == group_A]
CF_Yaw_HYclass3 <- features$CF_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_Yaw <- wilcox.test(CF_Yaw_HYclass2, CF_Yaw_HYclass3)$p.value

```

```{r CF_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Centroidal Frequency 0.9 - 15 Hz

```{r CF_0.9_15, echo = FALSE}
features$CF_0.9_15_AP <- NA
features$CF_0.9_15_ML <- NA
features$CF_0.9_15_VT <- NA
features$CF_0.9_15_Pitch <- NA
features$CF_0.9_15_Roll <- NA
features$CF_0.9_15_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2
  
  # restrict range to 0 to 16 Hz
  range_indices_ap_1 <- which(freq1 >= 0.9 & freq1 <= 15)
  range_indices_ap_2 <- which(freq2 >= 0.9 & freq2 <= 15)
  range_indices_ap_3 <- which(freq3 >= 0.9 & freq3 <= 15)
  
  range_indices_ml_1 <- which(freq1 >= 0.9 & freq1 <= 15)
  range_indices_ml_2 <- which(freq2 >= 0.9 & freq2 <= 15)
  range_indices_ml_3 <- which(freq3 >= 0.9 & freq3 <= 15)
  
  range_indices_VT_1 <- which(freq1 >= 0.9 & freq1 <= 15)
  range_indices_VT_2 <- which(freq2 >= 0.9 & freq2 <= 15)
  range_indices_VT_3 <- which(freq3 >= 0.9 & freq3 <= 15)
  
  range_indices_pi_1 <- which(freq1 >= 0.9 & freq1 <= 15)
  range_indices_pi_2 <- which(freq2 >= 0.9 & freq2 <= 15)
  range_indices_pi_3 <- which(freq3 >= 0.9 & freq3 <= 15)
  
  range_indices_Roll_1 <- which(freq1 >= 0.9 & freq1 <= 15)
  range_indices_Roll_2 <- which(freq2 >= 0.9 & freq2 <= 15)
  range_indices_Roll_3 <- which(freq3 >= 0.9 & freq3 <= 15)
  
  range_indices_Yaw_1 <- which(freq1 >= 0.9 & freq1 <= 15)
  range_indices_Yaw_2 <- which(freq2 >= 0.9 & freq2 <= 15)
  range_indices_Yaw_3 <- which(freq3 >= 0.9 & freq3 <= 15)
  
  # get the centroidal frequency in this range
  CF_AP_1 <- sum(freq1[range_indices_ap_1] * psd_ap_1[range_indices_ap_1]) /
    sum(psd_ap_1[range_indices_ap_1])
  CF_AP_2 <- sum(freq2[range_indices_ap_2] * psd_ap_2[range_indices_ap_2]) /
    sum(psd_ap_2[range_indices_ap_2])
  CF_AP_3 <- sum(freq3[range_indices_ap_3] * psd_ap_3[range_indices_ap_3]) /
    sum(psd_ap_3[range_indices_ap_3])
  
  CF_ML_1 <- sum(freq1[range_indices_ml_1] * psd_ml_1[range_indices_ml_1]) /
    sum(psd_ml_1[range_indices_ml_1])
  CF_ML_2 <- sum(freq2[range_indices_ml_2] * psd_ml_2[range_indices_ml_2]) /
    sum(psd_ml_2[range_indices_ml_2])
  CF_ML_3 <- sum(freq3[range_indices_ml_3] * psd_ml_3[range_indices_ml_3]) /
    sum(psd_ml_3[range_indices_ml_3])
  
  CF_VT_1 <- sum(freq1[range_indices_VT_1] * psd_VT_1[range_indices_VT_1]) /
    sum(psd_VT_1[range_indices_VT_1])
  CF_VT_2 <- sum(freq2[range_indices_VT_2] * psd_VT_2[range_indices_VT_2]) /
    sum(psd_VT_2[range_indices_VT_2])
  CF_VT_3 <- sum(freq3[range_indices_VT_3] * psd_VT_3[range_indices_VT_3]) /
    sum(psd_VT_3[range_indices_VT_3])
  
  CF_Pitch_1 <- sum(freq1[range_indices_pi_1] * psd_pi_1[range_indices_pi_1]) /
    sum(psd_pi_1[range_indices_pi_1])
  CF_Pitch_2 <- sum(freq2[range_indices_pi_2] * psd_pi_2[range_indices_pi_2]) /
    sum(psd_pi_2[range_indices_pi_2])
  CF_Pitch_3 <- sum(freq3[range_indices_pi_3] * psd_pi_3[range_indices_pi_3]) /
    sum(psd_pi_3[range_indices_pi_3])
  
  CF_Roll_1 <- sum(freq1[range_indices_Roll_1] * psd_Roll_1[range_indices_Roll_1]) /
    sum(psd_Roll_1[range_indices_Roll_1])
  CF_Roll_2 <- sum(freq2[range_indices_Roll_2] * psd_Roll_2[range_indices_Roll_2]) /
    sum(psd_Roll_2[range_indices_Roll_2])
  CF_Roll_3 <- sum(freq3[range_indices_Roll_3] * psd_Roll_3[range_indices_Roll_3]) /
    sum(psd_Roll_3[range_indices_Roll_3])
  
  CF_Yaw_1 <- sum(freq1[range_indices_Yaw_1] * psd_Yaw_1[range_indices_Yaw_1]) /
    sum(psd_Yaw_1[range_indices_Yaw_1])
  CF_Yaw_2 <- sum(freq2[range_indices_Yaw_2] * psd_Yaw_2[range_indices_Yaw_2]) /
    sum(psd_Yaw_2[range_indices_Yaw_2])
  CF_Yaw_3 <- sum(freq3[range_indices_Yaw_3] * psd_Yaw_3[range_indices_Yaw_3]) /
    sum(psd_Yaw_3[range_indices_Yaw_3])
  
  # average the segments for each
  features$CF_0.9_15_AP[i] <- mean(c(CF_AP_1, CF_AP_2, CF_AP_3))
  features$CF_0.9_15_ML[i] <- mean(c(CF_ML_1, CF_ML_2, CF_ML_3))
  features$CF_0.9_15_VT[i] <- mean(c(CF_VT_1, CF_VT_2, CF_VT_3))
  features$CF_0.9_15_Pitch[i] <- mean(c(CF_Pitch_1, CF_Pitch_2, CF_Pitch_3))
  features$CF_0.9_15_Roll[i] <- mean(c(CF_Roll_1, CF_Roll_2, CF_Roll_3))
  features$CF_0.9_15_Yaw[i] <- mean(c(CF_Yaw_1, CF_Yaw_2, CF_Yaw_3))

  
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_CF_0.9_15_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_0.9_15_AP_HYclass2 <- features$CF_0.9_15_AP[features$HYclass == group_A]
CF_0.9_15_AP_HYclass3 <- features$CF_0.9_15_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_0.9_15_AP <- 
  wilcox.test(CF_0.9_15_AP_HYclass2, CF_0.9_15_AP_HYclass3)$p.value

```


```{r CF_0.9_15_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_0.9_15_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_0.9_15_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_0.9_15_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_0.9_15_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_CF_0.9_15_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_0.9_15_ML_HYclass2 <- features$CF_0.9_15_ML[features$HYclass == group_A]
CF_0.9_15_ML_HYclass3 <- features$CF_0.9_15_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_0.9_15_ML <- 
  wilcox.test(CF_0.9_15_ML_HYclass2, CF_0.9_15_ML_HYclass3)$p.value

```

```{r CF_0.9_15_ML_plot_ML, echo=FALSE}

boxplot(CF_0.9_15_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CF_0.9_15_ML",
        #ylim = c(0,1.6),
        main = "Centroidal Frequency Power 0 - 16 Hz - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CF_0.9_15_ML_plot_ML_no_outlier, echo=FALSE}

boxplot(CF_0.9_15_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CF_0.9_15_ML",
        outline = FALSE,
        main = "Centroidal Frequency Power 0 - 16 Hz - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CF_0.9_15_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_0.9_15_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_0.9_15_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_0.9_15_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_0.9_15_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_CF_0.9_15_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_0.9_15_VT_HYclass2 <- features$CF_0.9_15_VT[features$HYclass == group_A]
CF_0.9_15_VT_HYclass3 <- features$CF_0.9_15_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_0.9_15_VT <- 
  wilcox.test(CF_0.9_15_VT_HYclass2, CF_0.9_15_VT_HYclass3)$p.value

```


```{r CF_0.9_15_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_0.9_15_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_0.9_15_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_0.9_15_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_0.9_15_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch (AV)

```{r Mann-Whitney-U-test_CF_0.9_15_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_0.9_15_Pitch_HYclass2 <- features$CF_0.9_15_Pitch[features$HYclass == group_A]
CF_0.9_15_Pitch_HYclass3 <- features$CF_0.9_15_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_0.9_15_Pitch <- 
  wilcox.test(CF_0.9_15_Pitch_HYclass2, CF_0.9_15_Pitch_HYclass3)$p.value

```

```{r CF_0.9_15_plot_Pitch, echo=FALSE}

boxplot(CF_0.9_15_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CF_0.9_15_Pitch",
        main = "Centroidal Frequency Power 0 - 16 Hz - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CF_0.9_15_plot_Pitch_no_outlier, echo=FALSE}

boxplot(CF_0.9_15_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "M_0_16_Pitch",
        outline = FALSE,
        main = "Centroidal Frequency Power 0 - 16 Hz - Pitch (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CF_0.9_15_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_0.9_15_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_0.9_15_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_0.9_15_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_0.9_15_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_CF_0.9_15_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_0.9_15_Roll_HYclass2 <- features$CF_0.9_15_Roll[features$HYclass == group_A]
CF_0.9_15_Roll_HYclass3 <- features$CF_0.9_15_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_0.9_15_Roll <- 
  wilcox.test(CF_0.9_15_Roll_HYclass2, CF_0.9_15_Roll_HYclass3)$p.value

```


```{r CF_0.9_15_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_0.9_15_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mRoll them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_0.9_15_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_0.9_15_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_0.9_15_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_CF_0.9_15_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_0.9_15_Yaw_HYclass2 <- features$CF_0.9_15_Yaw[features$HYclass == group_A]
CF_0.9_15_Yaw_HYclass3 <- features$CF_0.9_15_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_0.9_15_Yaw <- 
  wilcox.test(CF_0.9_15_Yaw_HYclass2, CF_0.9_15_Yaw_HYclass3)$p.value

```


```{r CF_0.9_15_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_0.9_15_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_0.9_15_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_0.9_15_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_0.9_15_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Centroidal Frequency Variance

```{r CF_Variance, echo = FALSE}
features$CF_var_AP <- NA
features$CF_var_ML <- NA
features$CF_var_AP <- NA
features$CF_var_Pitch <- NA
features$CF_var_Roll <- NA
features$CF_var_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2
  
  # first calculate centroidal frequency:
  CF_AP_1 <- sum(freq1 * psd_ap_1) / sum(psd_ap_1)
  CF_AP_2 <- sum(freq2 * psd_ap_2) / sum(psd_ap_2)
  CF_AP_3 <- sum(freq3 * psd_ap_3) / sum(psd_ap_3)
  
  CF_ML_1 <- sum(freq1 * psd_ml_1) / sum(psd_ml_1)
  CF_ML_2 <- sum(freq2 * psd_ml_2) / sum(psd_ml_2)
  CF_ML_3 <- sum(freq3 * psd_ml_3) / sum(psd_ml_3)
  
  CF_VT_1 <- sum(freq1 * psd_VT_1) / sum(psd_VT_1)
  CF_VT_2 <- sum(freq2 * psd_VT_2) / sum(psd_VT_2)
  CF_VT_3 <- sum(freq3 * psd_VT_3) / sum(psd_VT_3)
  
  CF_Pitch_1 <- sum(freq1 * psd_pi_1) / sum(psd_pi_1)
  CF_Pitch_2 <- sum(freq2 * psd_pi_2) / sum(psd_pi_2)
  CF_Pitch_3 <- sum(freq3 * psd_pi_3) / sum(psd_pi_3)
  
  CF_Roll_1 <- sum(freq1 * psd_Roll_1) / sum(psd_Roll_1)
  CF_Roll_2 <- sum(freq2 * psd_Roll_2) / sum(psd_Roll_2)
  CF_Roll_3 <- sum(freq3 * psd_Roll_3) / sum(psd_Roll_3)
  
  CF_Yaw_1 <- sum(freq1 * psd_Yaw_1) / sum(psd_Yaw_1)
  CF_Yaw_2 <- sum(freq2 * psd_Yaw_2) / sum(psd_Yaw_2)
  CF_Yaw_3 <- sum(freq3 * psd_Yaw_3) / sum(psd_Yaw_3)
  
  # average the segments for each
  features$CF_var_AP[i] <- var(c(CF_AP_1, CF_AP_2, CF_AP_3))
  features$CF_var_ML[i] <- var(c(CF_ML_1, CF_ML_2, CF_ML_3))
  features$CF_var_VT[i] <- var(c(CF_VT_1, CF_VT_2, CF_VT_3))
  features$CF_var_Pitch[i] <- var(c(CF_Pitch_1, CF_Pitch_2, CF_Pitch_3))
  features$CF_var_Roll[i] <- var(c(CF_Roll_1, CF_Roll_2, CF_Roll_3))
  features$CF_var_Yaw[i] <- var(c(CF_Yaw_1, CF_Yaw_2, CF_Yaw_3))

  
}


```


### Anteroposterior

```{r Mann-Whitney-U-test_CF_var_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_var_AP_HYclass2 <- features$CF_var_AP[features$HYclass == group_A]
CF_var_AP_HYclass3 <- features$CF_var_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_var_AP <- wilcox.test(CF_var_AP_HYclass2, CF_var_AP_HYclass3)$p.value

```


```{r CF_var_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_var_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_var_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_var_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_var_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_CF_var_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_var_ML_HYclass2 <- features$CF_var_ML[features$HYclass == group_A]
CF_var_ML_HYclass3 <- features$CF_var_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_var_ML <- wilcox.test(CF_var_ML_HYclass2, CF_var_ML_HYclass3)$p.value

```

```{r CF_var_ML_plot_ML, echo=FALSE}

boxplot(CF_var_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CF_var_ML",
        #ylim = c(0,1.6),
        main = "Centroidal Frequency Variance - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CF_var_ML_plot_ML_no_outlier, echo=FALSE}

boxplot(CF_var_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CF_var_ML",
        outline = FALSE,
        main = "Centroidal Frequency Variance - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CF_var_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_var_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_var_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_var_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_var_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_CF_var_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_var_VT_HYclass2 <- features$CF_var_VT[features$HYclass == group_A]
CF_var_VT_HYclass3 <- features$CF_var_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_var_VT <- wilcox.test(CF_var_VT_HYclass2, CF_var_VT_HYclass3)$p.value

```


```{r CF_var_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_var_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_var_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_var_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_var_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch (AV)

```{r Mann-Whitney-U-test_CF_var_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_var_Pitch_HYclass2 <- features$CF_var_Pitch[features$HYclass == group_A]
CF_var_Pitch_HYclass3 <- features$CF_var_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_var_Pitch <- 
  wilcox.test(CF_var_Pitch_HYclass2, CF_var_Pitch_HYclass3)$p.value

```

```{r CF_var_plot_Pitch, echo=FALSE}

boxplot(CF_var_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CF_var_Pitch",
        main = "Centroidal Frequency Variance - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r CF_var_plot_Pitch_no_outlier, echo=FALSE}

boxplot(CF_var_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CF_var_Pitch",
        outline = FALSE,
        main = "Centroidal Frequency Variance - Pitch (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r CF_var_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_var_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_var_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_var_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_var_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_CF_var_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_var_Roll_HYclass2 <- features$CF_var_Roll[features$HYclass == group_A]
CF_var_Roll_HYclass3 <- features$CF_var_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_var_Roll <- wilcox.test(CF_var_Roll_HYclass2, CF_var_Roll_HYclass3)$p.value

```


```{r CF_var_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_var_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_var_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_var_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_var_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_CF_var_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
CF_var_Yaw_HYclass2 <- features$CF_var_Yaw[features$HYclass == group_A]
CF_var_Yaw_HYclass3 <- features$CF_var_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CF_var_Yaw <- wilcox.test(CF_var_Yaw_HYclass2, CF_var_Yaw_HYclass3)$p.value

```


```{r CF_var_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CF_var_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CF_var_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CF_var_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CF_var_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Total Power

```{r Total_power_PR, echo = FALSE}
features$P_Tot_AP <- NA
features$P_Tot_ML <- NA
features$P_Tot_VT <- NA
features$P_Tot_Pitch <- NA
features$P_Tot_Roll <- NA
features$P_Tot_Yaw <- NA

# function for power band sum for future feature productions
  sum_power_in_band <- function(psd, freq, low_freq, high_freq) {
    band_indices <- which(freq >= low_freq & freq <= high_freq)
    sum(psd[band_indices])
  }

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate total power
  P_Tot_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 0, 25)
  P_Tot_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 0, 25)
  P_Tot_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 0, 25)
  
  P_Tot_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 0, 25) 
  P_Tot_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 0, 25)
  P_Tot_ML_3 <-  sum_power_in_band(psd_ml_3, freq3, 0, 25)
  
  P_Tot_VT_1 <- sum_power_in_band(psd_VT_1, freq1, 0, 25)
  P_Tot_VT_2 <- sum_power_in_band(psd_VT_2, freq2, 0, 25)
  P_Tot_VT_3 <- sum_power_in_band(psd_VT_3, freq3, 0, 25)
  
  P_Tot_Pitch_1 <- sum_power_in_band(psd_pi_1, freq1, 0, 25)
  P_Tot_Pitch_2 <- sum_power_in_band(psd_pi_2, freq2, 0, 25)
  P_Tot_Pitch_3 <-  sum_power_in_band(psd_pi_3, freq3, 0, 25)
  
  P_Tot_Roll_1 <- sum_power_in_band(psd_Roll_1, freq1, 0, 25)
  P_Tot_Roll_2 <- sum_power_in_band(psd_Roll_2, freq2, 0, 25)
  P_Tot_Roll_3 <- sum_power_in_band(psd_Roll_3, freq3, 0, 25)
  
  P_Tot_Yaw_1 <- sum_power_in_band(psd_Yaw_1, freq1, 0, 25)
  P_Tot_Yaw_2 <- sum_power_in_band(psd_Yaw_2, freq2, 0, 25)
  P_Tot_Yaw_3 <- sum_power_in_band(psd_Yaw_3, freq3, 0, 25)

  # Average for the three pulls
  features$P_Tot_AP[i] <- mean(c(P_Tot_AP_1, P_Tot_AP_2, P_Tot_AP_3))
  features$P_Tot_ML[i] <- mean(c(P_Tot_ML_1, P_Tot_ML_2, P_Tot_ML_3))
  features$P_Tot_VT[i] <- mean(c(P_Tot_VT_1, P_Tot_VT_2, P_Tot_VT_3))
  features$P_Tot_Pitch[i] <- mean(c(P_Tot_Pitch_1, P_Tot_Pitch_2, P_Tot_Pitch_3))
  features$P_Tot_Roll[i] <- mean(c(P_Tot_Roll_1, P_Tot_Roll_2, P_Tot_Roll_3))
  features$P_Tot_Yaw[i] <- mean(c(P_Tot_Yaw_1, P_Tot_Yaw_2, P_Tot_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_P_Tot, echo=FALSE}

# Extract values for HYclass 2 and 3
P_Tot_AP_HYclass2 <- features$P_Tot_AP[features$HYclass == group_A]
P_Tot_AP_HYclass3 <- features$P_Tot_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$P_Tot_AP <- wilcox.test(P_Tot_AP_HYclass2, P_Tot_AP_HYclass3)$p.value

```

```{r P_Tot_AP_plot, echo=FALSE}

boxplot(P_Tot_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "P_Tot_AP",
        main = "Total Power - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r P_Tot_AP_plot_no_outlier, echo=FALSE}

boxplot(P_Tot_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "P_Tot_AP",
        outline = FALSE,
        main = "Total Power - AP (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r P_Tot_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$P_Tot_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$P_Tot_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$P_Tot_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$P_Tot_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_P_Tot_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
P_Tot_ML_HYclass2 <- features$P_Tot_ML[features$HYclass == group_A]
P_Tot_ML_HYclass3 <- features$P_Tot_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$P_Tot_ML <- wilcox.test(P_Tot_ML_HYclass2, P_Tot_ML_HYclass3)$p.value

```


```{r P_Tot_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$P_Tot_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$P_Tot_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$P_Tot_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$P_Tot_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_P_Tot_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
P_Tot_VT_HYclass2 <- features$P_Tot_VT[features$HYclass == group_A]
P_Tot_VT_HYclass3 <- features$P_Tot_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$P_Tot_VT <- wilcox.test(P_Tot_VT_HYclass2, P_Tot_VT_HYclass3)$p.value

```


```{r P_Tot_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$P_Tot_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$P_Tot_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$P_Tot_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$P_Tot_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch (AV)

```{r Mann-Whitney-U-test_P_Tot_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
P_Tot_Pitch_HYclass2 <- features$P_Tot_Pitch[features$HYclass == 1]
P_Tot_Pitch_HYclass3 <- features$P_Tot_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$P_Tot_Pitch <- 
  wilcox.test(P_Tot_Pitch_HYclass2, P_Tot_Pitch_HYclass3)$p.value

```

```{r P_Tot_plot_Pitch, echo=FALSE}

boxplot(P_Tot_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "P_Tot_Pitch",
        main = "Total Power - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r P_Tot_plot_Pitch_no_outlier, echo=FALSE}

boxplot(P_Tot_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "P_Tot_Pitch",
        outline = FALSE,
        main = "Total Power - Pitch (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r P_Tot_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$P_Tot_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$P_Tot_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$P_Tot_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$P_Tot_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Roll

```{r Mann-Whitney-U-test_P_Tot_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
P_Tot_Roll_HYclass2 <- features$P_Tot_Roll[features$HYclass == group_A]
P_Tot_Roll_HYclass3 <- features$P_Tot_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$P_Tot_Roll <- wilcox.test(P_Tot_Roll_HYclass2, P_Tot_Roll_HYclass3)$p.value

```


```{r P_Tot_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$P_Tot_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$P_Tot_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$P_Tot_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$P_Tot_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_P_Tot_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
P_Tot_Yaw_HYclass2 <- features$P_Tot_Yaw[features$HYclass == group_A]
P_Tot_Yaw_HYclass3 <- features$P_Tot_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$P_Tot_Yaw <- wilcox.test(P_Tot_Yaw_HYclass2, P_Tot_Yaw_HYclass3)$p.value

```


```{r P_Tot_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$P_Tot_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$P_Tot_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$P_Tot_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$P_Tot_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Power 3 - 8 Hz

```{r power_3_8, echo = FALSE}
features$Pow_3_8_AP <- NA
features$Pow_3_8_ML <- NA
features$Pow_3_8_VT <- NA
features$Pow_3_8_Pitch <- NA
features$Pow_3_8_Roll <- NA
features$Pow_3_8_Yaw <- NA

# function for power band sum for future feature productions
  sum_power_in_band <- function(psd, freq, low_freq, high_freq) {
    band_indices <- which(freq >= low_freq & freq <= high_freq)
    sum(psd[band_indices])
  }

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate power between 3 and 8 Hz
  Pow_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 3, 8)
  Pow_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 3, 8)
  Pow_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 3, 8)
  
  Pow_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 3, 8)
  Pow_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 3, 8)
  Pow_ML_3 <- sum_power_in_band(psd_ml_3, freq3, 3, 8)
  
  Pow_VT_1 <- sum_power_in_band(psd_VT_1, freq1, 3, 8)
  Pow_VT_2 <- sum_power_in_band(psd_VT_2, freq2, 3, 8)
  Pow_VT_3 <- sum_power_in_band(psd_VT_3, freq3, 3, 8)
  
  Pow_Pitch_1 <- sum_power_in_band(psd_pi_1, freq1, 3, 8)
  Pow_Pitch_2 <- sum_power_in_band(psd_pi_2, freq2, 3, 8)
  Pow_Pitch_3 <- sum_power_in_band(psd_pi_3, freq3, 3, 8)
  
  Pow_Roll_1 <- sum_power_in_band(psd_Roll_1, freq1, 3, 8)
  Pow_Roll_2 <- sum_power_in_band(psd_Roll_2, freq2, 3, 8)
  Pow_Roll_3 <- sum_power_in_band(psd_Roll_3, freq3, 3, 8)
  
  Pow_Yaw_1 <- sum_power_in_band(psd_Yaw_1, freq1, 3, 8)
  Pow_Yaw_2 <- sum_power_in_band(psd_Yaw_2, freq2, 3, 8)
  Pow_Yaw_3 <- sum_power_in_band(psd_Yaw_3, freq3, 3, 8)

  # Average for the three pulls
  features$Pow_3_8_AP[i] <- mean(c(Pow_AP_1, Pow_AP_2, Pow_AP_3))
  features$Pow_3_8_ML[i] <- mean(c(Pow_ML_1, Pow_ML_2, Pow_ML_3))
  features$Pow_3_8_VT[i] <- mean(c(Pow_VT_1, Pow_VT_2, Pow_VT_3))
  features$Pow_3_8_Pitch[i] <- mean(c(Pow_Pitch_1, Pow_Pitch_2, Pow_Pitch_3))
  features$Pow_3_8_Roll[i] <- mean(c(Pow_Roll_1, Pow_Roll_2, Pow_Roll_3))
  features$Pow_3_8_Yaw[i] <- mean(c(Pow_Yaw_1, Pow_Yaw_2, Pow_Yaw_3))

}


```

### Anteroposterior

```{r Mann-Whitney-U-test_Pow_3_8, echo=FALSE}

# Extract values for HYclass 2 and 3
Pow_3_8_AP_HYclass2 <- features$Pow_3_8_AP[features$HYclass == group_A]
Pow_3_8_AP_HYclass3 <- features$Pow_3_8_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Pow_3_8_AP <- wilcox.test(Pow_3_8_AP_HYclass2, Pow_3_8_AP_HYclass3)$p.value

```

```{r Pow_3_8_AP_plot, echo=FALSE}

boxplot(Pow_3_8_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "Pow_3_8_AP",
        #ylim = c(0,1.6),
        main = "Power in 3 to 8 Hz Band - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r Pow_3_8_AP_plot2, echo=FALSE}

boxplot(Pow_3_8_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        outline = FALSE,
        ylab = "Pow_3_8_AP",
        #ylim = c(0,1.6),
        main = "Power in 3 to 8 Hz Band - AP (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r Pow_3_8_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Pow_3_8_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Pow_3_8_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Pow_3_8_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Pow_3_8_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_Pow_3_8_ML_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
Pow_3_8_ML_HYclass2 <- features$Pow_3_8_ML[features$HYclass == group_A]
Pow_3_8_ML_HYclass3 <- features$Pow_3_8_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Pow_3_8_ML <- wilcox.test(Pow_3_8_ML_HYclass2, Pow_3_8_ML_HYclass3)$p.value

```


```{r Pow_3_8_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Pow_3_8_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Pow_3_8_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Pow_3_8_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Pow_3_8_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_Pow_3_8_VT_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
Pow_3_8_VT_HYclass2 <- features$Pow_3_8_VT[features$HYclass == group_A]
Pow_3_8_VT_HYclass3 <- features$Pow_3_8_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Pow_3_8_VT <- wilcox.test(Pow_3_8_VT_HYclass2, Pow_3_8_VT_HYclass3)$p.value

```


```{r Pow_3_8_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Pow_3_8_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Pow_3_8_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Pow_3_8_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Pow_3_8_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_Pow_3_8_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
Pow_3_8_Pitch_HYclass2 <- features$Pow_3_8_Pitch[features$HYclass == group_A]
Pow_3_8_Pitch_HYclass3 <- features$Pow_3_8_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Pow_3_8_Pitch <- wilcox.test(Pow_3_8_Pitch_HYclass2, Pow_3_8_Pitch_HYclass3)$p.value

```


```{r Pow_3_8_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Pow_3_8_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Pow_3_8_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Pow_3_8_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Pow_3_8_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_Pow_3_8_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
Pow_3_8_Roll_HYclass2 <- features$Pow_3_8_Roll[features$HYclass == group_A]
Pow_3_8_Roll_HYclass3 <- features$Pow_3_8_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Pow_3_8_Roll <- wilcox.test(Pow_3_8_Roll_HYclass2, Pow_3_8_Roll_HYclass3)$p.value

```


```{r Pow_3_8_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Pow_3_8_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Pow_3_8_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Pow_3_8_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Pow_3_8_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_Pow_3_8_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
Pow_3_8_Yaw_HYclass2 <- features$Pow_3_8_Yaw[features$HYclass == group_A]
Pow_3_8_Yaw_HYclass3 <- features$Pow_3_8_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Pow_3_8_Yaw <- wilcox.test(Pow_3_8_Yaw_HYclass2, Pow_3_8_Yaw_HYclass3)$p.value

```


```{r Pow_3_8_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Pow_3_8_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Pow_3_8_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Pow_3_8_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Pow_3_8_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Power 4 - 5.5 Hz

```{r power_4_5.5, echo = FALSE}
features$Pow_4_5.5_AP <- NA
features$Pow_4_5.5_ML <- NA
features$Pow_4_5.5_VT <- NA
features$Pow_4_5.5_Pitch <- NA
features$Pow_4_5.5_Roll <- NA
features$Pow_4_5.5_Yaw <- NA

# function for power band sum for future feature productions
  sum_power_in_band <- function(psd, freq, low_freq, high_freq) {
    band_indices <- which(freq >= low_freq & freq <= high_freq)
    sum(psd[band_indices])
  }

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate power between 4 and 5.5 Hz
  Pow_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 4, 5.5)
  Pow_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 4, 5.5)
  Pow_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 4, 5.5)
  
  Pow_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 4, 5.5)
  Pow_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 4, 5.5)
  Pow_ML_3 <- sum_power_in_band(psd_ml_3, freq3, 4, 5.5)
  
  Pow_VT_1 <- sum_power_in_band(psd_VT_1, freq1, 4, 5.5)
  Pow_VT_2 <- sum_power_in_band(psd_VT_2, freq2, 4, 5.5)
  Pow_VT_3 <- sum_power_in_band(psd_VT_3, freq3, 4, 5.5)
  
  Pow_Pitch_1 <- sum_power_in_band(psd_pi_1, freq1, 4, 5.5)
  Pow_Pitch_2 <- sum_power_in_band(psd_pi_2, freq2, 4, 5.5)
  Pow_Pitch_3 <- sum_power_in_band(psd_pi_3, freq3, 4, 5.5)
  
  Pow_Roll_1 <- sum_power_in_band(psd_Roll_1, freq1, 4, 5.5)
  Pow_Roll_2 <- sum_power_in_band(psd_Roll_2, freq2, 4, 5.5)
  Pow_Roll_3 <- sum_power_in_band(psd_Roll_3, freq3, 4, 5.5)
  
  Pow_Yaw_1 <- sum_power_in_band(psd_Yaw_1, freq1, 4, 5.5)
  Pow_Yaw_2 <- sum_power_in_band(psd_Yaw_2, freq2, 4, 5.5)
  Pow_Yaw_3 <- sum_power_in_band(psd_Yaw_3, freq3, 4, 5.5)

  # Average for the three pulls
  features$Pow_4_5.5_AP[i] <- mean(c(Pow_AP_1, Pow_AP_2, Pow_AP_3))
  features$Pow_4_5.5_ML[i] <- mean(c(Pow_ML_1, Pow_ML_2, Pow_ML_3))
  features$Pow_4_5.5_VT[i] <- mean(c(Pow_VT_1, Pow_VT_2, Pow_VT_3))
  features$Pow_4_5.5_Pitch[i] <- mean(c(Pow_Pitch_1, Pow_Pitch_2, Pow_Pitch_3))
  features$Pow_4_5.5_Roll[i] <- mean(c(Pow_Roll_1, Pow_Roll_2, Pow_Roll_3))
  features$Pow_4_5.5_Yaw[i] <- mean(c(Pow_Yaw_1, Pow_Yaw_2, Pow_Yaw_3))

}


```

### Anteroposterior

```{r Mann-Whitney-U-test_Pow_4_5.5, echo=FALSE}

# Extract values for HYclass 2 and 3
Pow_4_5.5_AP_HYclass2 <- features$Pow_4_5.5_AP[features$HYclass == group_A]
Pow_4_5.5_AP_HYclass3 <- features$Pow_4_5.5_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Pow_4_5.5_AP <- wilcox.test(Pow_4_5.5_AP_HYclass2, Pow_4_5.5_AP_HYclass3)$p.value

```

```{r Pow_4_5.5_AP_plot, echo=FALSE}

boxplot(Pow_4_5.5_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "Pow_4_5.5_AP",
        #ylim = c(0,1.6),
        main = "Power in 3 to 8 Hz Band - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r Pow_4_5.5_AP_plot2, echo=FALSE}

boxplot(Pow_4_5.5_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        outline = FALSE,
        ylab = "Pow_4_5.5_AP",
        #ylim = c(0,1.6),
        main = "Power in 3 to 8 Hz Band - AP (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r Pow_4_5.5_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Pow_4_5.5_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Pow_4_5.5_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Pow_4_5.5_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Pow_4_5.5_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_Pow_4_5.5_ML_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
Pow_4_5.5_ML_HYclass2 <- features$Pow_4_5.5_ML[features$HYclass == group_A]
Pow_4_5.5_ML_HYclass3 <- features$Pow_4_5.5_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Pow_4_5.5_ML <- wilcox.test(Pow_4_5.5_ML_HYclass2, Pow_4_5.5_ML_HYclass3)$p.value

```


```{r Pow_4_5.5_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Pow_4_5.5_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Pow_4_5.5_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Pow_4_5.5_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Pow_4_5.5_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_Pow_4_5.5_VT_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
Pow_4_5.5_VT_HYclass2 <- features$Pow_4_5.5_VT[features$HYclass == group_A]
Pow_4_5.5_VT_HYclass3 <- features$Pow_4_5.5_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Pow_4_5.5_VT <- wilcox.test(Pow_4_5.5_VT_HYclass2, Pow_4_5.5_VT_HYclass3)$p.value

```


```{r Pow_4_5.5_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Pow_4_5.5_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Pow_4_5.5_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Pow_4_5.5_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Pow_4_5.5_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_Pow_4_5.5_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
Pow_4_5.5_Pitch_HYclass2 <- features$Pow_4_5.5_Pitch[features$HYclass == group_A]
Pow_4_5.5_Pitch_HYclass3 <- features$Pow_4_5.5_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Pow_4_5.5_Pitch <- wilcox.test(Pow_4_5.5_Pitch_HYclass2, Pow_4_5.5_Pitch_HYclass3)$p.value

```


```{r Pow_4_5.5_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Pow_4_5.5_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Pow_4_5.5_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Pow_4_5.5_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Pow_4_5.5_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_Pow_4_5.5_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
Pow_4_5.5_Roll_HYclass2 <- features$Pow_4_5.5_Roll[features$HYclass == group_A]
Pow_4_5.5_Roll_HYclass3 <- features$Pow_4_5.5_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Pow_4_5.5_Roll <- wilcox.test(Pow_4_5.5_Roll_HYclass2, Pow_4_5.5_Roll_HYclass3)$p.value

```


```{r Pow_4_5.5_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Pow_4_5.5_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Pow_4_5.5_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Pow_4_5.5_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Pow_4_5.5_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_Pow_4_5.5_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
Pow_4_5.5_Yaw_HYclass2 <- features$Pow_4_5.5_Yaw[features$HYclass == group_A]
Pow_4_5.5_Yaw_HYclass3 <- features$Pow_4_5.5_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$Pow_4_5.5_Yaw <- wilcox.test(Pow_4_5.5_Yaw_HYclass2, Pow_4_5.5_Yaw_HYclass3)$p.value

```


```{r Pow_4_5.5_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$Pow_4_5.5_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$Pow_4_5.5_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$Pow_4_5.5_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$Pow_4_5.5_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Power in Low Frequency Band

```{r Power_LF, echo = FALSE}
features$PLF_AP <- NA
features$PLF_ML <- NA
features$PLF_VT <- NA
features$PLF_Pitch <- NA
features$PLF_Roll <- NA
features$PLF_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # first calculate centroidal frequency:
  
  CF_AP_1 <- sum(freq1 * psd_ap_1) / sum(psd_ap_1)
  CF_AP_2 <- sum(freq2 * psd_ap_2) / sum(psd_ap_2)
  CF_AP_3 <- sum(freq3 * psd_ap_3) / sum(psd_ap_3)
  
  CF_ML_1 <- sum(freq1 * psd_ml_1) / sum(psd_ml_1)
  CF_ML_2 <- sum(freq2 * psd_ml_2) / sum(psd_ml_2)
  CF_ML_3 <- sum(freq3 * psd_ml_3) / sum(psd_ml_3)
  
  CF_VT_1 <- sum(freq1 * psd_VT_1) / sum(psd_VT_1)
  CF_VT_2 <- sum(freq2 * psd_VT_2) / sum(psd_VT_2)
  CF_VT_3 <- sum(freq3 * psd_VT_3) / sum(psd_VT_3)
  
  CF_Pitch_1 <- sum(freq1 * psd_pi_1) / sum(psd_pi_1)
  CF_Pitch_2 <- sum(freq2 * psd_pi_2) / sum(psd_pi_2)
  CF_Pitch_3 <- sum(freq3 * psd_pi_3) / sum(psd_pi_3)
  
  CF_Roll_1 <- sum(freq1 * psd_Roll_1) / sum(psd_Roll_1)
  CF_Roll_2 <- sum(freq2 * psd_Roll_2) / sum(psd_Roll_2)
  CF_Roll_3 <- sum(freq3 * psd_Roll_3) / sum(psd_Roll_3)
  
  CF_Yaw_1 <- sum(freq1 * psd_Yaw_1) / sum(psd_Yaw_1)
  CF_Yaw_2 <- sum(freq2 * psd_Yaw_2) / sum(psd_Yaw_2)
  CF_Yaw_3 <- sum(freq3 * psd_Yaw_3) / sum(psd_Yaw_3)
  
  # then calc total power from 0 to CF - 3 Hz.
  
  PLF_AP_1 <- sum(psd_ap_1[which(freq1 >= 0 & freq1 <= CF_AP_1 - 3)])
  PLF_AP_2 <- sum(psd_ap_2[which(freq2 >= 0 & freq2 <= CF_AP_2 - 3)])
  PLF_AP_3 <- sum(psd_ap_3[which(freq3 >= 0 & freq3 <= CF_AP_3 - 3)])

  PLF_ML_1 <- sum(psd_ml_1[which(freq1 >= 0 & freq1 <= CF_ML_1 - 3)])
  PLF_ML_2 <- sum(psd_ml_2[which(freq2 >= 0 & freq2 <= CF_ML_2 - 3)])
  PLF_ML_3 <- sum(psd_ml_3[which(freq3 >= 0 & freq3 <= CF_ML_3 - 3)])
  
  PLF_VT_1 <- sum(psd_VT_1[which(freq1 >= 0 & freq1 <= CF_VT_1 - 3)])
  PLF_VT_2 <- sum(psd_VT_2[which(freq2 >= 0 & freq2 <= CF_VT_2 - 3)])
  PLF_VT_3 <- sum(psd_VT_3[which(freq3 >= 0 & freq3 <= CF_VT_3 - 3)])

  PLF_Pitch_1 <- sum(psd_pi_1[which(freq1 >= 0 & freq1 <= CF_Pitch_1 - 3)])
  PLF_Pitch_2 <- sum(psd_pi_2[which(freq2 >= 0 & freq2 <= CF_Pitch_2 - 3)])
  PLF_Pitch_3 <- sum(psd_pi_3[which(freq3 >= 0 & freq3 <= CF_Pitch_3 - 3)])
  
  PLF_Roll_1 <- sum(psd_Roll_1[which(freq1 >= 0 & freq1 <= CF_Roll_1 - 3)])
  PLF_Roll_2 <- sum(psd_Roll_2[which(freq2 >= 0 & freq2 <= CF_Roll_2 - 3)])
  PLF_Roll_3 <- sum(psd_Roll_3[which(freq3 >= 0 & freq3 <= CF_Roll_3 - 3)])
  
  PLF_Yaw_1 <- sum(psd_Yaw_1[which(freq1 >= 0 & freq1 <= CF_Yaw_1 - 3)])
  PLF_Yaw_2 <- sum(psd_Yaw_2[which(freq2 >= 0 & freq2 <= CF_Yaw_2 - 3)])
  PLF_Yaw_3 <- sum(psd_Yaw_3[which(freq3 >= 0 & freq3 <= CF_Yaw_3 - 3)])


  # Average for the three pulls
  features$PLF_AP[i] <- mean(c(PLF_AP_1, PLF_AP_2, PLF_AP_3))
  features$PLF_ML[i] <- mean(c(PLF_ML_1, PLF_ML_2, PLF_ML_3))
  features$PLF_VT[i] <- mean(c(PLF_VT_1, PLF_VT_2, PLF_VT_3))
  features$PLF_Pitch[i] <- mean(c(PLF_Pitch_1, PLF_Pitch_2, PLF_Pitch_3))
  features$PLF_Roll[i] <- mean(c(PLF_Roll_1, PLF_Roll_2, PLF_Roll_3))
  features$PLF_Yaw[i] <- mean(c(PLF_Yaw_1, PLF_Yaw_2, PLF_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PLF_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
PLF_AP_HYclass2 <- features$PLF_AP[features$HYclass == group_A]
PLF_AP_HYclass3 <- features$PLF_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PLF_AP <- wilcox.test(PLF_AP_HYclass2, PLF_AP_HYclass3)$p.value

```


```{r PLF_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PLF_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PLF_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PLF_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PLF_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```



### Mediolateral

```{r Mann-Whitney-U-test_PLF_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PLF_ML_HYclass2 <- features$PLF_ML[features$HYclass == group_A]
PLF_ML_HYclass3 <- features$PLF_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PLF_ML <- wilcox.test(PLF_ML_HYclass2, PLF_ML_HYclass3)$p.value

```

```{r PLF_ML_plot_ML, echo=FALSE}

boxplot(PLF_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PLF_ML",
        #ylim = c(0,1.6),
        main = "Power in LF Band 0 - 16 Hz - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PLF_ML_plot_ML_no_outlier, echo=FALSE}

boxplot(PLF_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PLF_ML",
        outline = FALSE,
        main = "Power in LF Band 0 - 16 Hz - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PLF_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PLF_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PLF_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PLF_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PLF_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PLF_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PLF_VT_HYclass2 <- features$PLF_VT[features$HYclass == group_A]
PLF_VT_HYclass3 <- features$PLF_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PLF_VT <- wilcox.test(PLF_VT_HYclass2, PLF_VT_HYclass3)$p.value

```


```{r PLF_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PLF_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PLF_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PLF_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PLF_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```




### Pitch (AV)

```{r Mann-Whitney-U-test_PLF_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PLF_Pitch_HYclass2 <- features$PLF_Pitch[features$HYclass == group_A]
PLF_Pitch_HYclass3 <- features$PLF_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PLF_Pitch <- wilcox.test(PLF_Pitch_HYclass2, PLF_Pitch_HYclass3)$p.value

```

```{r PLF_plot_Pitch, echo=FALSE}

boxplot(PLF_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PLF_Pitch",
        main = "Power in LF Band 0 - 16 Hz - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PLF_plot_Pitch_no_outlier, echo=FALSE}

boxplot(PLF_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "M_0_16_Pitch",
        outline = FALSE,
        main = "Power in LF Band 0 - 16 Hz - Pitch (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PLF_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PLF_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PLF_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PLF_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PLF_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PLF_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PLF_Roll_HYclass2 <- features$PLF_Roll[features$HYclass == group_A]
PLF_Roll_HYclass3 <- features$PLF_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PLF_Roll <- wilcox.test(PLF_Roll_HYclass2, PLF_Roll_HYclass3)$p.value

```


```{r PLF_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PLF_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PLF_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PLF_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PLF_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PLF_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PLF_Yaw_HYclass2 <- features$PLF_Yaw[features$HYclass == group_A]
PLF_Yaw_HYclass3 <- features$PLF_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PLF_Yaw <- wilcox.test(PLF_Yaw_HYclass2, PLF_Yaw_HYclass3)$p.value

```


```{r PLF_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PLF_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PLF_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PLF_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PLF_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Power in High Frequency Band

```{r Power_HF, echo = FALSE}
features$PHF_AP <- NA
features$PHF_ML <- NA
features$PHF_VT <- NA
features$PHF_Pitch <- NA
features$PHF_Roll <- NA
features$PHF_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # first calculate centroidal frequency:
  
  CF_AP_1 <- sum(freq1 * psd_ap_1) / sum(psd_ap_1)
  CF_AP_2 <- sum(freq2 * psd_ap_2) / sum(psd_ap_2)
  CF_AP_3 <- sum(freq3 * psd_ap_3) / sum(psd_ap_3)
  
  CF_ML_1 <- sum(freq1 * psd_ml_1) / sum(psd_ml_1)
  CF_ML_2 <- sum(freq2 * psd_ml_2) / sum(psd_ml_2)
  CF_ML_3 <- sum(freq3 * psd_ml_3) / sum(psd_ml_3)
  
  CF_VT_1 <- sum(freq1 * psd_VT_1) / sum(psd_VT_1)
  CF_VT_2 <- sum(freq2 * psd_VT_2) / sum(psd_VT_2)
  CF_VT_3 <- sum(freq3 * psd_VT_3) / sum(psd_VT_3)
  
  CF_Pitch_1 <- sum(freq1 * psd_pi_1) / sum(psd_pi_1)
  CF_Pitch_2 <- sum(freq2 * psd_pi_2) / sum(psd_pi_2)
  CF_Pitch_3 <- sum(freq3 * psd_pi_3) / sum(psd_pi_3)
  
  CF_Roll_1 <- sum(freq1 * psd_Roll_1) / sum(psd_Roll_1)
  CF_Roll_2 <- sum(freq2 * psd_Roll_2) / sum(psd_Roll_2)
  CF_Roll_3 <- sum(freq3 * psd_Roll_3) / sum(psd_Roll_3)
  
  CF_Yaw_1 <- sum(freq1 * psd_Yaw_1) / sum(psd_Yaw_1)
  CF_Yaw_2 <- sum(freq2 * psd_Yaw_2) / sum(psd_Yaw_2)
  CF_Yaw_3 <- sum(freq3 * psd_Yaw_3) / sum(psd_Yaw_3)
  
  # then calc power 
  
  PHF_AP_1 <- sum(psd_ap_1[which(freq1 >= CF_AP_1 + 3 & freq1 <= 16)])
  PHF_AP_2 <- sum(psd_ap_2[which(freq2 >= CF_AP_2 + 3 & freq2 <= 16)])
  PHF_AP_3 <- sum(psd_ap_3[which(freq3 >= CF_AP_3 + 3 & freq3 <= 16)])

  PHF_ML_1 <- sum(psd_ml_1[which(freq1 >= CF_ML_1 + 3 & freq1 <= 16)])
  PHF_ML_2 <- sum(psd_ml_2[which(freq2 >= CF_ML_2 + 3 & freq2 <= 16)])
  PHF_ML_3 <- sum(psd_ml_3[which(freq3 >= CF_ML_3 + 3 & freq3 <= 16)])
  
  PHF_VT_1 <- sum(psd_VT_1[which(freq1 >= CF_VT_1 + 3 & freq1 <= 16)])
  PHF_VT_2 <- sum(psd_VT_2[which(freq2 >= CF_VT_2 + 3 & freq2 <= 16)])
  PHF_VT_3 <- sum(psd_VT_3[which(freq3 >= CF_VT_3 + 3 & freq3 <= 16)])

  PHF_Pitch_1 <- sum(psd_pi_1[which(freq1 >= CF_Pitch_1 + 3 & freq1 <= 16)])
  PHF_Pitch_2 <- sum(psd_pi_2[which(freq2 >= CF_Pitch_2 + 3 & freq2 <= 16)])
  PHF_Pitch_3 <- sum(psd_pi_3[which(freq3 >= CF_Pitch_3 + 3 & freq3 <= 16)])
  
  PHF_Roll_1 <- sum(psd_Roll_1[which(freq1 >= CF_Roll_1 + 3 & freq1 <= 16)])
  PHF_Roll_2 <- sum(psd_Roll_2[which(freq2 >= CF_Roll_2 + 3 & freq2 <= 16)])
  PHF_Roll_3 <- sum(psd_Roll_3[which(freq3 >= CF_Roll_3 + 3 & freq3 <= 16)])
  
  PHF_Yaw_1 <- sum(psd_Yaw_1[which(freq1 >= CF_Yaw_1 + 3 & freq1 <= 16)])
  PHF_Yaw_2 <- sum(psd_Yaw_2[which(freq2 >= CF_Yaw_2 + 3 & freq2 <= 16)])
  PHF_Yaw_3 <- sum(psd_Yaw_3[which(freq3 >= CF_Yaw_3 + 3 & freq3 <= 16)])


  # Average for the three pulls
  features$PHF_AP[i] <- mean(c(PHF_AP_1, PHF_AP_2, PHF_AP_3))
  features$PHF_ML[i] <- mean(c(PHF_ML_1, PHF_ML_2, PHF_ML_3))
  features$PHF_VT[i] <- mean(c(PHF_VT_1, PHF_VT_2, PHF_VT_3))
  features$PHF_Pitch[i] <- mean(c(PHF_Pitch_1, PHF_Pitch_2, PHF_Pitch_3))
  features$PHF_Roll[i] <- mean(c(PHF_Roll_1, PHF_Roll_2, PHF_Roll_3))
  features$PHF_Yaw[i] <- mean(c(PHF_Yaw_1, PHF_Yaw_2, PHF_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PHF_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
PHF_AP_HYclass2 <- features$PHF_AP[features$HYclass == group_A]
PHF_AP_HYclass3 <- features$PHF_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PHF_AP <- wilcox.test(PHF_AP_HYclass2, PHF_AP_HYclass3)$p.value

```


```{r PHF_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PHF_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PHF_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PHF_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PHF_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_PHF_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PHF_ML_HYclass2 <- features$PHF_ML[features$HYclass == group_A]
PHF_ML_HYclass3 <- features$PHF_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PHF_ML <- wilcox.test(PHF_ML_HYclass2, PHF_ML_HYclass3)$p.value

```

```{r PHF_ML_plot_ML, echo=FALSE}

boxplot(PHF_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PHF_ML",
        #ylim = c(0,1.6),
        main = "Power in HF Band Hz - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PHF_ML_plot_ML_no_outlier, echo=FALSE}

boxplot(PHF_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PHF_ML",
        outline = FALSE,
        main = "Power in HF Band - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PHF_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PHF_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PHF_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PHF_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PHF_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PHF_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PHF_VT_HYclass2 <- features$PHF_VT[features$HYclass == group_A]
PHF_VT_HYclass3 <- features$PHF_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PHF_VT <- wilcox.test(PHF_VT_HYclass2, PHF_VT_HYclass3)$p.value

```


```{r PHF_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PHF_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PHF_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PHF_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PHF_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch (AV)

```{r Mann-Whitney-U-test_PHF_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PHF_Pitch_HYclass2 <- features$PHF_Pitch[features$HYclass == group_A]
PHF_Pitch_HYclass3 <- features$PHF_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PHF_Pitch <- wilcox.test(PHF_Pitch_HYclass2, PHF_Pitch_HYclass3)$p.value

```

```{r PHF_plot_Pitch, echo=FALSE}

boxplot(PHF_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PHF_Pitch",
        main = "Power in HF Band - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PHF_plot_Pitch_no_outlier, echo=FALSE}

boxplot(PHF_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "M_0_16_Pitch",
        outline = FALSE,
        main = "Power in HF Band - Pitch (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PHF_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PHF_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PHF_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PHF_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PHF_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PHF_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PHF_Roll_HYclass2 <- features$PHF_Roll[features$HYclass == group_A]
PHF_Roll_HYclass3 <- features$PHF_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PHF_Roll <- wilcox.test(PHF_Roll_HYclass2, PHF_Roll_HYclass3)$p.value

```


```{r PHF_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PHF_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mRoll them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PHF_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PHF_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PHF_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PHF_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PHF_Yaw_HYclass2 <- features$PHF_Yaw[features$HYclass == group_A]
PHF_Yaw_HYclass3 <- features$PHF_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PHF_Yaw <- wilcox.test(PHF_Yaw_HYclass2, PHF_Yaw_HYclass3)$p.value

```


```{r PHF_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PHF_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PHF_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PHF_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PHF_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Total Power in Tremor band

```{r Power_tot_TB, echo = FALSE}
features$PTB_AP <- NA
features$PTB_ML <- NA
features$PTB_VT <- NA
features$PTB_Pitch <- NA
features$PTB_Roll <- NA
features$PTB_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # first calculate centroidal frequency:
  
  CF_AP_1 <- sum(freq1 * psd_ap_1) / sum(psd_ap_1)
  CF_AP_2 <- sum(freq2 * psd_ap_2) / sum(psd_ap_2)
  CF_AP_3 <- sum(freq3 * psd_ap_3) / sum(psd_ap_3)
  
  CF_ML_1 <- sum(freq1 * psd_ml_1) / sum(psd_ml_1)
  CF_ML_2 <- sum(freq2 * psd_ml_2) / sum(psd_ml_2)
  CF_ML_3 <- sum(freq3 * psd_ml_3) / sum(psd_ml_3)
  
  CF_VT_1 <- sum(freq1 * psd_VT_1) / sum(psd_VT_1)
  CF_VT_2 <- sum(freq2 * psd_VT_2) / sum(psd_VT_2)
  CF_VT_3 <- sum(freq3 * psd_VT_3) / sum(psd_VT_3)
  
  CF_Pitch_1 <- sum(freq1 * psd_pi_1) / sum(psd_pi_1)
  CF_Pitch_2 <- sum(freq2 * psd_pi_2) / sum(psd_pi_2)
  CF_Pitch_3 <- sum(freq3 * psd_pi_3) / sum(psd_pi_3)
  
  CF_Roll_1 <- sum(freq1 * psd_Roll_1) / sum(psd_Roll_1)
  CF_Roll_2 <- sum(freq2 * psd_Roll_2) / sum(psd_Roll_2)
  CF_Roll_3 <- sum(freq3 * psd_Roll_3) / sum(psd_Roll_3)
  
  CF_Yaw_1 <- sum(freq1 * psd_Yaw_1) / sum(psd_Yaw_1)
  CF_Yaw_2 <- sum(freq2 * psd_Yaw_2) / sum(psd_Yaw_2)
  CF_Yaw_3 <- sum(freq3 * psd_Yaw_3) / sum(psd_Yaw_3)
  
  # then calc power between CF -3 and CF + 3
  PTB_AP_1 <- sum(psd_ap_1[which(freq1 >= CF_AP_1 - 3 & freq1 <= CF_AP_1 + 3)])
  PTB_AP_2 <- sum(psd_ap_2[which(freq2 >= CF_AP_2 - 3 & freq2 <= CF_AP_2 + 3)])
  PTB_AP_3 <- sum(psd_ap_3[which(freq3 >= CF_AP_3 - 3 & freq3 <= CF_AP_3 + 3)])

  PTB_ML_1 <- sum(psd_ml_1[which(freq1 >= CF_ML_1 - 3 & freq1 <= CF_ML_1 + 3)])
  PTB_ML_2 <- sum(psd_ml_2[which(freq2 >= CF_ML_2 - 3 & freq2 <= CF_ML_2 + 3)])
  PTB_ML_3 <- sum(psd_ml_3[which(freq3 >= CF_ML_3 - 3 & freq3 <= CF_ML_3 + 3)])
  
  PTB_VT_1 <- sum(psd_VT_1[which(freq1 >= CF_VT_1 - 3 & freq1 <= CF_VT_1 + 3)])
  PTB_VT_2 <- sum(psd_VT_2[which(freq2 >= CF_VT_2 - 3 & freq2 <= CF_VT_2 + 3)])
  PTB_VT_3 <- sum(psd_VT_3[which(freq3 >= CF_VT_3 - 3 & freq3 <= CF_VT_3 + 3)])

  PTB_Pitch_1 <- sum(psd_pi_1[which(freq1 >= CF_Pitch_1 - 3 & freq1 <= CF_Pitch_1 + 3)])
  PTB_Pitch_2 <- sum(psd_pi_2[which(freq2 >= CF_Pitch_2 - 3 & freq2 <= CF_Pitch_2 + 3)])
  PTB_Pitch_3 <- sum(psd_pi_3[which(freq3 >= CF_Pitch_3 - 3 & freq3 <= CF_Pitch_3 + 3)])
  
  PTB_Roll_1 <- sum(psd_Roll_1[which(freq1 >= CF_Roll_1 - 3 & freq1 <= CF_Roll_1 + 3)])
  PTB_Roll_2 <- sum(psd_Roll_2[which(freq2 >= CF_Roll_2 - 3 & freq2 <= CF_Roll_2 + 3)])
  PTB_Roll_3 <- sum(psd_Roll_3[which(freq3 >= CF_Roll_3 - 3 & freq3 <= CF_Roll_3 + 3)])
  
  PTB_Yaw_1 <- sum(psd_Yaw_1[which(freq1 >= CF_Yaw_1 - 3 & freq1 <= CF_Yaw_1 + 3)])
  PTB_Yaw_2 <- sum(psd_Yaw_2[which(freq2 >= CF_Yaw_2 - 3 & freq2 <= CF_Yaw_2 + 3)])
  PTB_Yaw_3 <- sum(psd_Yaw_3[which(freq3 >= CF_Yaw_3 - 3 & freq3 <= CF_Yaw_3 + 3)])

  # Average for the three pulls
  features$PTB_AP[i] <- mean(c(PTB_AP_1, PTB_AP_2, PTB_AP_3))
  features$PTB_ML[i] <- mean(c(PTB_ML_1, PTB_ML_2, PTB_ML_3))
  features$PTB_VT[i] <- mean(c(PTB_VT_1, PTB_VT_2, PTB_VT_3))
  features$PTB_Pitch[i] <- mean(c(PTB_Pitch_1, PTB_Pitch_2, PTB_Pitch_3))
  features$PTB_Roll[i] <- mean(c(PTB_Roll_1, PTB_Roll_2, PTB_Roll_3))
  features$PTB_Yaw[i] <- mean(c(PTB_Yaw_1, PTB_Yaw_2, PTB_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PTB_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
PTB_AP_HYclass2 <- features$PTB_AP[features$HYclass == group_A]
PTB_AP_HYclass3 <- features$PTB_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PTB_AP <- wilcox.test(PTB_AP_HYclass2, PTB_AP_HYclass3)$p.value

```

```{r PTB_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PTB_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PTB_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PTB_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PTB_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_PTB_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PTB_ML_HYclass2 <- features$PTB_ML[features$HYclass == group_A]
PTB_ML_HYclass3 <- features$PTB_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PTB_ML <- wilcox.test(PTB_ML_HYclass2, PTB_ML_HYclass3)$p.value

```

```{r PTB_ML_plot_ML, echo=FALSE}

boxplot(PTB_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PTB_ML",
        #ylim = c(0,1.6),
        main = "Total Power in Tremor band - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PTB_ML_plot_ML_no_outlier, echo=FALSE}

boxplot(PTB_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PTB_ML",
        outline = FALSE,
        main = "Total Power in Tremor band - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PTB_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PTB_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PTB_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PTB_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PTB_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical    

```{r Mann-Whitney-U-test_PTB_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PTB_VT_HYclass2 <- features$PTB_VT[features$HYclass == group_A]
PTB_VT_HYclass3 <- features$PTB_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PTB_VT <- wilcox.test(PTB_VT_HYclass2, PTB_VT_HYclass3)$p.value

```

```{r PTB_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PTB_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PTB_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PTB_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PTB_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch (AV)

```{r Mann-Whitney-U-test_PTB_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PTB_Pitch_HYclass2 <- features$PTB_Pitch[features$HYclass == group_A]
PTB_Pitch_HYclass3 <- features$PTB_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PTB_Pitch <- wilcox.test(PTB_Pitch_HYclass2, PTB_Pitch_HYclass3)$p.value

```

```{r PTB_plot_Pitch, echo=FALSE}

boxplot(PTB_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PTB_Pitch",
        main = "Total Power in Tremor band - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PTB_plot_Pitch_no_outlier, echo=FALSE}

boxplot(PTB_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "M_0_16_Pitch",
        outline = FALSE,
        main = "Total Power in Tremor band - Pitch (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PTB_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PTB_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PTB_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PTB_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PTB_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PTB_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PTB_Roll_HYclass2 <- features$PTB_Roll[features$HYclass == group_A]
PTB_Roll_HYclass3 <- features$PTB_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PTB_Roll <- wilcox.test(PTB_Roll_HYclass2, PTB_Roll_HYclass3)$p.value

```

```{r PTB_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PTB_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mRoll them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PTB_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PTB_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PTB_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PTB_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PTB_Yaw_HYclass2 <- features$PTB_Yaw[features$HYclass == group_A]
PTB_Yaw_HYclass3 <- features$PTB_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PTB_Yaw <- wilcox.test(PTB_Yaw_HYclass2, PTB_Yaw_HYclass3)$p.value

```

```{r PTB_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PTB_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PTB_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PTB_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PTB_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Power Ratio 4 - 7 Hz

```{r power_ratio_4_7, echo = FALSE}
features$PR_4_7_AP <- NA
features$PR_4_7_ML <- NA
features$PR_4_7_VT <- NA
features$PR_4_7_Pitch <- NA
features$PR_4_7_Roll <- NA
features$PR_4_7_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate power ratio between 4 and 7 Hz
  PR_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 4, 7) / sum_power_in_band(psd_ap_1, freq1, 0, 25)
  PR_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 4, 7) / sum_power_in_band(psd_ap_2, freq2, 0, 25)
  PR_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 4, 7) / sum_power_in_band(psd_ap_3, freq3, 0, 25)
  
  PR_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 4, 7) / sum_power_in_band(psd_ml_1, freq1, 0, 25)
  PR_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 4, 7) / sum_power_in_band(psd_ml_2, freq2, 0, 25)
  PR_ML_3 <- sum_power_in_band(psd_ml_3, freq3, 4, 7) / sum_power_in_band(psd_ml_3, freq3, 0, 25)
  
  PR_VT_1 <- sum_power_in_band(psd_VT_1, freq1, 4, 7) / sum_power_in_band(psd_VT_1, freq1, 0, 25)
  PR_VT_2 <- sum_power_in_band(psd_VT_2, freq2, 4, 7) / sum_power_in_band(psd_VT_2, freq2, 0, 25)
  PR_VT_3 <- sum_power_in_band(psd_VT_3, freq3, 4, 7) / sum_power_in_band(psd_VT_3, freq3, 0, 25)
  
  PR_Pitch_1 <- sum_power_in_band(psd_pi_1, freq1, 4, 7) / sum_power_in_band(psd_pi_1, freq1, 0, 25)
  PR_Pitch_2 <- sum_power_in_band(psd_pi_2, freq2, 4, 7) / sum_power_in_band(psd_pi_2, freq2, 0, 25)
  PR_Pitch_3 <- sum_power_in_band(psd_pi_3, freq3, 4, 7) / sum_power_in_band(psd_pi_3, freq3, 0, 25)
  
  PR_Roll_1 <- sum_power_in_band(psd_Roll_1, freq1, 4, 7) / sum_power_in_band(psd_Roll_1, freq1, 0, 25)
  PR_Roll_2 <- sum_power_in_band(psd_Roll_2, freq2, 4, 7) / sum_power_in_band(psd_Roll_2, freq2, 0, 25)
  PR_Roll_3 <- sum_power_in_band(psd_Roll_3, freq3, 4, 7) / sum_power_in_band(psd_Roll_3, freq3, 0, 25)
  
  PR_Yaw_1 <- sum_power_in_band(psd_Yaw_1, freq1, 4, 7) / sum_power_in_band(psd_Yaw_1, freq1, 0, 25)
  PR_Yaw_2 <- sum_power_in_band(psd_Yaw_2, freq2, 4, 7) / sum_power_in_band(psd_Yaw_2, freq2, 0, 25)
  PR_Yaw_3 <- sum_power_in_band(psd_Yaw_3, freq3, 4, 7) / sum_power_in_band(psd_Yaw_3, freq3, 0, 25)

  
  # Average for the three pulls
  features$PR_4_7_AP[i] <- mean(c(PR_AP_1, PR_AP_2, PR_AP_3))
  features$PR_4_7_ML[i] <- mean(c(PR_ML_1, PR_ML_2, PR_ML_3))
  features$PR_4_7_VT[i] <- mean(c(PR_VT_1, PR_VT_2, PR_VT_3))
  features$PR_4_7_Pitch[i] <- mean(c(PR_Pitch_1, PR_Pitch_2, PR_Pitch_3))
  features$PR_4_7_Roll[i] <- mean(c(PR_Roll_1, PR_Roll_2, PR_Roll_3))
  features$PR_4_7_Yaw[i] <- mean(c(PR_Yaw_1, PR_Yaw_2, PR_Yaw_3))
  
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PR_4_7, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_4_7_AP_HYclass2 <- features$PR_4_7_AP[features$HYclass == group_A]
PR_4_7_AP_HYclass3 <- features$PR_4_7_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_4_7_AP <- wilcox.test(PR_4_7_AP_HYclass2, PR_4_7_AP_HYclass3)$p.value

```

```{r PR_4_7_AP_plot, echo=FALSE}

boxplot(PR_4_7_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PR_4_7_AP",
        # outline = FALSE,
        #ylim = c(0,1.6),
        main = "Power ratio 4 - 7 Hz - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PR_4_7_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_4_7_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_4_7_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_4_7_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_4_7_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_PR_4_7_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_4_7_ML_HYclass2 <- features$PR_4_7_ML[features$HYclass == group_A]
PR_4_7_ML_HYclass3 <- features$PR_4_7_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_4_7_ML <- wilcox.test(PR_4_7_ML_HYclass2, PR_4_7_ML_HYclass3)$p.value

```


```{r PR_4_7_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_4_7_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_4_7_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_4_7_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_4_7_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PR_4_7_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_4_7_VT_HYclass2 <- features$PR_4_7_VT[features$HYclass == group_A]
PR_4_7_VT_HYclass3 <- features$PR_4_7_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_4_7_VT <- wilcox.test(PR_4_7_VT_HYclass2, PR_4_7_VT_HYclass3)$p.value

```


```{r PR_4_7_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_4_7_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_4_7_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_4_7_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_4_7_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_PR_4_7_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_4_7_Pitch_HYclass2 <- features$PR_4_7_Pitch[features$HYclass == group_A]
PR_4_7_Pitch_HYclass3 <- features$PR_4_7_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_4_7_Pitch <- wilcox.test(PR_4_7_Pitch_HYclass2, PR_4_7_Pitch_HYclass3)$p.value

```


```{r PR_4_7_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_4_7_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_4_7_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_4_7_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_4_7_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PR_4_7_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_4_7_Roll_HYclass2 <- features$PR_4_7_Roll[features$HYclass == group_A]
PR_4_7_Roll_HYclass3 <- features$PR_4_7_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_4_7_Roll <- wilcox.test(PR_4_7_Roll_HYclass2, PR_4_7_Roll_HYclass3)$p.value

```


```{r PR_4_7_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_4_7_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_4_7_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_4_7_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_4_7_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PR_4_7_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_4_7_Yaw_HYclass2 <- features$PR_4_7_Yaw[features$HYclass == group_A]
PR_4_7_Yaw_HYclass3 <- features$PR_4_7_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_4_7_Yaw <- wilcox.test(PR_4_7_Yaw_HYclass2, PR_4_7_Yaw_HYclass3)$p.value

```


```{r PR_4_7_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_4_7_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_4_7_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_4_7_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_4_7_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Power Ratio 3.5 - 7.5 Hz*

```{r power_ratio_3.5_7.5, echo = FALSE}
features$PR_3.5_7.5_AP <- NA
features$PR_3.5_7.5_ML <- NA
features$PR_3.5_7.5_VT <- NA
features$PR_3.5_7.5_Pitch <- NA
features$PR_3.5_7.5_Roll <- NA
features$PR_3.5_7.5_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate power ratio between 3.5 and 7.5 Hz
  PR_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 3.5, 7.5) / sum_power_in_band(psd_ap_1, freq1, 0, 25)
  PR_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 3.5, 7.5) / sum_power_in_band(psd_ap_2, freq2, 0, 25)
  PR_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 3.5, 7.5) / sum_power_in_band(psd_ap_3, freq3, 0, 25)
  
  PR_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 3.5, 7.5) / sum_power_in_band(psd_ml_1, freq1, 0, 25)
  PR_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 3.5, 7.5) / sum_power_in_band(psd_ml_2, freq2, 0, 25)
  PR_ML_3 <- sum_power_in_band(psd_ml_3, freq3, 3.5, 7.5) / sum_power_in_band(psd_ml_3, freq3, 0, 25)
  
  PR_VT_1 <- sum_power_in_band(psd_VT_1, freq1, 3.5, 7.5) / sum_power_in_band(psd_VT_1, freq1, 0, 25)
  PR_VT_2 <- sum_power_in_band(psd_VT_2, freq2, 3.5, 7.5) / sum_power_in_band(psd_VT_2, freq2, 0, 25)
  PR_VT_3 <- sum_power_in_band(psd_VT_3, freq3, 3.5, 7.5) / sum_power_in_band(psd_VT_3, freq3, 0, 25)
  
  PR_Pitch_1 <- sum_power_in_band(psd_pi_1, freq1, 3.5, 7.5) / sum_power_in_band(psd_pi_1, freq1, 0, 25)
  PR_Pitch_2 <- sum_power_in_band(psd_pi_2, freq2, 3.5, 7.5) / sum_power_in_band(psd_pi_2, freq2, 0, 25)
  PR_Pitch_3 <- sum_power_in_band(psd_pi_3, freq3, 3.5, 7.5) / sum_power_in_band(psd_pi_3, freq3, 0, 25)
  
  PR_Roll_1 <- sum_power_in_band(psd_Roll_1, freq1, 3.5, 7.5) / sum_power_in_band(psd_Roll_1, freq1, 0, 25)
  PR_Roll_2 <- sum_power_in_band(psd_Roll_2, freq2, 3.5, 7.5) / sum_power_in_band(psd_Roll_2, freq2, 0, 25)
  PR_Roll_3 <- sum_power_in_band(psd_Roll_3, freq3, 3.5, 7.5) / sum_power_in_band(psd_Roll_3, freq3, 0, 25)
  
  PR_Yaw_1 <- sum_power_in_band(psd_Yaw_1, freq1, 3.5, 7.5) / sum_power_in_band(psd_Yaw_1, freq1, 0, 25)
  PR_Yaw_2 <- sum_power_in_band(psd_Yaw_2, freq2, 3.5, 7.5) / sum_power_in_band(psd_Yaw_2, freq2, 0, 25)
  PR_Yaw_3 <- sum_power_in_band(psd_Yaw_3, freq3, 3.5, 7.5) / sum_power_in_band(psd_Yaw_3, freq3, 0, 25)

  
  # Average for the three pulls
  features$PR_3.5_7.5_AP[i] <- mean(c(PR_AP_1, PR_AP_2, PR_AP_3))
  features$PR_3.5_7.5_ML[i] <- mean(c(PR_ML_1, PR_ML_2, PR_ML_3))
  features$PR_3.5_7.5_VT[i] <- mean(c(PR_VT_1, PR_VT_2, PR_VT_3))
  features$PR_3.5_7.5_Pitch[i] <- mean(c(PR_Pitch_1, PR_Pitch_2, PR_Pitch_3))
  features$PR_3.5_7.5_Roll[i] <- mean(c(PR_Roll_1, PR_Roll_2, PR_Roll_3))
  features$PR_3.5_7.5_Yaw[i] <- mean(c(PR_Yaw_1, PR_Yaw_2, PR_Yaw_3))
  
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PR_3.5_7.5, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_3.5_7.5_AP_HYclass2 <- features$PR_3.5_7.5_AP[features$HYclass == group_A]
PR_3.5_7.5_AP_HYclass3 <- features$PR_3.5_7.5_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_3.5_7.5_AP <- wilcox.test(PR_3.5_7.5_AP_HYclass2, PR_3.5_7.5_AP_HYclass3)$p.value

```

```{r PR_3.5_7.5_AP_plot, echo=FALSE}

boxplot(PR_3.5_7.5_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PR_3.5_7.5_AP",
        # outline = FALSE,
        #ylim = c(0,1.6),
        main = "Power ratio 4 - 7 Hz - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PR_3.5_7.5_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_3.5_7.5_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_3.5_7.5_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_3.5_7.5_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_3.5_7.5_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_PR_3.5_7.5_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_3.5_7.5_ML_HYclass2 <- features$PR_3.5_7.5_ML[features$HYclass == group_A]
PR_3.5_7.5_ML_HYclass3 <- features$PR_3.5_7.5_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_3.5_7.5_ML <- wilcox.test(PR_3.5_7.5_ML_HYclass2, PR_3.5_7.5_ML_HYclass3)$p.value

```


```{r PR_3.5_7.5_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_3.5_7.5_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_3.5_7.5_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_3.5_7.5_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_3.5_7.5_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PR_3.5_7.5_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_3.5_7.5_VT_HYclass2 <- features$PR_3.5_7.5_VT[features$HYclass == group_A]
PR_3.5_7.5_VT_HYclass3 <- features$PR_3.5_7.5_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_3.5_7.5_VT <- wilcox.test(PR_3.5_7.5_VT_HYclass2, PR_3.5_7.5_VT_HYclass3)$p.value

```


```{r PR_3.5_7.5_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_3.5_7.5_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_3.5_7.5_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_3.5_7.5_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_3.5_7.5_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_PR_3.5_7.5_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_3.5_7.5_Pitch_HYclass2 <- features$PR_3.5_7.5_Pitch[features$HYclass == group_A]
PR_3.5_7.5_Pitch_HYclass3 <- features$PR_3.5_7.5_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_3.5_7.5_Pitch <- wilcox.test(PR_3.5_7.5_Pitch_HYclass2, PR_3.5_7.5_Pitch_HYclass3)$p.value

```


```{r PR_3.5_7.5_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_3.5_7.5_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_3.5_7.5_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_3.5_7.5_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_3.5_7.5_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PR_3.5_7.5_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_3.5_7.5_Roll_HYclass2 <- features$PR_3.5_7.5_Roll[features$HYclass == group_A]
PR_3.5_7.5_Roll_HYclass3 <- features$PR_3.5_7.5_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_3.5_7.5_Roll <- wilcox.test(PR_3.5_7.5_Roll_HYclass2, PR_3.5_7.5_Roll_HYclass3)$p.value

```


```{r PR_3.5_7.5_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_3.5_7.5_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_3.5_7.5_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_3.5_7.5_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_3.5_7.5_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PR_3.5_7.5_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_3.5_7.5_Yaw_HYclass2 <- features$PR_3.5_7.5_Yaw[features$HYclass == group_A]
PR_3.5_7.5_Yaw_HYclass3 <- features$PR_3.5_7.5_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_3.5_7.5_Yaw <- wilcox.test(PR_3.5_7.5_Yaw_HYclass2, PR_3.5_7.5_Yaw_HYclass3)$p.value

```


```{r PR_3.5_7.5_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_3.5_7.5_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_3.5_7.5_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_3.5_7.5_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_3.5_7.5_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Power Ratio 5 - 6 Hz

```{r power_ratio_5_6, echo = FALSE}
features$PR_5_6_AP <- NA
features$PR_5_6_ML <- NA
features$PR_5_6_VT <- NA
features$PR_5_6_Pitch <- NA
features$PR_5_6_Roll <- NA
features$PR_5_6_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate power ratio between 4 and 7 Hz
  PR_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 5, 6) / sum_power_in_band(psd_ap_1, freq1, 0, 25)
  PR_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 5, 6) / sum_power_in_band(psd_ap_2, freq2, 0, 25)
  PR_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 5, 6) / sum_power_in_band(psd_ap_3, freq3, 0, 25)
  
  PR_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 5, 6) / sum_power_in_band(psd_ml_1, freq1, 0, 25)
  PR_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 5, 6) / sum_power_in_band(psd_ml_2, freq2, 0, 25)
  PR_ML_3 <- sum_power_in_band(psd_ml_3, freq3, 5, 6) / sum_power_in_band(psd_ml_3, freq3, 0, 25)
  
  PR_VT_1 <- sum_power_in_band(psd_VT_1, freq1, 5, 6) / sum_power_in_band(psd_VT_1, freq1, 0, 25)
  PR_VT_2 <- sum_power_in_band(psd_VT_2, freq2, 5, 6) / sum_power_in_band(psd_VT_2, freq2, 0, 25)
  PR_VT_3 <- sum_power_in_band(psd_VT_3, freq3, 5, 6) / sum_power_in_band(psd_VT_3, freq3, 0, 25)
  
  PR_Pitch_1 <- sum_power_in_band(psd_pi_1, freq1, 5, 6) / sum_power_in_band(psd_pi_1, freq1, 0, 25)
  PR_Pitch_2 <- sum_power_in_band(psd_pi_2, freq2, 5, 6) / sum_power_in_band(psd_pi_2, freq2, 0, 25)
  PR_Pitch_3 <- sum_power_in_band(psd_pi_3, freq3, 5, 6) / sum_power_in_band(psd_pi_3, freq3, 0, 25)
  
  PR_Roll_1 <- sum_power_in_band(psd_Roll_1, freq1, 5, 6) / sum_power_in_band(psd_Roll_1, freq1, 0, 25)
  PR_Roll_2 <- sum_power_in_band(psd_Roll_2, freq2, 5, 6) / sum_power_in_band(psd_Roll_2, freq2, 0, 25)
  PR_Roll_3 <- sum_power_in_band(psd_Roll_3, freq3, 5, 6) / sum_power_in_band(psd_Roll_3, freq3, 0, 25)
  
  PR_Yaw_1 <- sum_power_in_band(psd_Yaw_1, freq1, 5, 6) / sum_power_in_band(psd_Yaw_1, freq1, 0, 25)
  PR_Yaw_2 <- sum_power_in_band(psd_Yaw_2, freq2, 5, 6) / sum_power_in_band(psd_Yaw_2, freq2, 0, 25)
  PR_Yaw_3 <- sum_power_in_band(psd_Yaw_3, freq3, 5, 6) / sum_power_in_band(psd_Yaw_3, freq3, 0, 25)

  
  # Average for the three pulls
  features$PR_5_6_AP[i] <- mean(c(PR_AP_1, PR_AP_2, PR_AP_3))
  features$PR_5_6_ML[i] <- mean(c(PR_ML_1, PR_ML_2, PR_ML_3))
  features$PR_5_6_VT[i] <- mean(c(PR_VT_1, PR_VT_2, PR_VT_3))
  features$PR_5_6_Pitch[i] <- mean(c(PR_Pitch_1, PR_Pitch_2, PR_Pitch_3))
  features$PR_5_6_Roll[i] <- mean(c(PR_Roll_1, PR_Roll_2, PR_Roll_3))
  features$PR_5_6_Yaw[i] <- mean(c(PR_Yaw_1, PR_Yaw_2, PR_Yaw_3))
  
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PR_5_6, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_5_6_AP_HYclass2 <- features$PR_5_6_AP[features$HYclass == group_A]
PR_5_6_AP_HYclass3 <- features$PR_5_6_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_5_6_AP <- wilcox.test(PR_5_6_AP_HYclass2, PR_5_6_AP_HYclass3)$p.value

```

```{r PR_5_6_AP_plot, echo=FALSE}

boxplot(PR_5_6_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PR_5_6_AP",
        # outline = FALSE,
        #ylim = c(0,1.6),
        main = "Power ratio 4 - 7 Hz - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PR_5_6_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_5_6_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_5_6_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_5_6_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_5_6_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_PR_5_6_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_5_6_ML_HYclass2 <- features$PR_5_6_ML[features$HYclass == group_A]
PR_5_6_ML_HYclass3 <- features$PR_5_6_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_5_6_ML <- wilcox.test(PR_5_6_ML_HYclass2, PR_5_6_ML_HYclass3)$p.value

```


```{r PR_5_6_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_5_6_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_5_6_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_5_6_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_5_6_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PR_5_6_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_5_6_VT_HYclass2 <- features$PR_5_6_VT[features$HYclass == group_A]
PR_5_6_VT_HYclass3 <- features$PR_5_6_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_5_6_VT <- wilcox.test(PR_5_6_VT_HYclass2, PR_5_6_VT_HYclass3)$p.value

```


```{r PR_5_6_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_5_6_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_5_6_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_5_6_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_5_6_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_PR_5_6_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_5_6_Pitch_HYclass2 <- features$PR_5_6_Pitch[features$HYclass == group_A]
PR_5_6_Pitch_HYclass3 <- features$PR_5_6_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_5_6_Pitch <- wilcox.test(PR_5_6_Pitch_HYclass2, PR_5_6_Pitch_HYclass3)$p.value

```


```{r PR_5_6_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_5_6_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_5_6_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_5_6_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_5_6_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PR_5_6_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_5_6_Roll_HYclass2 <- features$PR_5_6_Roll[features$HYclass == group_A]
PR_5_6_Roll_HYclass3 <- features$PR_5_6_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_5_6_Roll <- wilcox.test(PR_5_6_Roll_HYclass2, PR_5_6_Roll_HYclass3)$p.value

```


```{r PR_5_6_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_5_6_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_5_6_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_5_6_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_5_6_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PR_5_6_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_5_6_Yaw_HYclass2 <- features$PR_5_6_Yaw[features$HYclass == group_A]
PR_5_6_Yaw_HYclass3 <- features$PR_5_6_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_5_6_Yaw <- wilcox.test(PR_5_6_Yaw_HYclass2, PR_5_6_Yaw_HYclass3)$p.value

```


```{r PR_5_6_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_5_6_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_5_6_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_5_6_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_5_6_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Power Ratio 8 - 12 Hz*

```{r power_ratio_8_12, echo = FALSE}
features$PR_8_12_AP <- NA
features$PR_8_12_ML <- NA
features$PR_8_12_VT <- NA
features$PR_8_12_Pitch <- NA
features$PR_8_12_Roll <- NA
features$PR_8_12_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate power ratio between 8 and 12 Hz
  PR_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 8, 12) / sum_power_in_band(psd_ap_1, freq1, 0, 25)
  PR_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 8, 12) / sum_power_in_band(psd_ap_2, freq2, 0, 25)
  PR_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 8, 12) / sum_power_in_band(psd_ap_3, freq3, 0, 25)
  
  PR_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 8, 12) / sum_power_in_band(psd_ml_1, freq1, 0, 25)
  PR_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 8, 12) / sum_power_in_band(psd_ml_2, freq2, 0, 25)
  PR_ML_3 <- sum_power_in_band(psd_ml_3, freq3, 8, 12) / sum_power_in_band(psd_ml_3, freq3, 0, 25)
  
  PR_VT_1 <- sum_power_in_band(psd_VT_1, freq1, 8, 12) / sum_power_in_band(psd_VT_1, freq1, 0, 25)
  PR_VT_2 <- sum_power_in_band(psd_VT_2, freq2, 8, 12) / sum_power_in_band(psd_VT_2, freq2, 0, 25)
  PR_VT_3 <- sum_power_in_band(psd_VT_3, freq3, 8, 12) / sum_power_in_band(psd_VT_3, freq3, 0, 25)
  
  PR_Pitch_1 <- sum_power_in_band(psd_pi_1, freq1, 8, 12) / sum_power_in_band(psd_pi_1, freq1, 0, 25)
  PR_Pitch_2 <- sum_power_in_band(psd_pi_2, freq2, 8, 12) / sum_power_in_band(psd_pi_2, freq2, 0, 25)
  PR_Pitch_3 <- sum_power_in_band(psd_pi_3, freq3, 8, 12) / sum_power_in_band(psd_pi_3, freq3, 0, 25)
  
  PR_Roll_1 <- sum_power_in_band(psd_Roll_1, freq1, 8, 12) / sum_power_in_band(psd_Roll_1, freq1, 0, 25)
  PR_Roll_2 <- sum_power_in_band(psd_Roll_2, freq2, 8, 12) / sum_power_in_band(psd_Roll_2, freq2, 0, 25)
  PR_Roll_3 <- sum_power_in_band(psd_Roll_3, freq3, 8, 12) / sum_power_in_band(psd_Roll_3, freq3, 0, 25)
  
  PR_Yaw_1 <- sum_power_in_band(psd_Yaw_1, freq1, 8, 12) / sum_power_in_band(psd_Yaw_1, freq1, 0, 25)
  PR_Yaw_2 <- sum_power_in_band(psd_Yaw_2, freq2, 8, 12) / sum_power_in_band(psd_Yaw_2, freq2, 0, 25)
  PR_Yaw_3 <- sum_power_in_band(psd_Yaw_3, freq3, 8, 12) / sum_power_in_band(psd_Yaw_3, freq3, 0, 25)

  
  # Average for the three pulls
  features$PR_8_12_AP[i] <- mean(c(PR_AP_1, PR_AP_2, PR_AP_3))
  features$PR_8_12_ML[i] <- mean(c(PR_ML_1, PR_ML_2, PR_ML_3))
  features$PR_8_12_VT[i] <- mean(c(PR_VT_1, PR_VT_2, PR_VT_3))
  features$PR_8_12_Pitch[i] <- mean(c(PR_Pitch_1, PR_Pitch_2, PR_Pitch_3))
  features$PR_8_12_Roll[i] <- mean(c(PR_Roll_1, PR_Roll_2, PR_Roll_3))
  features$PR_8_12_Yaw[i] <- mean(c(PR_Yaw_1, PR_Yaw_2, PR_Yaw_3))
  
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PR_8_12, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_8_12_AP_HYclass2 <- features$PR_8_12_AP[features$HYclass == group_A]
PR_8_12_AP_HYclass3 <- features$PR_8_12_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_8_12_AP <- wilcox.test(PR_8_12_AP_HYclass2, PR_8_12_AP_HYclass3)$p.value

```

```{r PR_8_12_AP_plot, echo=FALSE}

boxplot(PR_8_12_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PR_8_12_AP",
        # outline = FALSE,
        #ylim = c(0,1.6),
        main = "Power ratio 4 - 7 Hz - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PR_8_12_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_8_12_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_8_12_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_8_12_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_8_12_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_PR_8_12_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_8_12_ML_HYclass2 <- features$PR_8_12_ML[features$HYclass == group_A]
PR_8_12_ML_HYclass3 <- features$PR_8_12_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_8_12_ML <- wilcox.test(PR_8_12_ML_HYclass2, PR_8_12_ML_HYclass3)$p.value

```


```{r PR_8_12_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_8_12_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_8_12_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_8_12_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_8_12_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PR_8_12_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_8_12_VT_HYclass2 <- features$PR_8_12_VT[features$HYclass == group_A]
PR_8_12_VT_HYclass3 <- features$PR_8_12_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_8_12_VT <- wilcox.test(PR_8_12_VT_HYclass2, PR_8_12_VT_HYclass3)$p.value

```


```{r PR_8_12_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_8_12_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_8_12_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_8_12_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_8_12_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_PR_8_12_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_8_12_Pitch_HYclass2 <- features$PR_8_12_Pitch[features$HYclass == group_A]
PR_8_12_Pitch_HYclass3 <- features$PR_8_12_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_8_12_Pitch <- wilcox.test(PR_8_12_Pitch_HYclass2, PR_8_12_Pitch_HYclass3)$p.value

```


```{r PR_8_12_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_8_12_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_8_12_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_8_12_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_8_12_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PR_8_12_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_8_12_Roll_HYclass2 <- features$PR_8_12_Roll[features$HYclass == group_A]
PR_8_12_Roll_HYclass3 <- features$PR_8_12_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_8_12_Roll <- wilcox.test(PR_8_12_Roll_HYclass2, PR_8_12_Roll_HYclass3)$p.value

```


```{r PR_8_12_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_8_12_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_8_12_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_8_12_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_8_12_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PR_8_12_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_8_12_Yaw_HYclass2 <- features$PR_8_12_Yaw[features$HYclass == group_A]
PR_8_12_Yaw_HYclass3 <- features$PR_8_12_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_8_12_Yaw <- wilcox.test(PR_8_12_Yaw_HYclass2, PR_8_12_Yaw_HYclass3)$p.value

```


```{r PR_8_12_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_8_12_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_8_12_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_8_12_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_8_12_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Power Ratio 3 - 12 Hz

```{r power_ratio_3_12, echo = FALSE}
features$PR_3_12_AP <- NA
features$PR_3_12_ML <- NA
features$PR_3_12_VT <- NA
features$PR_3_12_Pitch <- NA
features$PR_3_12_Roll <- NA
features$PR_3_12_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate power ratio between 8 and 12 Hz
  PR_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 3, 12) / sum_power_in_band(psd_ap_1, freq1, 0, 25)
  PR_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 3, 12) / sum_power_in_band(psd_ap_2, freq2, 0, 25)
  PR_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 3, 12) / sum_power_in_band(psd_ap_3, freq3, 0, 25)
  
  PR_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 3, 12) / sum_power_in_band(psd_ml_1, freq1, 0, 25)
  PR_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 3, 12) / sum_power_in_band(psd_ml_2, freq2, 0, 25)
  PR_ML_3 <- sum_power_in_band(psd_ml_3, freq3, 3, 12) / sum_power_in_band(psd_ml_3, freq3, 0, 25)
  
  PR_VT_1 <- sum_power_in_band(psd_VT_1, freq1, 3, 12) / sum_power_in_band(psd_VT_1, freq1, 0, 25)
  PR_VT_2 <- sum_power_in_band(psd_VT_2, freq2, 3, 12) / sum_power_in_band(psd_VT_2, freq2, 0, 25)
  PR_VT_3 <- sum_power_in_band(psd_VT_3, freq3, 3, 12) / sum_power_in_band(psd_VT_3, freq3, 0, 25)
  
  PR_Pitch_1 <- sum_power_in_band(psd_pi_1, freq1, 3, 12) / sum_power_in_band(psd_pi_1, freq1, 0, 25)
  PR_Pitch_2 <- sum_power_in_band(psd_pi_2, freq2, 3, 12) / sum_power_in_band(psd_pi_2, freq2, 0, 25)
  PR_Pitch_3 <- sum_power_in_band(psd_pi_3, freq3, 3, 12) / sum_power_in_band(psd_pi_3, freq3, 0, 25)
  
  PR_Roll_1 <- sum_power_in_band(psd_Roll_1, freq1, 3, 12) / sum_power_in_band(psd_Roll_1, freq1, 0, 25)
  PR_Roll_2 <- sum_power_in_band(psd_Roll_2, freq2, 3, 12) / sum_power_in_band(psd_Roll_2, freq2, 0, 25)
  PR_Roll_3 <- sum_power_in_band(psd_Roll_3, freq3, 3, 12) / sum_power_in_band(psd_Roll_3, freq3, 0, 25)
  
  PR_Yaw_1 <- sum_power_in_band(psd_Yaw_1, freq1, 3, 12) / sum_power_in_band(psd_Yaw_1, freq1, 0, 25)
  PR_Yaw_2 <- sum_power_in_band(psd_Yaw_2, freq2, 3, 12) / sum_power_in_band(psd_Yaw_2, freq2, 0, 25)
  PR_Yaw_3 <- sum_power_in_band(psd_Yaw_3, freq3, 3, 12) / sum_power_in_band(psd_Yaw_3, freq3, 0, 25)

  
  # Average for the three pulls
  features$PR_3_12_AP[i] <- mean(c(PR_AP_1, PR_AP_2, PR_AP_3))
  features$PR_3_12_ML[i] <- mean(c(PR_ML_1, PR_ML_2, PR_ML_3))
  features$PR_3_12_VT[i] <- mean(c(PR_VT_1, PR_VT_2, PR_VT_3))
  features$PR_3_12_Pitch[i] <- mean(c(PR_Pitch_1, PR_Pitch_2, PR_Pitch_3))
  features$PR_3_12_Roll[i] <- mean(c(PR_Roll_1, PR_Roll_2, PR_Roll_3))
  features$PR_3_12_Yaw[i] <- mean(c(PR_Yaw_1, PR_Yaw_2, PR_Yaw_3))
  
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PR_3_12, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_3_12_AP_HYclass2 <- features$PR_3_12_AP[features$HYclass == group_A]
PR_3_12_AP_HYclass3 <- features$PR_3_12_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_3_12_AP <- wilcox.test(PR_3_12_AP_HYclass2, PR_3_12_AP_HYclass3)$p.value

```

```{r PR_3_12_AP_plot, echo=FALSE}

boxplot(PR_3_12_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PR_3_12_AP",
        # outline = FALSE,
        #ylim = c(0,1.6),
        main = "Power ratio 4 - 7 Hz - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PR_3_12_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_3_12_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_3_12_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_3_12_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_3_12_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_PR_3_12_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_3_12_ML_HYclass2 <- features$PR_3_12_ML[features$HYclass == group_A]
PR_3_12_ML_HYclass3 <- features$PR_3_12_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_3_12_ML <- wilcox.test(PR_3_12_ML_HYclass2, PR_3_12_ML_HYclass3)$p.value

```


```{r PR_3_12_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_3_12_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_3_12_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_3_12_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_3_12_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PR_3_12_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_3_12_VT_HYclass2 <- features$PR_3_12_VT[features$HYclass == group_A]
PR_3_12_VT_HYclass3 <- features$PR_3_12_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_3_12_VT <- wilcox.test(PR_3_12_VT_HYclass2, PR_3_12_VT_HYclass3)$p.value

```


```{r PR_3_12_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_3_12_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_3_12_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_3_12_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_3_12_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch

```{r Mann-Whitney-U-test_PR_3_12_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_3_12_Pitch_HYclass2 <- features$PR_3_12_Pitch[features$HYclass == group_A]
PR_3_12_Pitch_HYclass3 <- features$PR_3_12_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_3_12_Pitch <- wilcox.test(PR_3_12_Pitch_HYclass2, PR_3_12_Pitch_HYclass3)$p.value

```


```{r PR_3_12_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_3_12_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_3_12_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_3_12_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_3_12_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PR_3_12_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_3_12_Roll_HYclass2 <- features$PR_3_12_Roll[features$HYclass == group_A]
PR_3_12_Roll_HYclass3 <- features$PR_3_12_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_3_12_Roll <- wilcox.test(PR_3_12_Roll_HYclass2, PR_3_12_Roll_HYclass3)$p.value

```


```{r PR_3_12_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_3_12_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_3_12_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_3_12_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_3_12_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PR_3_12_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_3_12_Yaw_HYclass2 <- features$PR_3_12_Yaw[features$HYclass == group_A]
PR_3_12_Yaw_HYclass3 <- features$PR_3_12_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_3_12_Yaw <- wilcox.test(PR_3_12_Yaw_HYclass2, PR_3_12_Yaw_HYclass3)$p.value

```


```{r PR_3_12_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_3_12_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_3_12_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_3_12_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_3_12_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## High to Low Power Ratio

```{r High_to_low_PR, echo = FALSE}
features$PR_HL_AP <- NA
features$PR_HL_ML <- NA
features$PR_HL_VT <- NA
features$PR_HL_Pitch <- NA
features$PR_HL_Roll <- NA
features$PR_HL_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate power ratio of 3.5 to 7.5 Hz
  PR_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 3.5, 15) / sum_power_in_band(psd_ap_1, freq1, 0.15, 3.5)
  PR_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 3.5, 15) / sum_power_in_band(psd_ap_2, freq2, 0.15, 3.5)
  PR_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 3.5, 15) / sum_power_in_band(psd_ap_3, freq3, 0.15, 3.5)
  
  PR_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 3.5, 15) / sum_power_in_band(psd_ml_1, freq1, 0.15, 3.5)
  PR_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 3.5, 15) / sum_power_in_band(psd_ml_2, freq2, 0.15, 3.5)
  PR_ML_3 <- sum_power_in_band(psd_ml_3, freq3, 3.5, 15) / sum_power_in_band(psd_ml_3, freq3, 0.15, 3.5)
  
  PR_VT_1 <- sum_power_in_band(psd_VT_1, freq1, 3.5, 15) / sum_power_in_band(psd_VT_1, freq1, 0.15, 3.5)
  PR_VT_2 <- sum_power_in_band(psd_VT_2, freq2, 3.5, 15) / sum_power_in_band(psd_VT_2, freq2, 0.15, 3.5)
  PR_VT_3 <- sum_power_in_band(psd_VT_3, freq3, 3.5, 15) / sum_power_in_band(psd_VT_3, freq3, 0.15, 3.5)
  
  PR_Pitch_1 <- sum_power_in_band(psd_pi_1, freq1, 3.5, 15) / sum_power_in_band(psd_pi_1, freq1, 0.15, 3.5)
  PR_Pitch_2 <- sum_power_in_band(psd_pi_2, freq2, 3.5, 15) / sum_power_in_band(psd_pi_2, freq2, 0.15, 3.5)
  PR_Pitch_3 <- sum_power_in_band(psd_pi_3, freq3, 3.5, 15) / sum_power_in_band(psd_pi_3, freq3, 0.15, 3.5)
  
  PR_Roll_1 <- sum_power_in_band(psd_Roll_1, freq1, 3.5, 15) / sum_power_in_band(psd_Roll_1, freq1, 0.15, 3.5)
  PR_Roll_2 <- sum_power_in_band(psd_Roll_2, freq2, 3.5, 15) / sum_power_in_band(psd_Roll_2, freq2, 0.15, 3.5)
  PR_Roll_3 <- sum_power_in_band(psd_Roll_3, freq3, 3.5, 15) / sum_power_in_band(psd_Roll_3, freq3, 0.15, 3.5)
  
  PR_Yaw_1 <- sum_power_in_band(psd_Yaw_1, freq1, 3.5, 15) / sum_power_in_band(psd_Yaw_1, freq1, 0.15, 3.5)
  PR_Yaw_2 <- sum_power_in_band(psd_Yaw_2, freq2, 3.5, 15) / sum_power_in_band(psd_Yaw_2, freq2, 0.15, 3.5)
  PR_Yaw_3 <- sum_power_in_band(psd_Yaw_3, freq3, 3.5, 15) / sum_power_in_band(psd_Yaw_3, freq3, 0.15, 3.5)

  # Average for the three pulls
  features$PR_HL_AP[i] <- mean(c(PR_AP_1, PR_AP_2, PR_AP_3))
  features$PR_HL_ML[i] <- mean(c(PR_ML_1, PR_ML_2, PR_ML_3))
  features$PR_HL_VT[i] <- mean(c(PR_VT_1, PR_VT_2, PR_VT_3))
  features$PR_HL_Pitch[i] <- mean(c(PR_Pitch_1, PR_Pitch_2, PR_Pitch_3))
  features$PR_HL_Roll[i] <- mean(c(PR_Roll_1, PR_Roll_2, PR_Roll_3))
  features$PR_HL_Yaw[i] <- mean(c(PR_Yaw_1, PR_Yaw_2, PR_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PR_HL, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_HL_AP_HYclass2 <- features$PR_HL_AP[features$HYclass == group_A]
PR_HL_AP_HYclass3 <- features$PR_HL_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_HL_AP <- wilcox.test(PR_HL_AP_HYclass2, PR_HL_AP_HYclass3)$p.value

```

```{r PR_HL_AP_plot, echo=FALSE}

boxplot(PR_HL_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PR_HL_AP",
        main = "High to Low Power Ratio - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PR_HL_AP_plot_no_outlier, echo=FALSE}

boxplot(PR_HL_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PR_HL_AP",
        outline = FALSE,
        main = "High to Low Power Ratio - AP (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PR_HL_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_HL_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_HL_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_HL_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_HL_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_PR_HL_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_HL_ML_HYclass2 <- features$PR_HL_ML[features$HYclass == group_A]
PR_HL_ML_HYclass3 <- features$PR_HL_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_HL_ML <- wilcox.test(PR_HL_ML_HYclass2, PR_HL_ML_HYclass3)$p.value

```


```{r PR_HL_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_HL_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_HL_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_HL_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_HL_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PR_HL_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_HL_VT_HYclass2 <- features$PR_HL_VT[features$HYclass == group_A]
PR_HL_VT_HYclass3 <- features$PR_HL_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_HL_VT <- wilcox.test(PR_HL_VT_HYclass2, PR_HL_VT_HYclass3)$p.value

```


```{r PR_HL_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_HL_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_HL_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_HL_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_HL_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch (AV) 

```{r Mann-Whitney-U-test_PR_HL_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_HL_Pitch_HYclass2 <- features$PR_HL_Pitch[features$HYclass == group_A]
PR_HL_Pitch_HYclass3 <- features$PR_HL_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_HL_Pitch <-
  wilcox.test(PR_HL_Pitch_HYclass2, PR_HL_Pitch_HYclass3)$p.value

```


```{r PR_HL_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_HL_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_HL_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_HL_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_HL_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PR_HL_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_HL_Roll_HYclass2 <- features$PR_HL_Roll[features$HYclass == group_A]
PR_HL_Roll_HYclass3 <- features$PR_HL_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_HL_Roll <- wilcox.test(PR_HL_Roll_HYclass2, PR_HL_Roll_HYclass3)$p.value

```


```{r PR_HL_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_HL_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_HL_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_HL_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_HL_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PR_HL_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_HL_Yaw_HYclass2 <- features$PR_HL_Yaw[features$HYclass == group_A]
PR_HL_Yaw_HYclass3 <- features$PR_HL_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_HL_Yaw <- wilcox.test(PR_HL_Yaw_HYclass2, PR_HL_Yaw_HYclass3)$p.value

```


```{r PR_HL_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_HL_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_HL_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_HL_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_HL_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Selected Power Ratio

```{r Selected_power_ratio, echo = FALSE}
features$PR_Sel_AP <- NA
features$PR_Sel_ML <- NA
features$PR_Sel_VT <- NA
features$PR_Sel_Pitch <- NA
features$PR_Sel_Roll <- NA
features$PR_Sel_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate power ratio of 3.5 to 7.5 Hz
  PR_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 3.5, 4.5) / sum_power_in_band(psd_ap_1, freq1, 7.5, 8.5)
  PR_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 3.5, 4.5) / sum_power_in_band(psd_ap_2, freq2, 7.5, 8.5)
  PR_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 3.5, 4.5) / sum_power_in_band(psd_ap_3, freq3, 7.5, 8.5)
  
  PR_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 3.5, 4.5) / sum_power_in_band(psd_ml_1, freq1, 7.5, 8.5)
  PR_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 3.5, 4.5) / sum_power_in_band(psd_ml_2, freq2, 7.5, 8.5)
  PR_ML_3 <- sum_power_in_band(psd_ml_3, freq3, 3.5, 4.5) / sum_power_in_band(psd_ml_3, freq3, 7.5, 8.5)
  
  PR_VT_1 <- sum_power_in_band(psd_VT_1, freq1, 3.5, 4.5) / sum_power_in_band(psd_VT_1, freq1, 7.5, 8.5)
  PR_VT_2 <- sum_power_in_band(psd_VT_2, freq2, 3.5, 4.5) / sum_power_in_band(psd_VT_2, freq2, 7.5, 8.5)
  PR_VT_3 <- sum_power_in_band(psd_VT_3, freq3, 3.5, 4.5) / sum_power_in_band(psd_VT_3, freq3, 7.5, 8.5)
  
  PR_Pitch_1 <- sum_power_in_band(psd_pi_1, freq1, 3.5, 4.5) / sum_power_in_band(psd_pi_1, freq1, 7.5, 8.5)
  PR_Pitch_2 <- sum_power_in_band(psd_pi_2, freq2, 3.5, 4.5) / sum_power_in_band(psd_pi_2, freq2, 7.5, 8.5)
  PR_Pitch_3 <- sum_power_in_band(psd_pi_3, freq3, 3.5, 4.5) / sum_power_in_band(psd_pi_3, freq3, 7.5, 8.5)
  
  PR_Roll_1 <- sum_power_in_band(psd_Roll_1, freq1, 3.5, 4.5) / sum_power_in_band(psd_Roll_1, freq1, 7.5, 8.5)
  PR_Roll_2 <- sum_power_in_band(psd_Roll_2, freq2, 3.5, 4.5) / sum_power_in_band(psd_Roll_2, freq2, 7.5, 8.5)
  PR_Roll_3 <- sum_power_in_band(psd_Roll_3, freq3, 3.5, 4.5) / sum_power_in_band(psd_Roll_3, freq3, 7.5, 8.5)
  
  PR_Yaw_1 <- sum_power_in_band(psd_Yaw_1, freq1, 3.5, 4.5) / sum_power_in_band(psd_Yaw_1, freq1, 7.5, 8.5)
  PR_Yaw_2 <- sum_power_in_band(psd_Yaw_2, freq2, 3.5, 4.5) / sum_power_in_band(psd_Yaw_2, freq2, 7.5, 8.5)
  PR_Yaw_3 <- sum_power_in_band(psd_Yaw_3, freq3, 3.5, 4.5) / sum_power_in_band(psd_Yaw_3, freq3, 7.5, 8.5)

  # Average for the three pulls
  features$PR_Sel_AP[i] <- mean(c(PR_AP_1, PR_AP_2, PR_AP_3))
  features$PR_Sel_ML[i] <- mean(c(PR_ML_1, PR_ML_2, PR_ML_3))
  features$PR_Sel_VT[i] <- mean(c(PR_VT_1, PR_VT_2, PR_VT_3))
  features$PR_Sel_Pitch[i] <- mean(c(PR_Pitch_1, PR_Pitch_2, PR_Pitch_3))
  features$PR_Sel_Roll[i] <- mean(c(PR_Roll_1, PR_Roll_2, PR_Roll_3))
  features$PR_Sel_Yaw[i] <- mean(c(PR_Yaw_1, PR_Yaw_2, PR_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PR_Sel, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_Sel_AP_HYclass2 <- features$PR_Sel_AP[features$HYclass == group_A]
PR_Sel_AP_HYclass3 <- features$PR_Sel_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_Sel_AP <- wilcox.test(PR_Sel_AP_HYclass2, PR_Sel_AP_HYclass3)$p.value

```

```{r PR_Sel_AP_plot, echo=FALSE}

boxplot(PR_Sel_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PR_Sel_AP",
        main = "Selected Power Ratio - AP", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PR_Sel_AP_plot_no_outlier, echo=FALSE}

boxplot(PR_Sel_AP ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PR_Sel_AP",
        outline = FALSE,
        main = "Selected Power Ratio - AP (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PR_Sel_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_Sel_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_Sel_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_Sel_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_Sel_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_PR_Sel_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_Sel_ML_HYclass2 <- features$PR_Sel_ML[features$HYclass == group_A]
PR_Sel_ML_HYclass3 <- features$PR_Sel_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_Sel_ML <- wilcox.test(PR_Sel_ML_HYclass2, PR_Sel_ML_HYclass3)$p.value

```

```{r PR_Sel_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_Sel_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_Sel_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_Sel_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_Sel_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PR_Sel_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_Sel_VT_HYclass2 <- features$PR_Sel_VT[features$HYclass == group_A]
PR_Sel_VT_HYclass3 <- features$PR_Sel_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_Sel_VT <- wilcox.test(PR_Sel_VT_HYclass2, PR_Sel_VT_HYclass3)$p.value

```

```{r PR_Sel_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_Sel_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_Sel_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_Sel_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_Sel_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch (AV) 

```{r Mann-Whitney-U-test_PR_Sel_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_Sel_Pitch_HYclass2 <- features$PR_Sel_Pitch[features$HYclass == group_A]
PR_Sel_Pitch_HYclass3 <- features$PR_Sel_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_Sel_Pitch <-
  wilcox.test(PR_Sel_Pitch_HYclass2, PR_Sel_Pitch_HYclass3)$p.value

```


```{r PR_Sel_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_Sel_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_Sel_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_Sel_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_Sel_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PR_Sel_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_Sel_Roll_HYclass2 <- features$PR_Sel_Roll[features$HYclass == group_A]
PR_Sel_Roll_HYclass3 <- features$PR_Sel_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_Sel_Roll <- wilcox.test(PR_Sel_Roll_HYclass2, PR_Sel_Roll_HYclass3)$p.value

```

```{r PR_Sel_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_Sel_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_Sel_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_Sel_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_Sel_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PR_Sel_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PR_Sel_Yaw_HYclass2 <- features$PR_Sel_Yaw[features$HYclass == group_A]
PR_Sel_Yaw_HYclass3 <- features$PR_Sel_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PR_Sel_Yaw <- wilcox.test(PR_Sel_Yaw_HYclass2, PR_Sel_Yaw_HYclass3)$p.value

```

```{r PR_Sel_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PR_Sel_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PR_Sel_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PR_Sel_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PR_Sel_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Relative Power in Low Frequency band

```{r Power_rel_PLF, echo = FALSE}
features$PLF_Rel_AP <- NA
features$PLF_Rel_ML <- NA
features$PLF_Rel_VT <- NA
features$PLF_Rel_Pitch <- NA
features$PLF_Rel_Roll <- NA
features$PLF_Rel_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # first calculate centroidal frequency:
  
  CF_AP_1 <- sum(freq1 * psd_ap_1) / sum(psd_ap_1)
  CF_AP_2 <- sum(freq2 * psd_ap_2) / sum(psd_ap_2)
  CF_AP_3 <- sum(freq3 * psd_ap_3) / sum(psd_ap_3)
  
  CF_ML_1 <- sum(freq1 * psd_ml_1) / sum(psd_ml_1)
  CF_ML_2 <- sum(freq2 * psd_ml_2) / sum(psd_ml_2)
  CF_ML_3 <- sum(freq3 * psd_ml_3) / sum(psd_ml_3)
  
  CF_VT_1 <- sum(freq1 * psd_VT_1) / sum(psd_VT_1)
  CF_VT_2 <- sum(freq2 * psd_VT_2) / sum(psd_VT_2)
  CF_VT_3 <- sum(freq3 * psd_VT_3) / sum(psd_VT_3)
  
  CF_Pitch_1 <- sum(freq1 * psd_pi_1) / sum(psd_pi_1)
  CF_Pitch_2 <- sum(freq2 * psd_pi_2) / sum(psd_pi_2)
  CF_Pitch_3 <- sum(freq3 * psd_pi_3) / sum(psd_pi_3)
  
  CF_Roll_1 <- sum(freq1 * psd_Roll_1) / sum(psd_Roll_1)
  CF_Roll_2 <- sum(freq2 * psd_Roll_2) / sum(psd_Roll_2)
  CF_Roll_3 <- sum(freq3 * psd_Roll_3) / sum(psd_Roll_3)
  
  CF_Yaw_1 <- sum(freq1 * psd_Yaw_1) / sum(psd_Yaw_1)
  CF_Yaw_2 <- sum(freq2 * psd_Yaw_2) / sum(psd_Yaw_2)
  CF_Yaw_3 <- sum(freq3 * psd_Yaw_3) / sum(psd_Yaw_3)
  
  # then calc power between CF -3 and 0
  PLF_Rel_AP_1 <- sum(psd_ap_1[which(freq1 >= 0 & freq1 <= CF_AP_1 - 3)])
  PLF_Rel_AP_2 <- sum(psd_ap_2[which(freq2 >= 0 & freq2 <= CF_AP_2 - 3)])
  PLF_Rel_AP_3 <- sum(psd_ap_3[which(freq3 >= 0 & freq3 <= CF_AP_3 - 3)])

  PLF_Rel_ML_1 <- sum(psd_ml_1[which(freq1 >= 0 & freq1 <= CF_ML_1 - 3)])
  PLF_Rel_ML_2 <- sum(psd_ml_2[which(freq2 >= 0 & freq2 <= CF_ML_2 - 3)])
  PLF_Rel_ML_3 <- sum(psd_ml_3[which(freq3 >= 0 & freq3 <= CF_ML_3 - 3)])
  
  PLF_Rel_VT_1 <- sum(psd_VT_1[which(freq1 >= 0 & freq1 <= CF_VT_1 - 3)])
  PLF_Rel_VT_2 <- sum(psd_VT_2[which(freq2 >= 0 & freq2 <= CF_VT_2 - 3)])
  PLF_Rel_VT_3 <- sum(psd_VT_3[which(freq3 >= 0 & freq3 <= CF_VT_3 - 3)])

  PLF_Rel_Pitch_1 <- sum(psd_pi_1[which(freq1 >= 0 & freq1 <= CF_Pitch_1 - 3)])
  PLF_Rel_Pitch_2 <- sum(psd_pi_2[which(freq2 >= 0 & freq2 <= CF_Pitch_2 - 3)])
  PLF_Rel_Pitch_3 <- sum(psd_pi_3[which(freq3 >= 0 & freq3 <= CF_Pitch_3 - 3)])
  
  PLF_Rel_Roll_1 <- sum(psd_Roll_1[which(freq1 >= 0 & freq1 <= CF_Roll_1 - 3)])
  PLF_Rel_Roll_2 <- sum(psd_Roll_2[which(freq2 >= 0 & freq2 <= CF_Roll_2 - 3)])
  PLF_Rel_Roll_3 <- sum(psd_Roll_3[which(freq3 >= 0 & freq3 <= CF_Roll_3 - 3)])
  
  PLF_Rel_Yaw_1 <- sum(psd_Yaw_1[which(freq1 >= 0 & freq1 <= CF_Yaw_1 - 3)])
  PLF_Rel_Yaw_2 <- sum(psd_Yaw_2[which(freq2 >= 0 & freq2 <= CF_Yaw_2 - 3)])
  PLF_Rel_Yaw_3 <- sum(psd_Yaw_3[which(freq3 >= 0 & freq3 <= CF_Yaw_3 - 3)])
  
  # then calc total power
  PLF_Tot_AP_1 <- sum(psd_ap_1[which(freq1 >= 0 & freq1 <= 25)])
  PLF_Tot_AP_2 <- sum(psd_ap_2[which(freq2 >= 0 & freq2 <= 25)])
  PLF_Tot_AP_3 <- sum(psd_ap_3[which(freq3 >= 0 & freq3 <= 25)])

  PLF_Tot_ML_1 <- sum(psd_ml_1[which(freq1 >= 0 & freq1 <= 25)])
  PLF_Tot_ML_2 <- sum(psd_ml_2[which(freq2 >= 0 & freq2 <= 25)])
  PLF_Tot_ML_3 <- sum(psd_ml_3[which(freq3 >= 0 & freq3 <= 25)])
  
  PLF_Tot_VT_1 <- sum(psd_VT_1[which(freq1 >= 0 & freq1 <= 25)])
  PLF_Tot_VT_2 <- sum(psd_VT_2[which(freq2 >= 0 & freq2 <= 25)])
  PLF_Tot_VT_3 <- sum(psd_VT_3[which(freq3 >= 0 & freq3 <= 25)])

  PLF_Tot_Pitch_1 <- sum(psd_pi_1[which(freq1 >= 0 & freq1 <= 25)])
  PLF_Tot_Pitch_2 <- sum(psd_pi_2[which(freq2 >= 0 & freq2 <= 25)])
  PLF_Tot_Pitch_3 <- sum(psd_pi_3[which(freq3 >= 0 & freq3 <= 25)])
  
  PLF_Tot_Roll_1 <- sum(psd_Roll_1[which(freq1 >= 0 & freq1 <= 25)])
  PLF_Tot_Roll_2 <- sum(psd_Roll_2[which(freq2 >= 0 & freq2 <= 25)])
  PLF_Tot_Roll_3 <- sum(psd_Roll_3[which(freq3 >= 0 & freq3 <= 25)])
  
  PLF_Tot_Yaw_1 <- sum(psd_Yaw_1[which(freq1 >= 0 & freq1 <= 25)])
  PLF_Tot_Yaw_2 <- sum(psd_Yaw_2[which(freq2 >= 0 & freq2 <= 25)])
  PLF_Tot_Yaw_3 <- sum(psd_Yaw_3[which(freq3 >= 0 & freq3 <= 25)])


  # Average for the three pulls taking the ratio for Rel power
  features$PLF_Rel_AP[i] <- mean(c(PLF_Rel_AP_1/PLF_Tot_AP_1, 
                                   PLF_Rel_AP_2/PLF_Tot_AP_2, 
                                   PLF_Rel_AP_3/PLF_Tot_AP_3))
  features$PLF_Rel_ML[i] <- mean(c(PLF_Rel_ML_1/PLF_Tot_ML_1, 
                                   PLF_Rel_ML_2/PLF_Tot_ML_2, 
                                   PLF_Rel_ML_3/PLF_Tot_ML_3))
  features$PLF_Rel_VT[i] <- mean(c(PLF_Rel_VT_1/PLF_Tot_VT_1, 
                                   PLF_Rel_VT_2/PLF_Tot_VT_2, 
                                   PLF_Rel_VT_3/PLF_Tot_VT_3))
  features$PLF_Rel_Pitch[i] <- mean(c(PLF_Rel_Pitch_1/PLF_Tot_Pitch_1, 
                                      PLF_Rel_Pitch_2/PLF_Tot_Pitch_2,
                                      PLF_Rel_Pitch_3/PLF_Tot_Pitch_3))
  features$PLF_Rel_Roll[i] <- mean(c(PLF_Rel_Roll_1/PLF_Tot_Roll_1, 
                                   PLF_Rel_Roll_2/PLF_Tot_Roll_2, 
                                   PLF_Rel_Roll_3/PLF_Tot_Roll_3))
  features$PLF_Rel_Yaw[i] <- mean(c(PLF_Rel_Yaw_1/PLF_Tot_Yaw_1, 
                                   PLF_Rel_Yaw_2/PLF_Tot_Yaw_2, 
                                   PLF_Rel_Yaw_3/PLF_Tot_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PLF_Rel_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
PLF_Rel_AP_HYclass2 <- features$PLF_Rel_AP[features$HYclass == group_A]
PLF_Rel_AP_HYclass3 <- features$PLF_Rel_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PLF_Rel_AP <- wilcox.test(PLF_Rel_AP_HYclass2, PLF_Rel_AP_HYclass3)$p.value

```


```{r PLF_Rel_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PLF_Rel_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PLF_Rel_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PLF_Rel_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PLF_Rel_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_PLF_Rel_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PLF_Rel_ML_HYclass2 <- features$PLF_Rel_ML[features$HYclass == group_A]
PLF_Rel_ML_HYclass3 <- features$PLF_Rel_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PLF_Rel_ML <- wilcox.test(PLF_Rel_ML_HYclass2, PLF_Rel_ML_HYclass3)$p.value

```

```{r PLF_Rel_ML_plot_ML, echo=FALSE}

boxplot(PLF_Rel_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PLF_Rel_ML",
        #ylim = c(0,1.6),
        main = "Relative Power in LF band - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PLF_Rel_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PLF_Rel_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PLF_Rel_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PLF_Rel_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PLF_Rel_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PLF_Rel_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PLF_Rel_VT_HYclass2 <- features$PLF_Rel_VT[features$HYclass == group_A]
PLF_Rel_VT_HYclass3 <- features$PLF_Rel_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PLF_Rel_VT <- wilcox.test(PLF_Rel_VT_HYclass2, PLF_Rel_VT_HYclass3)$p.value

```


```{r PLF_Rel_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PLF_Rel_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PLF_Rel_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PLF_Rel_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PLF_Rel_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch (AV)

```{r Mann-Whitney-U-test_PLF_Rel_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PLF_Rel_Pitch_HYclass2 <- features$PLF_Rel_Pitch[features$HYclass == group_A]
PLF_Rel_Pitch_HYclass3 <- features$PLF_Rel_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PLF_Rel_Pitch <- 
  wilcox.test(PLF_Rel_Pitch_HYclass2, PLF_Rel_Pitch_HYclass3)$p.value

```

```{r PLF_Rel_plot_Pitch, echo=FALSE}

boxplot(PLF_Rel_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PLF_Rel_Pitch",
        main = "Relative Power in LF band - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PLF_Rel_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PLF_Rel_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PLF_Rel_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PLF_Rel_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PLF_Rel_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PLF_Rel_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PLF_Rel_Roll_HYclass2 <- features$PLF_Rel_Roll[features$HYclass == group_A]
PLF_Rel_Roll_HYclass3 <- features$PLF_Rel_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PLF_Rel_Roll <- wilcox.test(PLF_Rel_Roll_HYclass2, PLF_Rel_Roll_HYclass3)$p.value

```


```{r PLF_Rel_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PLF_Rel_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PLF_Rel_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PLF_Rel_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PLF_Rel_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PLF_Rel_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PLF_Rel_Yaw_HYclass2 <- features$PLF_Rel_Yaw[features$HYclass == group_A]
PLF_Rel_Yaw_HYclass3 <- features$PLF_Rel_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PLF_Rel_Yaw <- wilcox.test(PLF_Rel_Yaw_HYclass2, PLF_Rel_Yaw_HYclass3)$p.value

```


```{r PLF_Rel_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PLF_Rel_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PLF_Rel_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PLF_Rel_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PLF_Rel_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Relative Power in High Frequency band

```{r Power_rel_PHF, echo = FALSE}
features$PHF_Rel_AP <- NA
features$PHF_Rel_ML <- NA
features$PHF_Rel_VT <- NA
features$PHF_Rel_Pitch <- NA
features$PHF_Rel_Roll <- NA
features$PHF_Rel_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # first calculate centroidal frequency:
  
  CF_AP_1 <- sum(freq1 * psd_ap_1) / sum(psd_ap_1)
  CF_AP_2 <- sum(freq2 * psd_ap_2) / sum(psd_ap_2)
  CF_AP_3 <- sum(freq3 * psd_ap_3) / sum(psd_ap_3)
  
  CF_ML_1 <- sum(freq1 * psd_ml_1) / sum(psd_ml_1)
  CF_ML_2 <- sum(freq2 * psd_ml_2) / sum(psd_ml_2)
  CF_ML_3 <- sum(freq3 * psd_ml_3) / sum(psd_ml_3)
  
  CF_VT_1 <- sum(freq1 * psd_VT_1) / sum(psd_VT_1)
  CF_VT_2 <- sum(freq2 * psd_VT_2) / sum(psd_VT_2)
  CF_VT_3 <- sum(freq3 * psd_VT_3) / sum(psd_VT_3)
  
  CF_Pitch_1 <- sum(freq1 * psd_pi_1) / sum(psd_pi_1)
  CF_Pitch_2 <- sum(freq2 * psd_pi_2) / sum(psd_pi_2)
  CF_Pitch_3 <- sum(freq3 * psd_pi_3) / sum(psd_pi_3)
  
  CF_Roll_1 <- sum(freq1 * psd_Roll_1) / sum(psd_Roll_1)
  CF_Roll_2 <- sum(freq2 * psd_Roll_2) / sum(psd_Roll_2)
  CF_Roll_3 <- sum(freq3 * psd_Roll_3) / sum(psd_Roll_3)
  
  CF_Yaw_1 <- sum(freq1 * psd_Yaw_1) / sum(psd_Yaw_1)
  CF_Yaw_2 <- sum(freq2 * psd_Yaw_2) / sum(psd_Yaw_2)
  CF_Yaw_3 <- sum(freq3 * psd_Yaw_3) / sum(psd_Yaw_3)
  
  # then calc power between CF -3 and CF + 3
  PHF_Rel_AP_1 <- sum(psd_ap_1[which(freq1 >= CF_AP_1 + 3 & freq1 <= 16)])
  PHF_Rel_AP_2 <- sum(psd_ap_2[which(freq2 >= CF_AP_2 + 3 & freq2 <= 16)])
  PHF_Rel_AP_3 <- sum(psd_ap_3[which(freq3 >= CF_AP_3 + 3 & freq3 <= 16)])

  PHF_Rel_ML_1 <- sum(psd_ml_1[which(freq1 >= CF_ML_1 + 3 & freq1 <= 16)])
  PHF_Rel_ML_2 <- sum(psd_ml_2[which(freq2 >= CF_ML_2 + 3 & freq2 <= 16)])
  PHF_Rel_ML_3 <- sum(psd_ml_3[which(freq3 >= CF_ML_3 + 3 & freq3 <= 16)])
  
  PHF_Rel_VT_1 <- sum(psd_VT_1[which(freq1 >= CF_VT_1 + 3 & freq1 <= 16)])
  PHF_Rel_VT_2 <- sum(psd_VT_2[which(freq2 >= CF_VT_2 + 3 & freq2 <= 16)])
  PHF_Rel_VT_3 <- sum(psd_VT_3[which(freq3 >= CF_VT_3 + 3 & freq3 <= 16)])

  PHF_Rel_Pitch_1 <- sum(psd_pi_1[which(freq1 >= CF_Pitch_1 + 3 & freq1 <= 16)])
  PHF_Rel_Pitch_2 <- sum(psd_pi_2[which(freq2 >= CF_Pitch_2 + 3 & freq2 <= 16)])
  PHF_Rel_Pitch_3 <- sum(psd_pi_3[which(freq3 >= CF_Pitch_3 + 3 & freq3 <= 16)])
  
  PHF_Rel_Roll_1 <- sum(psd_Roll_1[which(freq1 >= CF_Roll_1 + 3 & freq1 <= 16)])
  PHF_Rel_Roll_2 <- sum(psd_Roll_2[which(freq2 >= CF_Roll_2 + 3 & freq2 <= 16)])
  PHF_Rel_Roll_3 <- sum(psd_Roll_3[which(freq3 >= CF_Roll_3 + 3 & freq3 <= 16)])
  
  PHF_Rel_Yaw_1 <- sum(psd_Yaw_1[which(freq1 >= CF_Yaw_1 + 3 & freq1 <= 16)])
  PHF_Rel_Yaw_2 <- sum(psd_Yaw_2[which(freq2 >= CF_Yaw_2 + 3 & freq2 <= 16)])
  PHF_Rel_Yaw_3 <- sum(psd_Yaw_3[which(freq3 >= CF_Yaw_3 + 3 & freq3 <= 16)])
  
  # then calc total power
  PHF_Tot_AP_1 <- sum(psd_ap_1[which(freq1 >= 0 & freq1 <= 25)])
  PHF_Tot_AP_2 <- sum(psd_ap_2[which(freq2 >= 0 & freq2 <= 25)])
  PHF_Tot_AP_3 <- sum(psd_ap_3[which(freq3 >= 0 & freq3 <= 25)])

  PHF_Tot_ML_1 <- sum(psd_ml_1[which(freq1 >= 0 & freq1 <= 25)])
  PHF_Tot_ML_2 <- sum(psd_ml_2[which(freq2 >= 0 & freq2 <= 25)])
  PHF_Tot_ML_3 <- sum(psd_ml_3[which(freq3 >= 0 & freq3 <= 25)])
  
  PHF_Tot_VT_1 <- sum(psd_VT_1[which(freq1 >= 0 & freq1 <= 25)])
  PHF_Tot_VT_2 <- sum(psd_VT_2[which(freq2 >= 0 & freq2 <= 25)])
  PHF_Tot_VT_3 <- sum(psd_VT_3[which(freq3 >= 0 & freq3 <= 25)])

  PHF_Tot_Pitch_1 <- sum(psd_pi_1[which(freq1 >= 0 & freq1 <= 25)])
  PHF_Tot_Pitch_2 <- sum(psd_pi_2[which(freq2 >= 0 & freq2 <= 25)])
  PHF_Tot_Pitch_3 <- sum(psd_pi_3[which(freq3 >= 0 & freq3 <= 25)])
  
  PHF_Tot_Roll_1 <- sum(psd_Roll_1[which(freq1 >= 0 & freq1 <= 25)])
  PHF_Tot_Roll_2 <- sum(psd_Roll_2[which(freq2 >= 0 & freq2 <= 25)])
  PHF_Tot_Roll_3 <- sum(psd_Roll_3[which(freq3 >= 0 & freq3 <= 25)])
  
  PHF_Tot_Yaw_1 <- sum(psd_Yaw_1[which(freq1 >= 0 & freq1 <= 25)])
  PHF_Tot_Yaw_2 <- sum(psd_Yaw_2[which(freq2 >= 0 & freq2 <= 25)])
  PHF_Tot_Yaw_3 <- sum(psd_Yaw_3[which(freq3 >= 0 & freq3 <= 25)])


  # Average for the three pulls taking the ratio for Rel power
  features$PHF_Rel_AP[i] <- mean(c(PHF_Rel_AP_1/PHF_Tot_AP_1, 
                                   PHF_Rel_AP_2/PHF_Tot_AP_2, 
                                   PHF_Rel_AP_3/PHF_Tot_AP_3))
  features$PHF_Rel_ML[i] <- mean(c(PHF_Rel_ML_1/PHF_Tot_ML_1, 
                                   PHF_Rel_ML_2/PHF_Tot_ML_2, 
                                   PHF_Rel_ML_3/PHF_Tot_ML_3))
  features$PHF_Rel_VT[i] <- mean(c(PHF_Rel_VT_1/PHF_Tot_VT_1, 
                                   PHF_Rel_VT_2/PHF_Tot_VT_2, 
                                   PHF_Rel_VT_3/PHF_Tot_VT_3))
  features$PHF_Rel_Pitch[i] <- mean(c(PHF_Rel_Pitch_1/PHF_Tot_Pitch_1,
                                      PHF_Rel_Pitch_2/PHF_Tot_Pitch_2,
                                      PHF_Rel_Pitch_3/PHF_Tot_Pitch_3))
  features$PHF_Rel_Roll[i] <- mean(c(PHF_Rel_Roll_1/PHF_Tot_Roll_1, 
                                   PHF_Rel_Roll_2/PHF_Tot_Roll_2, 
                                   PHF_Rel_Roll_3/PHF_Tot_Roll_3))
  features$PHF_Rel_Yaw[i] <- mean(c(PHF_Rel_Yaw_1/PHF_Tot_Yaw_1, 
                                   PHF_Rel_Yaw_2/PHF_Tot_Yaw_2, 
                                   PHF_Rel_Yaw_3/PHF_Tot_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PHF_Rel_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
PHF_Rel_AP_HYclass2 <- features$PHF_Rel_AP[features$HYclass == group_A]
PHF_Rel_AP_HYclass3 <- features$PHF_Rel_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PHF_Rel_AP <- wilcox.test(PHF_Rel_AP_HYclass2, PHF_Rel_AP_HYclass3)$p.value

```


```{r PHF_Rel_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PHF_Rel_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PHF_Rel_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PHF_Rel_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PHF_Rel_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_PHF_Rel_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PHF_Rel_ML_HYclass2 <- features$PHF_Rel_ML[features$HYclass == group_A]
PHF_Rel_ML_HYclass3 <- features$PHF_Rel_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PHF_Rel_ML <- wilcox.test(PHF_Rel_ML_HYclass2, PHF_Rel_ML_HYclass3)$p.value

```

```{r PHF_Rel_ML_plot_ML, echo=FALSE}

boxplot(PHF_Rel_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PHF_Rel_ML",
        #ylim = c(0,1.6),
        main = "Relative Power in HF band - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PHF_Rel_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PHF_Rel_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PHF_Rel_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PHF_Rel_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PHF_Rel_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PHF_Rel_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PHF_Rel_VT_HYclass2 <- features$PHF_Rel_VT[features$HYclass == group_A]
PHF_Rel_VT_HYclass3 <- features$PHF_Rel_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PHF_Rel_VT <- wilcox.test(PHF_Rel_VT_HYclass2, PHF_Rel_VT_HYclass3)$p.value

```


```{r PHF_Rel_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PHF_Rel_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PHF_Rel_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PHF_Rel_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PHF_Rel_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch (AV)

```{r Mann-Whitney-U-test_PHF_Rel_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PHF_Rel_Pitch_HYclass2 <- features$PHF_Rel_Pitch[features$HYclass == group_A]
PHF_Rel_Pitch_HYclass3 <- features$PHF_Rel_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PHF_Rel_Pitch <-
  wilcox.test(PHF_Rel_Pitch_HYclass2, PHF_Rel_Pitch_HYclass3)$p.value

```

```{r PHF_Rel_plot_Pitch, echo=FALSE}

boxplot(PHF_Rel_Pitch ~ HYclass, data = features,
        xlab = "HYclass",
        ylab = "PHF_Rel_Pitch",
        main = "Relative Power in HF band - Pitch",
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PHF_Rel_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PHF_Rel_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PHF_Rel_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PHF_Rel_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PHF_Rel_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Roll

```{r Mann-Whitney-U-test_PHF_Rel_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PHF_Rel_Roll_HYclass2 <- features$PHF_Rel_Roll[features$HYclass == group_A]
PHF_Rel_Roll_HYclass3 <- features$PHF_Rel_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PHF_Rel_Roll <- wilcox.test(PHF_Rel_Roll_HYclass2, PHF_Rel_Roll_HYclass3)$p.value

```


```{r PHF_Rel_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PHF_Rel_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mRoll them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PHF_Rel_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PHF_Rel_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PHF_Rel_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PHF_Rel_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PHF_Rel_Yaw_HYclass2 <- features$PHF_Rel_Yaw[features$HYclass == group_A]
PHF_Rel_Yaw_HYclass3 <- features$PHF_Rel_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PHF_Rel_Yaw <- wilcox.test(PHF_Rel_Yaw_HYclass2, PHF_Rel_Yaw_HYclass3)$p.value

```


```{r PHF_Rel_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PHF_Rel_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and mYaw them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PHF_Rel_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PHF_Rel_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PHF_Rel_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Relative Power in Tremor band

```{r Power_Rel_TB, echo = FALSE}
features$PTB_Rel_AP <- NA
features$PTB_Rel_ML <- NA
features$PTB_Rel_VT <- NA
features$PTB_Rel_Pitch <- NA
features$PTB_Rel_Roll <- NA
features$PTB_Rel_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # first calculate centroidal frequency:
  
  CF_AP_1 <- sum(freq1 * psd_ap_1) / sum(psd_ap_1)
  CF_AP_2 <- sum(freq2 * psd_ap_2) / sum(psd_ap_2)
  CF_AP_3 <- sum(freq3 * psd_ap_3) / sum(psd_ap_3)
  
  CF_ML_1 <- sum(freq1 * psd_ml_1) / sum(psd_ml_1)
  CF_ML_2 <- sum(freq2 * psd_ml_2) / sum(psd_ml_2)
  CF_ML_3 <- sum(freq3 * psd_ml_3) / sum(psd_ml_3)
  
  CF_VT_1 <- sum(freq1 * psd_VT_1) / sum(psd_VT_1)
  CF_VT_2 <- sum(freq2 * psd_VT_2) / sum(psd_VT_2)
  CF_VT_3 <- sum(freq3 * psd_VT_3) / sum(psd_VT_3)
  
  CF_Pitch_1 <- sum(freq1 * psd_pi_1) / sum(psd_pi_1)
  CF_Pitch_2 <- sum(freq2 * psd_pi_2) / sum(psd_pi_2)
  CF_Pitch_3 <- sum(freq3 * psd_pi_3) / sum(psd_pi_3)
  
  CF_Roll_1 <- sum(freq1 * psd_Roll_1) / sum(psd_Roll_1)
  CF_Roll_2 <- sum(freq2 * psd_Roll_2) / sum(psd_Roll_2)
  CF_Roll_3 <- sum(freq3 * psd_Roll_3) / sum(psd_Roll_3)
  
  CF_Yaw_1 <- sum(freq1 * psd_Yaw_1) / sum(psd_Yaw_1)
  CF_Yaw_2 <- sum(freq2 * psd_Yaw_2) / sum(psd_Yaw_2)
  CF_Yaw_3 <- sum(freq3 * psd_Yaw_3) / sum(psd_Yaw_3)
  
  # then calc power between CF -3 and CF + 3
  PTB_Rel_AP_1 <- sum(psd_ap_1[which(freq1 >= CF_AP_1 - 3 & freq1 <= CF_AP_1 + 3)])
  PTB_Rel_AP_2 <- sum(psd_ap_2[which(freq2 >= CF_AP_2 - 3 & freq2 <= CF_AP_2 + 3)])
  PTB_Rel_AP_3 <- sum(psd_ap_3[which(freq3 >= CF_AP_3 - 3 & freq3 <= CF_AP_3 + 3)])

  PTB_Rel_ML_1 <- sum(psd_ml_1[which(freq1 >= CF_ML_1 - 3 & freq1 <= CF_ML_1 + 3)])
  PTB_Rel_ML_2 <- sum(psd_ml_2[which(freq2 >= CF_ML_2 - 3 & freq2 <= CF_ML_2 + 3)])
  PTB_Rel_ML_3 <- sum(psd_ml_3[which(freq3 >= CF_ML_3 - 3 & freq3 <= CF_ML_3 + 3)])
  
  PTB_Rel_VT_1 <- sum(psd_VT_1[which(freq1 >= CF_VT_1 - 3 & freq1 <= CF_VT_1 + 3)])
  PTB_Rel_VT_2 <- sum(psd_VT_2[which(freq2 >= CF_VT_2 - 3 & freq2 <= CF_VT_2 + 3)])
  PTB_Rel_VT_3 <- sum(psd_VT_3[which(freq3 >= CF_VT_3 - 3 & freq3 <= CF_VT_3 + 3)])

  PTB_Rel_Pitch_1 <- sum(psd_pi_1[which(freq1 >= CF_Pitch_1 - 3 & freq1 <= CF_Pitch_1 + 3)])
  PTB_Rel_Pitch_2 <- sum(psd_pi_2[which(freq2 >= CF_Pitch_2 - 3 & freq2 <= CF_Pitch_2 + 3)])
  PTB_Rel_Pitch_3 <- sum(psd_pi_3[which(freq3 >= CF_Pitch_3 - 3 & freq3 <= CF_Pitch_3 + 3)])
  
  PTB_Rel_Roll_1 <- sum(psd_Roll_1[which(freq1 >= CF_Roll_1 - 3 & freq1 <= CF_Roll_1 + 3)])
  PTB_Rel_Roll_2 <- sum(psd_Roll_2[which(freq2 >= CF_Roll_2 - 3 & freq2 <= CF_Roll_2 + 3)])
  PTB_Rel_Roll_3 <- sum(psd_Roll_3[which(freq3 >= CF_Roll_3 - 3 & freq3 <= CF_Roll_3 + 3)])
  
  PTB_Rel_Yaw_1 <- sum(psd_Yaw_1[which(freq1 >= CF_Yaw_1 - 3 & freq1 <= CF_Yaw_1 + 3)])
  PTB_Rel_Yaw_2 <- sum(psd_Yaw_2[which(freq2 >= CF_Yaw_2 - 3 & freq2 <= CF_Yaw_2 + 3)])
  PTB_Rel_Yaw_3 <- sum(psd_Yaw_3[which(freq3 >= CF_Yaw_3 - 3 & freq3 <= CF_Yaw_3 + 3)])

  
  # then calc total power
  PTB_Tot_AP_1 <- sum(psd_ap_1[which(freq1 >= 0 & freq1 <= 25)])
  PTB_Tot_AP_2 <- sum(psd_ap_2[which(freq2 >= 0 & freq2 <= 25)])
  PTB_Tot_AP_3 <- sum(psd_ap_3[which(freq3 >= 0 & freq3 <= 25)])

  PTB_Tot_ML_1 <- sum(psd_ml_1[which(freq1 >= 0 & freq1 <= 25)])
  PTB_Tot_ML_2 <- sum(psd_ml_2[which(freq2 >= 0 & freq2 <= 25)])
  PTB_Tot_ML_3 <- sum(psd_ml_3[which(freq3 >= 0 & freq3 <= 25)])
  
  PTB_Tot_VT_1 <- sum(psd_VT_1[which(freq1 >= 0 & freq1 <= 25)])
  PTB_Tot_VT_2 <- sum(psd_VT_2[which(freq2 >= 0 & freq2 <= 25)])
  PTB_Tot_VT_3 <- sum(psd_VT_3[which(freq3 >= 0 & freq3 <= 25)])

  PTB_Tot_Pitch_1 <- sum(psd_pi_1[which(freq1 >= 0 & freq1 <= 25)])
  PTB_Tot_Pitch_2 <- sum(psd_pi_2[which(freq2 >= 0 & freq2 <= 25)])
  PTB_Tot_Pitch_3 <- sum(psd_pi_3[which(freq3 >= 0 & freq3 <= 25)])
  
  PTB_Tot_Roll_1 <- sum(psd_Roll_1[which(freq1 >= 0 & freq1 <= 25)])
  PTB_Tot_Roll_2 <- sum(psd_Roll_2[which(freq2 >= 0 & freq2 <= 25)])
  PTB_Tot_Roll_3 <- sum(psd_Roll_3[which(freq3 >= 0 & freq3 <= 25)])
  
  PTB_Tot_Yaw_1 <- sum(psd_Yaw_1[which(freq1 >= 0 & freq1 <= 25)])
  PTB_Tot_Yaw_2 <- sum(psd_Yaw_2[which(freq2 >= 0 & freq2 <= 25)])
  PTB_Tot_Yaw_3 <- sum(psd_Yaw_3[which(freq3 >= 0 & freq3 <= 25)])


  # Average for the three pulls taking the ratio for Rel power
  features$PTB_Rel_AP[i] <- mean(c(PTB_Rel_AP_1/PTB_Tot_AP_1, 
                                   PTB_Rel_AP_2/PTB_Tot_AP_2, 
                                   PTB_Rel_AP_3/PTB_Tot_AP_3))
  features$PTB_Rel_ML[i] <- mean(c(PTB_Rel_ML_1/PTB_Tot_ML_1, 
                                   PTB_Rel_ML_2/PTB_Tot_ML_2, 
                                   PTB_Rel_ML_3/PTB_Tot_ML_3))
  features$PTB_Rel_VT[i] <- mean(c(PTB_Rel_VT_1/PTB_Tot_VT_1, 
                                   PTB_Rel_VT_2/PTB_Tot_VT_2, 
                                   PTB_Rel_VT_3/PTB_Tot_VT_3))
  features$PTB_Rel_Pitch[i] <- mean(c(PTB_Rel_Pitch_1/PTB_Tot_Pitch_1, 
                                      PTB_Rel_Pitch_2/PTB_Tot_Pitch_2,
                                      PTB_Rel_Pitch_3/PTB_Tot_Pitch_3))
  features$PTB_Rel_Roll[i] <- mean(c(PTB_Rel_Roll_1/PTB_Tot_Roll_1, 
                                   PTB_Rel_Roll_2/PTB_Tot_Roll_2, 
                                   PTB_Rel_Roll_3/PTB_Tot_Roll_3))
  features$PTB_Rel_Yaw[i] <- mean(c(PTB_Rel_Yaw_1/PTB_Tot_Yaw_1, 
                                   PTB_Rel_Yaw_2/PTB_Tot_Yaw_2, 
                                   PTB_Rel_Yaw_3/PTB_Tot_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PTB_Rel_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
PTB_Rel_AP_HYclass2 <- features$PTB_Rel_AP[features$HYclass == group_A]
PTB_Rel_AP_HYclass3 <- features$PTB_Rel_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PTB_Rel_AP <- wilcox.test(PTB_Rel_AP_HYclass2, PTB_Rel_AP_HYclass3)$p.value

```

```{r PTB_Rel_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PTB_Rel_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PTB_Rel_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PTB_Rel_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PTB_Rel_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_PTB_Rel_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PTB_Rel_ML_HYclass2 <- features$PTB_Rel_ML[features$HYclass == group_A]
PTB_Rel_ML_HYclass3 <- features$PTB_Rel_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PTB_Rel_ML <- wilcox.test(PTB_Rel_ML_HYclass2, PTB_Rel_ML_HYclass3)$p.value

```

```{r PTB_Rel_ML_plot_ML, echo=FALSE}

boxplot(PTB_Rel_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PTB_Rel_ML",
        #ylim = c(0,1.6),
        main = "Relative Power in Tremor band - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PTB_Rel_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PTB_Rel_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PTB_Rel_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PTB_Rel_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PTB_Rel_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PTB_Rel_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PTB_Rel_VT_HYclass2 <- features$PTB_Rel_VT[features$HYclass == group_A]
PTB_Rel_VT_HYclass3 <- features$PTB_Rel_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PTB_Rel_VT <- wilcox.test(PTB_Rel_VT_HYclass2, PTB_Rel_VT_HYclass3)$p.value

```

```{r PTB_Rel_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PTB_Rel_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PTB_Rel_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PTB_Rel_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PTB_Rel_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch (AV)

```{r Mann-Whitney-U-test_PTB_Rel_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PTB_Rel_Pitch_HYclass2 <- features$PTB_Rel_Pitch[features$HYclass == group_A]
PTB_Rel_Pitch_HYclass3 <- features$PTB_Rel_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PTB_Rel_Pitch <- 
  wilcox.test(PTB_Rel_Pitch_HYclass2, PTB_Rel_Pitch_HYclass3)$p.value

```

```{r PTB_Rel_plot_Pitch, echo=FALSE}

boxplot(PTB_Rel_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PTB_Rel_Pitch",
        main = "Relative Power in Tremor band - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```


```{r PTB_Rel_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PTB_Rel_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PTB_Rel_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PTB_Rel_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PTB_Rel_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PTB_Rel_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PTB_Rel_Roll_HYclass2 <- features$PTB_Rel_Roll[features$HYclass == group_A]
PTB_Rel_Roll_HYclass3 <- features$PTB_Rel_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PTB_Rel_Roll <- wilcox.test(PTB_Rel_Roll_HYclass2, PTB_Rel_Roll_HYclass3)$p.value

```

```{r PTB_Rel_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PTB_Rel_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PTB_Rel_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PTB_Rel_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PTB_Rel_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PTB_Rel_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PTB_Rel_Yaw_HYclass2 <- features$PTB_Rel_Yaw[features$HYclass == group_A]
PTB_Rel_Yaw_HYclass3 <- features$PTB_Rel_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PTB_Rel_Yaw <- wilcox.test(PTB_Rel_Yaw_HYclass2, PTB_Rel_Yaw_HYclass3)$p.value

```

```{r PTB_Rel_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PTB_Rel_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PTB_Rel_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PTB_Rel_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PTB_Rel_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Peak Power 3 - 10 Hz

```{r Peak_Power_3_10, echo = FALSE}
features$PP_3_10_AP <- NA
features$PP_3_10_ML <- NA
features$PP_3_10_VT <- NA
features$PP_3_10_Pitch <- NA
features$PP_3_10_Roll <- NA
features$PP_3_10_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate peak power between 3 & 10 Hz
  
  PP_AP_1 <- max(psd_ap_1[which(freq1 >= 3 & freq1 <= 10)])
  PP_AP_2 <- max(psd_ap_2[which(freq2 >= 3 & freq2 <= 10)])
  PP_AP_3 <- max(psd_ap_3[which(freq3 >= 3 & freq3 <= 10)])
  
  PP_ML_1 <- max(psd_ml_1[which(freq1 >= 3 & freq1 <= 10)])
  PP_ML_2 <- max(psd_ml_2[which(freq2 >= 3 & freq2 <= 10)])
  PP_ML_3 <- max(psd_ml_3[which(freq3 >= 3 & freq3 <= 10)])
  
  PP_VT_1 <- max(psd_VT_1[which(freq1 >= 3 & freq1 <= 10)])
  PP_VT_2 <- max(psd_VT_2[which(freq2 >= 3 & freq2 <= 10)])
  PP_VT_3 <- max(psd_VT_3[which(freq3 >= 3 & freq3 <= 10)])
  
  PP_Pitch_1 <- max(psd_pi_1[which(freq1 >= 3 & freq1 <= 10)])
  PP_Pitch_2 <- max(psd_pi_2[which(freq2 >= 3 & freq2 <= 10)])
  PP_Pitch_3 <- max(psd_pi_3[which(freq3 >= 3 & freq3 <= 10)])
  
  PP_Roll_1 <- max(psd_Roll_1[which(freq1 >= 3 & freq1 <= 10)])
  PP_Roll_2 <- max(psd_Roll_2[which(freq2 >= 3 & freq2 <= 10)])
  PP_Roll_3 <- max(psd_Roll_3[which(freq3 >= 3 & freq3 <= 10)])
  
  PP_Yaw_1 <- max(psd_Yaw_1[which(freq1 >= 3 & freq1 <= 10)])
  PP_Yaw_2 <- max(psd_Yaw_2[which(freq2 >= 3 & freq2 <= 10)])
  PP_Yaw_3 <- max(psd_Yaw_3[which(freq3 >= 3 & freq3 <= 10)])

  # Average for the three pulls
  features$PP_3_10_AP[i] <- mean(c(PP_AP_1, PP_AP_2, PP_AP_3))
  features$PP_3_10_ML[i] <- mean(c(PP_ML_1, PP_ML_2, PP_ML_3))
  features$PP_3_10_VT[i] <- mean(c(PP_VT_1, PP_VT_2, PP_VT_3))
  features$PP_3_10_Pitch[i] <- mean(c(PP_Pitch_1, PP_Pitch_2, PP_Pitch_3))
  features$PP_3_10_Roll[i] <- mean(c(PP_Roll_1, PP_Roll_2, PP_Roll_3))
  features$PP_3_10_Yaw[i] <- mean(c(PP_Yaw_1, PP_Yaw_2, PP_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PP_3_10_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_3_10_AP_HYclass2 <- features$PP_3_10_AP[features$HYclass == group_A]
PP_3_10_AP_HYclass3 <- features$PP_3_10_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_3_10_AP <- 
  wilcox.test(PP_3_10_AP_HYclass2, PP_3_10_AP_HYclass3)$p.value

```


```{r PP_3_10_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_3_10_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_3_10_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_3_10_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_3_10_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```



### Mediolateral

```{r Mann-Whitney-U-test_PP_3_10_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_3_10_ML_HYclass2 <- features$PP_3_10_ML[features$HYclass == group_A]
PP_3_10_ML_HYclass3 <- features$PP_3_10_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_3_10_ML <- 
  wilcox.test(PP_3_10_ML_HYclass2, PP_3_10_ML_HYclass3)$p.value

```

```{r PP_3_10_ML_plot_ML, echo=FALSE}

boxplot(PP_3_10_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PP_3_10_ML",
        #ylim = c(0,1.6),
        main = "Peak Power 3 - 10 Hz - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PP_3_10_ML_plot_ML_no_outlier, echo=FALSE}

boxplot(PP_3_10_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PP_3_10_ML",
        outline = FALSE,
        main = "Peak Power 3 - 10 Hz - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PP_3_10_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_3_10_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_3_10_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_3_10_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_3_10_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PP_3_10_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_3_10_VT_HYclass2 <- features$PP_3_10_VT[features$HYclass == group_A]
PP_3_10_VT_HYclass3 <- features$PP_3_10_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_3_10_VT <- 
  wilcox.test(PP_3_10_VT_HYclass2, PP_3_10_VT_HYclass3)$p.value

```


```{r PP_3_10_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_3_10_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_3_10_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_3_10_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_3_10_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch (AV)

```{r Mann-Whitney-U-test_PP_3_10_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_3_10_Pitch_HYclass2 <- features$PP_3_10_Pitch[features$HYclass == group_A]
PP_3_10_Pitch_HYclass3 <- features$PP_3_10_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_3_10_Pitch <- 
  wilcox.test(PP_3_10_Pitch_HYclass2, PP_3_10_Pitch_HYclass3)$p.value

```

```{r PP_3_10_plot_Pitch, echo=FALSE}

boxplot(PP_3_10_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PP_3_10_Pitch",
        main = "Peak Power 3 - 10 Hz - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PP_3_10_plot_Pitch_no_outlier, echo=FALSE}

boxplot(PP_3_10_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PP_3_10_Pitch",
        outline = FALSE,
        main = "Peak Power 3 - 10 Hz - Pitch (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PP_3_10_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_3_10_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_3_10_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_3_10_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_3_10_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PP_3_10_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_3_10_Roll_HYclass2 <- features$PP_3_10_Roll[features$HYclass == group_A]
PP_3_10_Roll_HYclass3 <- features$PP_3_10_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_3_10_Roll <- 
  wilcox.test(PP_3_10_Roll_HYclass2, PP_3_10_Roll_HYclass3)$p.value

```


```{r PP_3_10_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_3_10_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_3_10_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_3_10_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_3_10_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PP_3_10_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_3_10_Yaw_HYclass2 <- features$PP_3_10_Yaw[features$HYclass == group_A]
PP_3_10_Yaw_HYclass3 <- features$PP_3_10_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_3_10_Yaw <- 
  wilcox.test(PP_3_10_Yaw_HYclass2, PP_3_10_Yaw_HYclass3)$p.value

```


```{r PP_3_10_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_3_10_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_3_10_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_3_10_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_3_10_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Peak Power 8 - 12 Hz


```{r Peak_Power_8_12, echo = FALSE}
features$PP_8_12_AP <- NA
features$PP_8_12_ML <- NA
features$PP_8_12_VT <- NA
features$PP_8_12_Pitch <- NA
features$PP_8_12_Roll <- NA
features$PP_8_12_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate peak power between 3 & 10 Hz
  
  PP_AP_1 <- max(psd_ap_1[which(freq1 >= 8 & freq1 <= 12)])
  PP_AP_2 <- max(psd_ap_2[which(freq2 >= 8 & freq2 <= 12)])
  PP_AP_3 <- max(psd_ap_3[which(freq3 >= 8 & freq3 <= 12)])
  
  PP_ML_1 <- max(psd_ml_1[which(freq1 >= 8 & freq1 <= 12)])
  PP_ML_2 <- max(psd_ml_2[which(freq2 >= 8 & freq2 <= 12)])
  PP_ML_3 <- max(psd_ml_3[which(freq3 >= 8 & freq3 <= 12)])
  
  PP_VT_1 <- max(psd_VT_1[which(freq1 >= 8 & freq1 <= 12)])
  PP_VT_2 <- max(psd_VT_2[which(freq2 >= 8 & freq2 <= 12)])
  PP_VT_3 <- max(psd_VT_3[which(freq3 >= 8 & freq3 <= 12)])
  
  PP_Pitch_1 <- max(psd_pi_1[which(freq1 >= 8 & freq1 <= 12)])
  PP_Pitch_2 <- max(psd_pi_2[which(freq2 >= 8 & freq2 <= 12)])
  PP_Pitch_3 <- max(psd_pi_3[which(freq3 >= 8 & freq3 <= 12)])
  
  PP_Roll_1 <- max(psd_Roll_1[which(freq1 >= 8 & freq1 <= 12)])
  PP_Roll_2 <- max(psd_Roll_2[which(freq2 >= 8 & freq2 <= 12)])
  PP_Roll_3 <- max(psd_Roll_3[which(freq3 >= 8 & freq3 <= 12)])
  
  PP_Yaw_1 <- max(psd_Yaw_1[which(freq1 >= 8 & freq1 <= 12)])
  PP_Yaw_2 <- max(psd_Yaw_2[which(freq2 >= 8 & freq2 <= 12)])
  PP_Yaw_3 <- max(psd_Yaw_3[which(freq3 >= 8 & freq3 <= 12)])

  # Average for the three pulls
  features$PP_8_12_AP[i] <- mean(c(PP_AP_1, PP_AP_2, PP_AP_3))
  features$PP_8_12_ML[i] <- mean(c(PP_ML_1, PP_ML_2, PP_ML_3))
  features$PP_8_12_VT[i] <- mean(c(PP_VT_1, PP_VT_2, PP_VT_3))
  features$PP_8_12_Pitch[i] <- mean(c(PP_Pitch_1, PP_Pitch_2, PP_Pitch_3))
  features$PP_8_12_Roll[i] <- mean(c(PP_Roll_1, PP_Roll_2, PP_Roll_3))
  features$PP_8_12_Yaw[i] <- mean(c(PP_Yaw_1, PP_Yaw_2, PP_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PP_8_12_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_8_12_AP_HYclass2 <- features$PP_8_12_AP[features$HYclass == group_A]
PP_8_12_AP_HYclass3 <- features$PP_8_12_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_8_12_AP <- 
  wilcox.test(PP_8_12_AP_HYclass2, PP_8_12_AP_HYclass3)$p.value

```


```{r PP_8_12_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_8_12_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_8_12_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_8_12_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_8_12_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```



### Mediolateral

```{r Mann-Whitney-U-test_PP_8_12_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_8_12_ML_HYclass2 <- features$PP_8_12_ML[features$HYclass == group_A]
PP_8_12_ML_HYclass3 <- features$PP_8_12_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_8_12_ML <- 
  wilcox.test(PP_8_12_ML_HYclass2, PP_8_12_ML_HYclass3)$p.value

```

```{r PP_8_12_ML_plot_ML, echo=FALSE}

boxplot(PP_8_12_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PP_8_12_ML",
        #ylim = c(0,1.6),
        main = "Peak Power 3 - 10 Hz - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PP_8_12_ML_plot_ML_no_outlier, echo=FALSE}

boxplot(PP_8_12_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PP_8_12_ML",
        outline = FALSE,
        main = "Peak Power 3 - 10 Hz - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PP_8_12_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_8_12_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_8_12_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_8_12_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_8_12_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PP_8_12_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_8_12_VT_HYclass2 <- features$PP_8_12_VT[features$HYclass == group_A]
PP_8_12_VT_HYclass3 <- features$PP_8_12_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_8_12_VT <- 
  wilcox.test(PP_8_12_VT_HYclass2, PP_8_12_VT_HYclass3)$p.value

```


```{r PP_8_12_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_8_12_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_8_12_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_8_12_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_8_12_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch (AV)

```{r Mann-Whitney-U-test_PP_8_12_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_8_12_Pitch_HYclass2 <- features$PP_8_12_Pitch[features$HYclass == group_A]
PP_8_12_Pitch_HYclass3 <- features$PP_8_12_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_8_12_Pitch <- 
  wilcox.test(PP_8_12_Pitch_HYclass2, PP_8_12_Pitch_HYclass3)$p.value

```

```{r PP_8_12_plot_Pitch, echo=FALSE}

boxplot(PP_8_12_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PP_8_12_Pitch",
        main = "Peak Power 3 - 10 Hz - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PP_8_12_plot_Pitch_no_outlier, echo=FALSE}

boxplot(PP_8_12_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PP_8_12_Pitch",
        outline = FALSE,
        main = "Peak Power 3 - 10 Hz - Pitch (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PP_8_12_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_8_12_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_8_12_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_8_12_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_8_12_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PP_8_12_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_8_12_Roll_HYclass2 <- features$PP_8_12_Roll[features$HYclass == group_A]
PP_8_12_Roll_HYclass3 <- features$PP_8_12_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_8_12_Roll <- 
  wilcox.test(PP_8_12_Roll_HYclass2, PP_8_12_Roll_HYclass3)$p.value

```


```{r PP_8_12_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_8_12_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_8_12_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_8_12_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_8_12_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PP_8_12_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_8_12_Yaw_HYclass2 <- features$PP_8_12_Yaw[features$HYclass == group_A]
PP_8_12_Yaw_HYclass3 <- features$PP_8_12_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_8_12_Yaw <- 
  wilcox.test(PP_8_12_Yaw_HYclass2, PP_8_12_Yaw_HYclass3)$p.value

```


```{r PP_8_12_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_8_12_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_8_12_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_8_12_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_8_12_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Peak Power 0 - 16 Hz


```{r Peak_Power_0_16, echo = FALSE}
features$PP_0_16_AP <- NA
features$PP_0_16_ML <- NA
features$PP_0_16_VT <- NA
features$PP_0_16_Pitch <- NA
features$PP_0_16_Roll <- NA
features$PP_0_16_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # Calculate peak power between 3 & 10 Hz
  
  PP_AP_1 <- max(psd_ap_1[which(freq1 >= 0 & freq1 <= 16)])
  PP_AP_2 <- max(psd_ap_2[which(freq2 >= 0 & freq2 <= 16)])
  PP_AP_3 <- max(psd_ap_3[which(freq3 >= 0 & freq3 <= 16)])
  
  PP_ML_1 <- max(psd_ml_1[which(freq1 >= 0 & freq1 <= 16)])
  PP_ML_2 <- max(psd_ml_2[which(freq2 >= 0 & freq2 <= 16)])
  PP_ML_3 <- max(psd_ml_3[which(freq3 >= 0 & freq3 <= 16)])
  
  PP_VT_1 <- max(psd_VT_1[which(freq1 >= 0 & freq1 <= 16)])
  PP_VT_2 <- max(psd_VT_2[which(freq2 >= 0 & freq2 <= 16)])
  PP_VT_3 <- max(psd_VT_3[which(freq3 >= 0 & freq3 <= 16)])
  
  PP_Pitch_1 <- max(psd_pi_1[which(freq1 >= 0 & freq1 <= 16)])
  PP_Pitch_2 <- max(psd_pi_2[which(freq2 >= 0 & freq2 <= 16)])
  PP_Pitch_3 <- max(psd_pi_3[which(freq3 >= 0 & freq3 <= 16)])
  
  PP_Roll_1 <- max(psd_Roll_1[which(freq1 >= 0 & freq1 <= 16)])
  PP_Roll_2 <- max(psd_Roll_2[which(freq2 >= 0 & freq2 <= 16)])
  PP_Roll_3 <- max(psd_Roll_3[which(freq3 >= 0 & freq3 <= 16)])
  
  PP_Yaw_1 <- max(psd_Yaw_1[which(freq1 >= 0 & freq1 <= 16)])
  PP_Yaw_2 <- max(psd_Yaw_2[which(freq2 >= 0 & freq2 <= 16)])
  PP_Yaw_3 <- max(psd_Yaw_3[which(freq3 >= 0 & freq3 <= 16)])

  # Average for the three pulls
  features$PP_0_16_AP[i] <- mean(c(PP_AP_1, PP_AP_2, PP_AP_3))
  features$PP_0_16_ML[i] <- mean(c(PP_ML_1, PP_ML_2, PP_ML_3))
  features$PP_0_16_VT[i] <- mean(c(PP_VT_1, PP_VT_2, PP_VT_3))
  features$PP_0_16_Pitch[i] <- mean(c(PP_Pitch_1, PP_Pitch_2, PP_Pitch_3))
  features$PP_0_16_Roll[i] <- mean(c(PP_Roll_1, PP_Roll_2, PP_Roll_3))
  features$PP_0_16_Yaw[i] <- mean(c(PP_Yaw_1, PP_Yaw_2, PP_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_PP_0_16_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_0_16_AP_HYclass2 <- features$PP_0_16_AP[features$HYclass == group_A]
PP_0_16_AP_HYclass3 <- features$PP_0_16_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_0_16_AP <- 
  wilcox.test(PP_0_16_AP_HYclass2, PP_0_16_AP_HYclass3)$p.value

```


```{r PP_0_16_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_0_16_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_0_16_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_0_16_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_0_16_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```



### Mediolateral

```{r Mann-Whitney-U-test_PP_0_16_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_0_16_ML_HYclass2 <- features$PP_0_16_ML[features$HYclass == group_A]
PP_0_16_ML_HYclass3 <- features$PP_0_16_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_0_16_ML <- 
  wilcox.test(PP_0_16_ML_HYclass2, PP_0_16_ML_HYclass3)$p.value

```

```{r PP_0_16_ML_plot_ML, echo=FALSE}

boxplot(PP_0_16_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PP_0_16_ML",
        #ylim = c(0,1.6),
        main = "Peak Power 3 - 10 Hz - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PP_0_16_ML_plot_ML_no_outlier, echo=FALSE}

boxplot(PP_0_16_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PP_0_16_ML",
        outline = FALSE,
        main = "Peak Power 3 - 10 Hz - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PP_0_16_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_0_16_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_0_16_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_0_16_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_0_16_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_PP_0_16_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_0_16_VT_HYclass2 <- features$PP_0_16_VT[features$HYclass == group_A]
PP_0_16_VT_HYclass3 <- features$PP_0_16_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_0_16_VT <- 
  wilcox.test(PP_0_16_VT_HYclass2, PP_0_16_VT_HYclass3)$p.value

```


```{r PP_0_16_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_0_16_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_0_16_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_0_16_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_0_16_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch (AV)

```{r Mann-Whitney-U-test_PP_0_16_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_0_16_Pitch_HYclass2 <- features$PP_0_16_Pitch[features$HYclass == group_A]
PP_0_16_Pitch_HYclass3 <- features$PP_0_16_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_0_16_Pitch <- 
  wilcox.test(PP_0_16_Pitch_HYclass2, PP_0_16_Pitch_HYclass3)$p.value

```

```{r PP_0_16_plot_Pitch, echo=FALSE}

boxplot(PP_0_16_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PP_0_16_Pitch",
        main = "Peak Power 3 - 10 Hz - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PP_0_16_plot_Pitch_no_outlier, echo=FALSE}

boxplot(PP_0_16_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "PP_0_16_Pitch",
        outline = FALSE,
        main = "Peak Power 3 - 10 Hz - Pitch (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r PP_0_16_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_0_16_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_0_16_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_0_16_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_0_16_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_PP_0_16_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_0_16_Roll_HYclass2 <- features$PP_0_16_Roll[features$HYclass == group_A]
PP_0_16_Roll_HYclass3 <- features$PP_0_16_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_0_16_Roll <- 
  wilcox.test(PP_0_16_Roll_HYclass2, PP_0_16_Roll_HYclass3)$p.value

```


```{r PP_0_16_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_0_16_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_0_16_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_0_16_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_0_16_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_PP_0_16_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
PP_0_16_Yaw_HYclass2 <- features$PP_0_16_Yaw[features$HYclass == group_A]
PP_0_16_Yaw_HYclass3 <- features$PP_0_16_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$PP_0_16_Yaw <- 
  wilcox.test(PP_0_16_Yaw_HYclass2, PP_0_16_Yaw_HYclass3)$p.value

```


```{r PP_0_16_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$PP_0_16_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$PP_0_16_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$PP_0_16_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$PP_0_16_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Mean Power 0 - 16 Hz

```{r Mean_Power_0_16, echo = FALSE}
features$MP_0_16_AP <- NA
features$MP_0_16_ML <- NA
features$MP_0_16_VT <- NA
features$MP_0_16_Pitch <- NA
features$MP_0_16_Roll <- NA
features$MP_0_16_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2

  # calculate mean power between 0 and 16 Hz
  MP_AP_1 <- mean(psd_ap_1[which(freq1 >= 0 & freq1 <= 16)])
  MP_AP_2 <- mean(psd_ap_2[which(freq2 >= 0 & freq2 <= 16)])
  MP_AP_3 <- mean(psd_ap_3[which(freq3 >= 0 & freq3 <= 16)])

  MP_ML_1 <- mean(psd_ml_1[which(freq1 >= 0 & freq1 <= 16)])
  MP_ML_2 <- mean(psd_ml_2[which(freq2 >= 0 & freq2 <= 16)])
  MP_ML_3 <- mean(psd_ml_3[which(freq3 >= 0 & freq3 <= 16)])
  
  MP_VT_1 <- mean(psd_VT_1[which(freq1 >= 0 & freq1 <= 16)])
  MP_VT_2 <- mean(psd_VT_2[which(freq2 >= 0 & freq2 <= 16)])
  MP_VT_3 <- mean(psd_VT_3[which(freq3 >= 0 & freq3 <= 16)])
  
  MP_Pitch_1 <- mean(psd_pi_1[which(freq1 >= 0 & freq1 <= 16)])
  MP_Pitch_2 <- mean(psd_pi_2[which(freq2 >= 0 & freq2 <= 16)])
  MP_Pitch_3 <- mean(psd_pi_3[which(freq3 >= 0 & freq3 <= 16)])
  
  MP_Roll_1 <- mean(psd_Roll_1[which(freq1 >= 0 & freq1 <= 16)])
  MP_Roll_2 <- mean(psd_Roll_2[which(freq2 >= 0 & freq2 <= 16)])
  MP_Roll_3 <- mean(psd_Roll_3[which(freq3 >= 0 & freq3 <= 16)])
  
  MP_Yaw_1 <- mean(psd_Yaw_1[which(freq1 >= 0 & freq1 <= 16)])
  MP_Yaw_2 <- mean(psd_Yaw_2[which(freq2 >= 0 & freq2 <= 16)])
  MP_Yaw_3 <- mean(psd_Yaw_3[which(freq3 >= 0 & freq3 <= 16)])

  # Average for the three pulls
  features$MP_0_16_AP[i] <- mean(c(MP_AP_1, MP_AP_2, MP_AP_3))
  features$MP_0_16_ML[i] <- mean(c(MP_ML_1, MP_ML_2, MP_ML_3))
  features$MP_0_16_VT[i] <- mean(c(MP_VT_1, MP_VT_2, MP_VT_3))
  features$MP_0_16_Pitch[i] <- mean(c(MP_Pitch_1, MP_Pitch_2, MP_Pitch_3))
  features$MP_0_16_Roll[i] <- mean(c(MP_Roll_1, MP_Roll_2, MP_Roll_3))
  features$MP_0_16_Yaw[i] <- mean(c(MP_Yaw_1, MP_Yaw_2, MP_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_MP_0_16_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
MP_0_16_AP_HYclass2 <- features$MP_0_16_AP[features$HYclass == group_A]
MP_0_16_AP_HYclass3 <- features$MP_0_16_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MP_0_16_AP <- wilcox.test(MP_0_16_AP_HYclass2, MP_0_16_AP_HYclass3)$p.value

```

```{r MP_0_16_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MP_0_16_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MP_0_16_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MP_0_16_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MP_0_16_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Mediolateral

```{r Mann-Whitney-U-test_MP_0_16_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
MP_0_16_ML_HYclass2 <- features$MP_0_16_ML[features$HYclass == group_A]
MP_0_16_ML_HYclass3 <- features$MP_0_16_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MP_0_16_ML <- wilcox.test(MP_0_16_ML_HYclass2, MP_0_16_ML_HYclass3)$p.value

```

```{r MP_0_16_ML_plot_ML, echo=FALSE}

boxplot(MP_0_16_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "MP_0_16_ML",
        #ylim = c(0,1.6),
        main = "Mean Power 0 - 16 Hz - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r MP_0_16_ML_plot_ML_no_outlier, echo=FALSE}

boxplot(MP_0_16_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "MP_0_16_ML",
        outline = FALSE,
        main = "Mean Power 0 - 16 Hz - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r MP_0_16_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MP_0_16_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MP_0_16_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MP_0_16_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MP_0_16_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_MP_0_16_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
MP_0_16_VT_HYclass2 <- features$MP_0_16_VT[features$HYclass == group_A]
MP_0_16_VT_HYclass3 <- features$MP_0_16_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MP_0_16_VT <- wilcox.test(MP_0_16_VT_HYclass2, MP_0_16_VT_HYclass3)$p.value

```

```{r MP_0_16_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MP_0_16_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MP_0_16_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MP_0_16_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MP_0_16_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch (AV)

```{r Mann-Whitney-U-test_MP_0_16_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
MP_0_16_Pitch_HYclass2 <- features$MP_0_16_Pitch[features$HYclass == group_A]
MP_0_16_Pitch_HYclass3 <- features$MP_0_16_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MP_0_16_Pitch <- 
  wilcox.test(MP_0_16_Pitch_HYclass2, MP_0_16_Pitch_HYclass3)$p.value

```

```{r MP_0_16_plot_Pitch, echo=FALSE}

boxplot(MP_0_16_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "MP_0_16_Pitch",
        main = "Mean Power 0 - 16 Hz - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r MP_0_16_plot_Pitch_no_outlier, echo=FALSE}

boxplot(MP_0_16_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "M_0_16_Pitch",
        outline = FALSE,
        main = "Mean Power 0 - 16 Hz - Pitch (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r MP_0_16_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MP_0_16_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MP_0_16_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MP_0_16_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MP_0_16_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Roll

```{r Mann-Whitney-U-test_MP_0_16_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
MP_0_16_Roll_HYclass2 <- features$MP_0_16_Roll[features$HYclass == group_A]
MP_0_16_Roll_HYclass3 <- features$MP_0_16_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MP_0_16_Roll <- wilcox.test(MP_0_16_Roll_HYclass2, MP_0_16_Roll_HYclass3)$p.value

```

```{r MP_0_16_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MP_0_16_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MP_0_16_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MP_0_16_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MP_0_16_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_MP_0_16_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
MP_0_16_Yaw_HYclass2 <- features$MP_0_16_Yaw[features$HYclass == group_A]
MP_0_16_Yaw_HYclass3 <- features$MP_0_16_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MP_0_16_Yaw <- wilcox.test(MP_0_16_Yaw_HYclass2, MP_0_16_Yaw_HYclass3)$p.value

```

```{r MP_0_16_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MP_0_16_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MP_0_16_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MP_0_16_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MP_0_16_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Centroidal Frequency Power 0 - 16 Hz

```{r CF_Power_0_16, echo = FALSE}
features$CFP_0_16_AP <- NA
features$CFP_0_16_ML <- NA
features$CFP_0_16_VT <- NA
features$CFP_0_16_Pitch <- NA
features$CFP_0_16_Roll <- NA
features$CFP_0_16_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2
  
  # restrict range to 0 to 16 Hz
  range_indices_ap_1 <- which(freq1 >= 0 & freq1 <= 16)
  range_indices_ap_2 <- which(freq2 >= 0 & freq2 <= 16)
  range_indices_ap_3 <- which(freq3 >= 0 & freq3 <= 16)
  
  range_indices_ml_1 <- which(freq1 >= 0 & freq1 <= 16)
  range_indices_ml_2 <- which(freq2 >= 0 & freq2 <= 16)
  range_indices_ml_3 <- which(freq3 >= 0 & freq3 <= 16)
  
  range_indices_VT_1 <- which(freq1 >= 0 & freq1 <= 16)
  range_indices_VT_2 <- which(freq2 >= 0 & freq2 <= 16)
  range_indices_VT_3 <- which(freq3 >= 0 & freq3 <= 16)
  
  range_indices_pi_1 <- which(freq1 >= 0 & freq1 <= 16)
  range_indices_pi_2 <- which(freq2 >= 0 & freq2 <= 16)
  range_indices_pi_3 <- which(freq3 >= 0 & freq3 <= 16)
  
  range_indices_Roll_1 <- which(freq1 >= 0 & freq1 <= 16)
  range_indices_Roll_2 <- which(freq2 >= 0 & freq2 <= 16)
  range_indices_Roll_3 <- which(freq3 >= 0 & freq3 <= 16)
  
  range_indices_Yaw_1 <- which(freq1 >= 0 & freq1 <= 16)
  range_indices_Yaw_2 <- which(freq2 >= 0 & freq2 <= 16)
  range_indices_Yaw_3 <- which(freq3 >= 0 & freq3 <= 16)
  
  # get the centroidal frequency in this range
  CF_0_16_AP_1 <- sum(freq1[range_indices_ap_1] * psd_ap_1[range_indices_ap_1]) /
    sum(psd_ap_1[range_indices_ap_1])
  CF_0_16_AP_2 <- sum(freq2[range_indices_ap_2] * psd_ap_2[range_indices_ap_2]) /
    sum(psd_ap_2[range_indices_ap_2])
  CF_0_16_AP_3 <- sum(freq3[range_indices_ap_3] * psd_ap_3[range_indices_ap_3]) /
    sum(psd_ap_3[range_indices_ap_3])
  
  CF_0_16_ML_1 <- sum(freq1[range_indices_ml_1] * psd_ml_1[range_indices_ml_1]) /
    sum(psd_ml_1[range_indices_ml_1])
  CF_0_16_ML_2 <- sum(freq2[range_indices_ml_2] * psd_ml_2[range_indices_ml_2]) /
    sum(psd_ml_2[range_indices_ml_2])
  CF_0_16_ML_3 <- sum(freq3[range_indices_ml_3] * psd_ml_3[range_indices_ml_3]) /
    sum(psd_ml_3[range_indices_ml_3])
  
  CF_0_16_VT_1 <- sum(freq1[range_indices_VT_1] * psd_VT_1[range_indices_VT_1]) /
    sum(psd_VT_1[range_indices_VT_1])
  CF_0_16_VT_2 <- sum(freq2[range_indices_VT_2] * psd_VT_2[range_indices_VT_2]) /
    sum(psd_VT_2[range_indices_VT_2])
  CF_0_16_VT_3 <- sum(freq3[range_indices_VT_3] * psd_VT_3[range_indices_VT_3]) /
    sum(psd_VT_3[range_indices_VT_3])
  
  CF_0_16_Pitch_1 <- sum(freq1[range_indices_pi_1] * psd_pi_1[range_indices_pi_1]) /
    sum(psd_pi_1[range_indices_pi_1])
  CF_0_16_Pitch_2 <- sum(freq2[range_indices_pi_2] * psd_pi_2[range_indices_pi_2]) /
    sum(psd_pi_2[range_indices_pi_2])
  CF_0_16_Pitch_3 <- sum(freq3[range_indices_pi_3] * psd_pi_3[range_indices_pi_3]) /
    sum(psd_pi_3[range_indices_pi_3])
  
  CF_0_16_Roll_1 <- sum(freq1[range_indices_Roll_1] * psd_Roll_1[range_indices_Roll_1]) /
    sum(psd_Roll_1[range_indices_Roll_1])
  CF_0_16_Roll_2 <- sum(freq2[range_indices_Roll_2] * psd_Roll_2[range_indices_Roll_2]) /
    sum(psd_Roll_2[range_indices_Roll_2])
  CF_0_16_Roll_3 <- sum(freq3[range_indices_Roll_3] * psd_Roll_3[range_indices_Roll_3]) /
    sum(psd_Roll_3[range_indices_Roll_3])
  
  CF_0_16_Yaw_1 <- sum(freq1[range_indices_Yaw_1] * psd_Yaw_1[range_indices_Yaw_1]) /
    sum(psd_Yaw_1[range_indices_Yaw_1])
  CF_0_16_Yaw_2 <- sum(freq2[range_indices_Yaw_2] * psd_Yaw_2[range_indices_Yaw_2]) /
    sum(psd_Yaw_2[range_indices_Yaw_2])
  CF_0_16_Yaw_3 <- sum(freq3[range_indices_Yaw_3] * psd_Yaw_3[range_indices_Yaw_3]) /
    sum(psd_Yaw_3[range_indices_Yaw_3])
  
  # get index of the frequency bin closest to the CF
  index_CF_0_16_AP_1 <- which.min(abs(freq1 - CF_0_16_AP_1))
  index_CF_0_16_AP_2 <- which.min(abs(freq2 - CF_0_16_AP_2))
  index_CF_0_16_AP_3 <- which.min(abs(freq3 - CF_0_16_AP_3))
  
  index_CF_0_16_ML_1 <- which.min(abs(freq1 - CF_0_16_ML_1))
  index_CF_0_16_ML_2 <- which.min(abs(freq2 - CF_0_16_ML_2))
  index_CF_0_16_ML_3 <- which.min(abs(freq3 - CF_0_16_ML_3))
  
  index_CF_0_16_VT_1 <- which.min(abs(freq1 - CF_0_16_VT_1))
  index_CF_0_16_VT_2 <- which.min(abs(freq2 - CF_0_16_VT_2))
  index_CF_0_16_VT_3 <- which.min(abs(freq3 - CF_0_16_VT_3))
  
  index_CF_0_16_Pitch_1 <- which.min(abs(freq1 - CF_0_16_Pitch_1))
  index_CF_0_16_Pitch_2 <- which.min(abs(freq2 - CF_0_16_Pitch_2))
  index_CF_0_16_Pitch_3 <- which.min(abs(freq3 - CF_0_16_Pitch_3))
  
  index_CF_0_16_Roll_1 <- which.min(abs(freq1 - CF_0_16_Roll_1))
  index_CF_0_16_Roll_2 <- which.min(abs(freq2 - CF_0_16_Roll_2))
  index_CF_0_16_Roll_3 <- which.min(abs(freq3 - CF_0_16_Roll_3))
  
  index_CF_0_16_Yaw_1 <- which.min(abs(freq1 - CF_0_16_Yaw_1))
  index_CF_0_16_Yaw_2 <- which.min(abs(freq2 - CF_0_16_Yaw_2))
  index_CF_0_16_Yaw_3 <- which.min(abs(freq3 - CF_0_16_Yaw_3))

  # Get the PSD value at that frequency bin
  power_CF_0_16_AP_1 <- psd_ap_1[index_CF_0_16_AP_1]
  power_CF_0_16_AP_2 <- psd_ap_2[index_CF_0_16_AP_2]
  power_CF_0_16_AP_3 <- psd_ap_3[index_CF_0_16_AP_3]
  
  power_CF_0_16_ML_1 <- psd_ml_1[index_CF_0_16_ML_1]
  power_CF_0_16_ML_2 <- psd_ml_2[index_CF_0_16_ML_2]
  power_CF_0_16_ML_3 <- psd_ml_3[index_CF_0_16_ML_3]
  
  power_CF_0_16_VT_1 <- psd_VT_1[index_CF_0_16_VT_1]
  power_CF_0_16_VT_2 <- psd_VT_2[index_CF_0_16_VT_2]
  power_CF_0_16_VT_3 <- psd_VT_3[index_CF_0_16_VT_3]
  
  power_CF_0_16_Pitch_1 <- psd_pi_1[index_CF_0_16_Pitch_1]
  power_CF_0_16_Pitch_2 <- psd_pi_2[index_CF_0_16_Pitch_2]
  power_CF_0_16_Pitch_3 <- psd_pi_3[index_CF_0_16_Pitch_3]
  
  power_CF_0_16_Roll_1 <- psd_Roll_1[index_CF_0_16_Roll_1]
  power_CF_0_16_Roll_2 <- psd_Roll_2[index_CF_0_16_Roll_2]
  power_CF_0_16_Roll_3 <- psd_Roll_3[index_CF_0_16_Roll_3]
  
  power_CF_0_16_Yaw_1 <- psd_Yaw_1[index_CF_0_16_Yaw_1]
  power_CF_0_16_Yaw_2 <- psd_Yaw_2[index_CF_0_16_Yaw_2]
  power_CF_0_16_Yaw_3 <- psd_Yaw_3[index_CF_0_16_Yaw_3]
  
  # average the segments for each
  features$CFP_0_16_AP[i] <- mean(c(power_CF_0_16_AP_1, power_CF_0_16_AP_2, 
                                    power_CF_0_16_AP_3))
  features$CFP_0_16_ML[i] <- mean(c(power_CF_0_16_ML_1, power_CF_0_16_ML_2, 
                                    power_CF_0_16_ML_3))
  features$CFP_0_16_VT[i] <- mean(c(power_CF_0_16_VT_1, power_CF_0_16_VT_2, 
                                    power_CF_0_16_VT_3))
  features$CFP_0_16_Pitch[i] <- mean(c(power_CF_0_16_Pitch_1, power_CF_0_16_Pitch_2,
                                       power_CF_0_16_Pitch_3))
  features$CFP_0_16_Roll[i] <- mean(c(power_CF_0_16_Roll_1, power_CF_0_16_Roll_2, 
                                    power_CF_0_16_Roll_3))
  features$CFP_0_16_Yaw[i] <- mean(c(power_CF_0_16_Yaw_1, power_CF_0_16_Yaw_2, 
                                    power_CF_0_16_Yaw_3))

  
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_CFP_0_16_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_0_16_AP_HYclass2 <- features$CFP_0_16_AP[features$HYclass == group_A]
CFP_0_16_AP_HYclass3 <- features$CFP_0_16_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_0_16_AP <- 
  wilcox.test(CFP_0_16_AP_HYclass2, CFP_0_16_AP_HYclass3)$p.value

```


```{r CFP_0_16_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_0_16_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_0_16_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_0_16_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_0_16_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_CFP_0_16_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_0_16_ML_HYclass2 <- features$CFP_0_16_ML[features$HYclass == group_A]
CFP_0_16_ML_HYclass3 <- features$CFP_0_16_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_0_16_ML <- 
  wilcox.test(CFP_0_16_ML_HYclass2, CFP_0_16_ML_HYclass3)$p.value

```

```{r CFP_0_16_ML_plot_ML, echo=FALSE}

boxplot(CFP_0_16_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CFP_0_16_ML",
        #ylim = c(0,1.6),
        main = "Centroidal Frequency Power 0 - 16 Hz - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CFP_0_16_ML_plot_ML_no_outlier, echo=FALSE}

boxplot(CFP_0_16_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CFP_0_16_ML",
        outline = FALSE,
        main = "Centroidal Frequency Power 0 - 16 Hz - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CFP_0_16_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_0_16_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_0_16_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_0_16_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_0_16_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_CFP_0_16_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_0_16_VT_HYclass2 <- features$CFP_0_16_VT[features$HYclass == group_A]
CFP_0_16_VT_HYclass3 <- features$CFP_0_16_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_0_16_VT <- 
  wilcox.test(CFP_0_16_VT_HYclass2, CFP_0_16_VT_HYclass3)$p.value

```


```{r CFP_0_16_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_0_16_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_0_16_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_0_16_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_0_16_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch (AV) *

```{r Mann-Whitney-U-test_CFP_0_16_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_0_16_Pitch_HYclass2 <- features$CFP_0_16_Pitch[features$HYclass == group_A]
CFP_0_16_Pitch_HYclass3 <- features$CFP_0_16_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_0_16_Pitch <-
  wilcox.test(CFP_0_16_Pitch_HYclass2, CFP_0_16_Pitch_HYclass3)$p.value

```


```{r CFP_0_16_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_0_16_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_0_16_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_0_16_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_0_16_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_CFP_0_16_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_0_16_Roll_HYclass2 <- features$CFP_0_16_Roll[features$HYclass == group_A]
CFP_0_16_Roll_HYclass3 <- features$CFP_0_16_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_0_16_Roll <- 
  wilcox.test(CFP_0_16_Roll_HYclass2, CFP_0_16_Roll_HYclass3)$p.value

```


```{r CFP_0_16_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_0_16_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_0_16_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_0_16_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_0_16_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_CFP_0_16_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_0_16_Yaw_HYclass2 <- features$CFP_0_16_Yaw[features$HYclass == group_A]
CFP_0_16_Yaw_HYclass3 <- features$CFP_0_16_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_0_16_Yaw <- 
  wilcox.test(CFP_0_16_Yaw_HYclass2, CFP_0_16_Yaw_HYclass3)$p.value

```


```{r CFP_0_16_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_0_16_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_0_16_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_0_16_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_0_16_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Centroidal Frequency Power (total)

```{r Centroidal_power, echo = FALSE}
features$CFP_AP <- NA
features$CFP_ML <- NA
features$CFP_VT <- NA
features$CFP_Pitch <- NA
features$CFP_Roll <- NA
features$CFP_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2
  
  # get the centroidal frequency
  CF_AP_1 <- sum(freq1 * psd_ap_1) / sum(psd_ap_1)
  CF_AP_2 <- sum(freq2 * psd_ap_2) / sum(psd_ap_2)
  CF_AP_3 <- sum(freq3 * psd_ap_3) / sum(psd_ap_3)
  
  CF_ML_1 <- sum(freq1 * psd_ml_1) / sum(psd_ml_1)
  CF_ML_2 <- sum(freq2 * psd_ml_2) / sum(psd_ml_2)
  CF_ML_3 <- sum(freq3 * psd_ml_3) / sum(psd_ml_3)
  
  CF_VT_1 <- sum(freq1 * psd_VT_1) / sum(psd_VT_1)
  CF_VT_2 <- sum(freq2 * psd_VT_2) / sum(psd_VT_2)
  CF_VT_3 <- sum(freq3 * psd_VT_3) / sum(psd_VT_3)
  
  CF_Pitch_1 <- sum(freq1 * psd_pi_1) / sum(psd_pi_1)
  CF_Pitch_2 <- sum(freq2 * psd_pi_2) / sum(psd_pi_2)
  CF_Pitch_3 <- sum(freq3 * psd_pi_3) / sum(psd_pi_3)
  
  CF_Roll_1 <- sum(freq1 * psd_Roll_1) / sum(psd_Roll_1)
  CF_Roll_2 <- sum(freq2 * psd_Roll_2) / sum(psd_Roll_2)
  CF_Roll_3 <- sum(freq3 * psd_Roll_3) / sum(psd_Roll_3)
  
  CF_Yaw_1 <- sum(freq1 * psd_Yaw_1) / sum(psd_Yaw_1)
  CF_Yaw_2 <- sum(freq2 * psd_Yaw_2) / sum(psd_Yaw_2)
  CF_Yaw_3 <- sum(freq3 * psd_Yaw_3) / sum(psd_Yaw_3)
  
  # get index of the frequency bin closest to the CF
  index_CF_AP_1 <- which.min(abs(freq1 - CF_AP_1))
  index_CF_AP_2 <- which.min(abs(freq2 - CF_AP_2))
  index_CF_AP_3 <- which.min(abs(freq3 - CF_AP_3))
  
  index_CF_ML_1 <- which.min(abs(freq1 - CF_ML_1))
  index_CF_ML_2 <- which.min(abs(freq2 - CF_ML_2))
  index_CF_ML_3 <- which.min(abs(freq3 - CF_ML_3))
  
  index_CF_VT_1 <- which.min(abs(freq1 - CF_VT_1))
  index_CF_VT_2 <- which.min(abs(freq2 - CF_VT_2))
  index_CF_VT_3 <- which.min(abs(freq3 - CF_VT_3))
  
  index_CF_Pitch_1 <- which.min(abs(freq1 - CF_Pitch_1))
  index_CF_Pitch_2 <- which.min(abs(freq2 - CF_Pitch_2))
  index_CF_Pitch_3 <- which.min(abs(freq3 - CF_Pitch_3))
  
  index_CF_Roll_1 <- which.min(abs(freq1 - CF_Roll_1))
  index_CF_Roll_2 <- which.min(abs(freq2 - CF_Roll_2))
  index_CF_Roll_3 <- which.min(abs(freq3 - CF_Roll_3))
  
  index_CF_Yaw_1 <- which.min(abs(freq1 - CF_Yaw_1))
  index_CF_Yaw_2 <- which.min(abs(freq2 - CF_Yaw_2))
  index_CF_Yaw_3 <- which.min(abs(freq3 - CF_Yaw_3))

  # Get the PSD value at that frequency bin
  power_CF_AP_1 <- psd_ap_1[index_CF_AP_1]
  power_CF_AP_2 <- psd_ap_2[index_CF_AP_2]
  power_CF_AP_3 <- psd_ap_3[index_CF_AP_3]
  
  power_CF_ML_1 <- psd_ml_1[index_CF_ML_1]
  power_CF_ML_2 <- psd_ml_2[index_CF_ML_2]
  power_CF_ML_3 <- psd_ml_3[index_CF_ML_3]
  
  power_CF_VT_1 <- psd_VT_1[index_CF_VT_1]
  power_CF_VT_2 <- psd_VT_2[index_CF_VT_2]
  power_CF_VT_3 <- psd_VT_3[index_CF_VT_3]
  
  power_CF_Pitch_1 <- psd_pi_1[index_CF_Pitch_1]
  power_CF_Pitch_2 <- psd_pi_2[index_CF_Pitch_2]
  power_CF_Pitch_3 <- psd_pi_3[index_CF_Pitch_3]
  
  power_CF_Roll_1 <- psd_Roll_1[index_CF_Roll_1]
  power_CF_Roll_2 <- psd_Roll_2[index_CF_Roll_2]
  power_CF_Roll_3 <- psd_Roll_3[index_CF_Roll_3]
  
  power_CF_Yaw_1 <- psd_Yaw_1[index_CF_Yaw_1]
  power_CF_Yaw_2 <- psd_Yaw_2[index_CF_Yaw_2]
  power_CF_Yaw_3 <- psd_Yaw_3[index_CF_Yaw_3]
  
  # average the segments for each
  features$CFP_AP[i] <- mean(c(power_CF_AP_1, power_CF_AP_2, power_CF_AP_3))
  features$CFP_ML[i] <- mean(c(power_CF_ML_1, power_CF_ML_2, power_CF_ML_3))
  features$CFP_VT[i] <- mean(c(power_CF_VT_1, power_CF_VT_2, power_CF_VT_3))
  features$CFP_Pitch[i] <- mean(c(power_CF_Pitch_1, power_CF_Pitch_2, power_CF_Pitch_3))
  features$CFP_Roll[i] <- mean(c(power_CF_Roll_1, power_CF_Roll_2, power_CF_Roll_3))
  features$CFP_Yaw[i] <- mean(c(power_CF_Yaw_1, power_CF_Yaw_2, power_CF_Yaw_3))
  
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_CFP_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_AP_HYclass2 <- features$CFP_AP[features$HYclass == group_A]
CFP_AP_HYclass3 <- features$CFP_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_AP <- wilcox.test(CFP_AP_HYclass2, CFP_AP_HYclass3)$p.value

```


```{r CFP_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```



### Mediolateral

```{r Mann-Whitney-U-test_CFP_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_ML_HYclass2 <- features$CFP_ML[features$HYclass == group_A]
CFP_ML_HYclass3 <- features$CFP_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_ML <- wilcox.test(CFP_ML_HYclass2, CFP_ML_HYclass3)$p.value

```

```{r CFP_ML_plot_ML, echo=FALSE}

boxplot(CFP_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CFP_ML",
        #ylim = c(0,1.6),
        main = "Centroidal Frequency Power - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CFP_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_CFP_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_VT_HYclass2 <- features$CFP_VT[features$HYclass == group_A]
CFP_VT_HYclass3 <- features$CFP_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_VT <- wilcox.test(CFP_VT_HYclass2, CFP_VT_HYclass3)$p.value

```


```{r CFP_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch (AV) *

```{r Mann-Whitney-U-test_CFP_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_Pitch_HYclass2 <- features$CFP_Pitch[features$HYclass == group_A]
CFP_Pitch_HYclass3 <- features$CFP_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_Pitch <- wilcox.test(CFP_Pitch_HYclass2, CFP_Pitch_HYclass3)$p.value

```


```{r CFP_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_CFP_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_Roll_HYclass2 <- features$CFP_Roll[features$HYclass == group_A]
CFP_Roll_HYclass3 <- features$CFP_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_Roll <- wilcox.test(CFP_Roll_HYclass2, CFP_Roll_HYclass3)$p.value

```


```{r CFP_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_CFP_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_Yaw_HYclass2 <- features$CFP_Yaw[features$HYclass == group_A]
CFP_Yaw_HYclass3 <- features$CFP_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_Yaw <- wilcox.test(CFP_Yaw_HYclass2, CFP_Yaw_HYclass3)$p.value

```


```{r CFP_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Centroidal Frequency 66% Power Range

```{r centroidal_frequency_66_P, echo = FALSE}
features$CFP_66_AP <- NA
features$CFP_66_ML <- NA
features$CFP_66_VT <- NA
features$CFP_66_Pitch <- NA
features$CFP_66_Roll <- NA
features$CFP_66_Yaw <- NA

# function to find 16.5 to 83.5% range (i.e. mid 66%)
find_power_range <- function(cumulative_psd, freq) {
  total_power <- tail(cumulative_psd, 1)
  lower_power_threshold <- total_power * 0.165
  upper_power_threshold <- total_power * 0.835

  lower_bound_index <- which(cumulative_psd >= lower_power_threshold)[1]
  upper_bound_index <- which(cumulative_psd >= upper_power_threshold)[1]

  lower_bound_freq <- freq[lower_bound_index]
  upper_bound_freq <- freq[upper_bound_index]

  return(c(lower_bound_freq, upper_bound_freq))
}

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2
  
  # cumulative sum for the 66% calculation
  cumulative_psd_ap_1 <- cumsum(psd_ap_1)
  cumulative_psd_ap_2 <- cumsum(psd_ap_2)
  cumulative_psd_ap_3 <- cumsum(psd_ap_3)
  
  cumulative_psd_ml_1 <- cumsum(psd_ml_1)
  cumulative_psd_ml_2 <- cumsum(psd_ml_2)
  cumulative_psd_ml_3 <- cumsum(psd_ml_3)
  
  cumulative_psd_VT_1 <- cumsum(psd_VT_1)
  cumulative_psd_VT_2 <- cumsum(psd_VT_2)
  cumulative_psd_VT_3 <- cumsum(psd_VT_3)
  
  cumulative_psd_pi_1 <- cumsum(psd_pi_1)
  cumulative_psd_pi_2 <- cumsum(psd_pi_2)
  cumulative_psd_pi_3 <- cumsum(psd_pi_3)
  
  cumulative_psd_Roll_1 <- cumsum(psd_Roll_1)
  cumulative_psd_Roll_2 <- cumsum(psd_Roll_2)
  cumulative_psd_Roll_3 <- cumsum(psd_Roll_3)
  
  cumulative_psd_Yaw_1 <- cumsum(psd_Yaw_1)
  cumulative_psd_Yaw_2 <- cumsum(psd_Yaw_2)
  cumulative_psd_Yaw_3 <- cumsum(psd_Yaw_3)

  # first calculate centroidal frequency:
  CF_AP_1 <- sum(freq1 * psd_ap_1) / sum(psd_ap_1)
  CF_AP_2 <- sum(freq2 * psd_ap_2) / sum(psd_ap_2)
  CF_AP_3 <- sum(freq3 * psd_ap_3) / sum(psd_ap_3)
  
  CF_ML_1 <- sum(freq1 * psd_ml_1) / sum(psd_ml_1)
  CF_ML_2 <- sum(freq2 * psd_ml_2) / sum(psd_ml_2)
  CF_ML_3 <- sum(freq3 * psd_ml_3) / sum(psd_ml_3)
  
  CF_VT_1 <- sum(freq1 * psd_VT_1) / sum(psd_VT_1)
  CF_VT_2 <- sum(freq2 * psd_VT_2) / sum(psd_VT_2)
  CF_VT_3 <- sum(freq3 * psd_VT_3) / sum(psd_VT_3)
  
  CF_Pitch_1 <- sum(freq1 * psd_pi_1) / sum(psd_pi_1)
  CF_Pitch_2 <- sum(freq2 * psd_pi_2) / sum(psd_pi_2)
  CF_Pitch_3 <- sum(freq3 * psd_pi_3) / sum(psd_pi_3)
  
  CF_Roll_1 <- sum(freq1 * psd_Roll_1) / sum(psd_Roll_1)
  CF_Roll_2 <- sum(freq2 * psd_Roll_2) / sum(psd_Roll_2)
  CF_Roll_3 <- sum(freq3 * psd_Roll_3) / sum(psd_Roll_3)
  
  CF_Yaw_1 <- sum(freq1 * psd_Yaw_1) / sum(psd_Yaw_1)
  CF_Yaw_2 <- sum(freq2 * psd_Yaw_2) / sum(psd_Yaw_2)
  CF_Yaw_3 <- sum(freq3 * psd_Yaw_3) / sum(psd_Yaw_3)
  
  # Calculate the frequency range for each segment
  power_range_ap_1 <- find_power_range(cumulative_psd_ap_1, freq1)
  power_range_ap_2 <- find_power_range(cumulative_psd_ap_2, freq2)
  power_range_ap_3 <- find_power_range(cumulative_psd_ap_3, freq3)
  
  power_range_ml_1 <- find_power_range(cumulative_psd_ml_1, freq1)
  power_range_ml_2 <- find_power_range(cumulative_psd_ml_2, freq2)
  power_range_ml_3 <- find_power_range(cumulative_psd_ml_3, freq3)
  
  power_range_VT_1 <- find_power_range(cumulative_psd_VT_1, freq1)
  power_range_VT_2 <- find_power_range(cumulative_psd_VT_2, freq2)
  power_range_VT_3 <- find_power_range(cumulative_psd_VT_3, freq3)
  
  power_range_pi_1 <- find_power_range(cumulative_psd_pi_1, freq1)
  power_range_pi_2 <- find_power_range(cumulative_psd_pi_2, freq2)
  power_range_pi_3 <- find_power_range(cumulative_psd_pi_3, freq3)
  
  power_range_Roll_1 <- find_power_range(cumulative_psd_Roll_1, freq1)
  power_range_Roll_2 <- find_power_range(cumulative_psd_Roll_2, freq2)
  power_range_Roll_3 <- find_power_range(cumulative_psd_Roll_3, freq3)
  
  power_range_Yaw_1 <- find_power_range(cumulative_psd_Yaw_1, freq1)
  power_range_Yaw_2 <- find_power_range(cumulative_psd_Yaw_2, freq2)
  power_range_Yaw_3 <- find_power_range(cumulative_psd_Yaw_3, freq3)

  # Average for the three pulls taking
  features$CFP_66_AP[i] <- mean(c(power_range_ap_1, power_range_ap_2, power_range_ap_3))
  features$CFP_66_ML[i] <- mean(c(power_range_ml_1, power_range_ml_2, power_range_ml_3))
  features$CFP_66_VT[i] <- mean(c(power_range_VT_1, power_range_VT_2, power_range_VT_3))
  features$CFP_66_Pitch[i] <- mean(c(power_range_pi_1, power_range_pi_2, power_range_pi_3))
  features$CFP_66_Roll[i] <- mean(c(power_range_Roll_1, power_range_Roll_2, power_range_Roll_3))
  features$CFP_66_Yaw[i] <- mean(c(power_range_Yaw_1, power_range_Yaw_2, power_range_Yaw_3))
  
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_CFP_66_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_66_AP_HYclass2 <- features$CFP_66_AP[features$HYclass == group_A]
CFP_66_AP_HYclass3 <- features$CFP_66_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_66_AP <- wilcox.test(CFP_66_AP_HYclass2, CFP_66_AP_HYclass3)$p.value

```


```{r CFP_66_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_66_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_66_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_66_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_66_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_CFP_66_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_66_ML_HYclass2 <- features$CFP_66_ML[features$HYclass == group_A]
CFP_66_ML_HYclass3 <- features$CFP_66_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_66_ML <- wilcox.test(CFP_66_ML_HYclass2, CFP_66_ML_HYclass3)$p.value

```

```{r CFP_66_ML_plot_ML, echo=FALSE}

boxplot(CFP_66_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CFP_66_ML",
        #ylim = c(0,1.6),
        main = "Centroidal Frequency 66% Power - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CFP_66_ML_plot_ML_no_outlier, echo=FALSE}

boxplot(CFP_66_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "CFP_66_ML",
        outline = FALSE,
        main = "Centroidal Frequency 66% Power - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r CFP_66_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_66_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_66_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_66_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_66_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_CFP_66_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_66_VT_HYclass2 <- features$CFP_66_VT[features$HYclass == group_A]
CFP_66_VT_HYclass3 <- features$CFP_66_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_66_VT <- wilcox.test(CFP_66_VT_HYclass2, CFP_66_VT_HYclass3)$p.value

```


```{r CFP_66_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_66_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_66_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_66_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_66_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```



### Pitch (AV) *

```{r Mann-Whitney-U-test_CFP_66_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_66_Pitch_HYclass2 <- features$CFP_66_Pitch[features$HYclass == group_A]
CFP_66_Pitch_HYclass3 <- features$CFP_66_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_66_Pitch <-
  wilcox.test(CFP_66_Pitch_HYclass2, CFP_66_Pitch_HYclass3)$p.value

```

```{r CFP_66_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_66_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_66_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_66_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_66_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_CFP_66_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_66_Roll_HYclass2 <- features$CFP_66_Roll[features$HYclass == group_A]
CFP_66_Roll_HYclass3 <- features$CFP_66_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_66_Roll <- wilcox.test(CFP_66_Roll_HYclass2, CFP_66_Roll_HYclass3)$p.value

```


```{r CFP_66_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_66_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_66_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_66_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_66_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_CFP_66_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
CFP_66_Yaw_HYclass2 <- features$CFP_66_Yaw[features$HYclass == group_A]
CFP_66_Yaw_HYclass3 <- features$CFP_66_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$CFP_66_Yaw <- wilcox.test(CFP_66_Yaw_HYclass2, CFP_66_Yaw_HYclass3)$p.value

```


```{r CFP_66_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$CFP_66_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$CFP_66_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$CFP_66_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$CFP_66_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Mean Harmonic Peak Power

```{r mean_harmonic_power, echo = FALSE}
features$MHP_AP <- NA
features$MHP_ML <- NA
features$MHP_VT <- NA
features$MHP_Pitch <- NA
features$MHP_Roll <- NA
features$MHP_Yaw <- NA


## Note the n_harmonics hyperparameter has been tuned as n = 3 for AP, ML, Roll,
# and Yaw, n = 4 for VT, and n = 7 for pitch.

# function to calc mean harmonic power per segment
calculate_mean_harmonic_power <- function(fundamental_freq, mag, freq, n_harmonics, nyquist_limit) {
  harmonic_powers <- numeric(n_harmonics)
  
  for (i in 1:n_harmonics) {
    harmonic_freq <- i * fundamental_freq
    if (harmonic_freq > nyquist_limit) {
      # Skip this harmonic as it exceeds the Nyquist frequency
      next
    }
    
    # Find the index of the closest frequency bin
    closest_index <- which.min(abs(freq - harmonic_freq))
    harmonic_powers[i] <- mag[closest_index]^2
  }
  
  # Calculate the mean, ignoring NA values
  mean(harmonic_powers, na.rm = TRUE)
  }

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate magnitude on real half of FFT
  mag_ap_1 <- Mod(fft_ap_1[1:(n1/2)])
  mag_ap_2 <- Mod(fft_ap_2[1:(n2/2)])
  mag_ap_3 <- Mod(fft_ap_3[1:(n3/2)])
  
  mag_ml_1 <- Mod(fft_ml_1[1:(n1/2)])
  mag_ml_2 <- Mod(fft_ml_2[1:(n2/2)])
  mag_ml_3 <- Mod(fft_ml_3[1:(n3/2)])
  
  mag_VT_1 <- Mod(fft_VT_1[1:(n1/2)])
  mag_VT_2 <- Mod(fft_VT_2[1:(n2/2)])
  mag_VT_3 <- Mod(fft_VT_3[1:(n3/2)])
  
  mag_pi_1 <- Mod(fft_pi_1[1:(n1/2)])
  mag_pi_2 <- Mod(fft_pi_2[1:(n2/2)])
  mag_pi_3 <- Mod(fft_pi_3[1:(n3/2)])
  
  mag_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])
  mag_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])
  mag_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])
  
  mag_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])
  mag_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])
  mag_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])
  
  # get the index of the fundamental frequency
  index_ap_1 <- which.max(mag_ap_1)
  index_ap_2 <- which.max(mag_ap_2)
  index_ap_3 <- which.max(mag_ap_3)
  
  index_ml_1 <- which.max(mag_ml_1)
  index_ml_2 <- which.max(mag_ml_2)
  index_ml_3 <- which.max(mag_ml_3)
  
  index_VT_1 <- which.max(mag_VT_1)
  index_VT_2 <- which.max(mag_VT_2)
  index_VT_3 <- which.max(mag_VT_3)
  
  index_pi_1 <- which.max(mag_pi_1)
  index_pi_2 <- which.max(mag_pi_2)
  index_pi_3 <- which.max(mag_pi_3)
  
  index_Roll_1 <- which.max(mag_Roll_1)
  index_Roll_2 <- which.max(mag_Roll_2)
  index_Roll_3 <- which.max(mag_Roll_3)
  
  index_Yaw_1 <- which.max(mag_Yaw_1)
  index_Yaw_2 <- which.max(mag_Yaw_2)
  index_Yaw_3 <- which.max(mag_Yaw_3)
  
  # then get the frequency of that index
  fundamental_freq_ap_1 <- index_ap_1 * (50 / n1)
  fundamental_freq_ap_2 <- index_ap_2 * (50 / n2)
  fundamental_freq_ap_3 <- index_ap_3 * (50 / n3)
  
  fundamental_freq_ml_1 <- index_ml_1 * (50 / n1)
  fundamental_freq_ml_2 <- index_ml_2 * (50 / n2)
  fundamental_freq_ml_3 <- index_ml_3 * (50 / n3)
  
  fundamental_freq_VT_1 <- index_VT_1 * (50 / n1)
  fundamental_freq_VT_2 <- index_VT_2 * (50 / n2)
  fundamental_freq_VT_3 <- index_VT_3 * (50 / n3)
  
  fundamental_freq_pi_1 <- index_pi_1 * (50 / n1)
  fundamental_freq_pi_2 <- index_pi_2 * (50 / n2)
  fundamental_freq_pi_3 <- index_pi_3 * (50 / n3)
  
  fundamental_freq_Roll_1 <- index_Roll_1 * (50 / n1)
  fundamental_freq_Roll_2 <- index_Roll_2 * (50 / n2)
  fundamental_freq_Roll_3 <- index_Roll_3 * (50 / n3)
  
  fundamental_freq_Yaw_1 <- index_Yaw_1 * (50 / n1)
  fundamental_freq_Yaw_2 <- index_Yaw_2 * (50 / n2)
  fundamental_freq_Yaw_3 <- index_Yaw_3 * (50 / n3)
  
  ## Note this has been tuned to n_harmonics = 3 for AP
  mean_harmonic_power_ap_1 <- calculate_mean_harmonic_power(fundamental_freq_ap_1, 
                                                            mag_ap_1, freq1, 3, 25)
  mean_harmonic_power_ap_2 <- calculate_mean_harmonic_power(fundamental_freq_ap_2, 
                                                            mag_ap_2, freq2, 3, 25)
  mean_harmonic_power_ap_3 <- calculate_mean_harmonic_power(fundamental_freq_ap_3, 
                                                            mag_ap_3, freq3, 3, 25)
  
  ## Note this has been tuned to n_harmonics = 3 for ML (n = 2 is better, but min = 3)
  mean_harmonic_power_ml_1 <- calculate_mean_harmonic_power(fundamental_freq_ml_1, 
                                                            mag_ml_1, freq1, 3, 25)
  mean_harmonic_power_ml_2 <- calculate_mean_harmonic_power(fundamental_freq_ml_2, 
                                                            mag_ml_2, freq2, 3, 25)
  mean_harmonic_power_ml_3 <- calculate_mean_harmonic_power(fundamental_freq_ml_3, 
                                                            mag_ml_3, freq3, 3, 25)
  
  ## Note this has been tuned to n_harmonics = 4 for VT
  mean_harmonic_power_VT_1 <- calculate_mean_harmonic_power(fundamental_freq_VT_1, 
                                                            mag_VT_1, freq1, 4, 25)
  mean_harmonic_power_VT_2 <- calculate_mean_harmonic_power(fundamental_freq_VT_2, 
                                                            mag_VT_2, freq2, 4, 25)
  mean_harmonic_power_VT_3 <- calculate_mean_harmonic_power(fundamental_freq_VT_3, 
                                                            mag_VT_3, freq3, 4, 25)
  
  ## Note this has been tuned to n_harmonics = 7 for Pitch
  mean_harmonic_power_pi_1 <- calculate_mean_harmonic_power(fundamental_freq_pi_1, 
                                                            mag_pi_1, freq1, 7, 25)
  mean_harmonic_power_pi_2 <- calculate_mean_harmonic_power(fundamental_freq_pi_2, 
                                                            mag_pi_2, freq2, 7, 25)
  mean_harmonic_power_pi_3 <- calculate_mean_harmonic_power(fundamental_freq_pi_3, 
                                                            mag_pi_3, freq3, 7, 25)
  
  ## Note this has been tuned to n_harmonics = 3 for Roll
  mean_harmonic_power_Roll_1 <- calculate_mean_harmonic_power(fundamental_freq_Roll_1, 
                                                            mag_Roll_1, freq1, 3, 25)
  mean_harmonic_power_Roll_2 <- calculate_mean_harmonic_power(fundamental_freq_Roll_2, 
                                                            mag_Roll_2, freq2, 3, 25)
  mean_harmonic_power_Roll_3 <- calculate_mean_harmonic_power(fundamental_freq_Roll_3, 
                                                            mag_Roll_3, freq3, 3, 25)
  
  ## Note this has been tuned to n_harmonics = 3 for Yaw
  mean_harmonic_power_Yaw_1 <- calculate_mean_harmonic_power(fundamental_freq_Yaw_1, 
                                                            mag_Yaw_1, freq1, 3, 25)
  mean_harmonic_power_Yaw_2 <- calculate_mean_harmonic_power(fundamental_freq_Yaw_2, 
                                                            mag_Yaw_2, freq2, 3, 25)
  mean_harmonic_power_Yaw_3 <- calculate_mean_harmonic_power(fundamental_freq_Yaw_3, 
                                                            mag_Yaw_3, freq3, 3, 25)

  # Average for the three pulls
  features$MHP_AP[i] <- mean(c(mean_harmonic_power_ap_1, mean_harmonic_power_ap_2,
                               mean_harmonic_power_ap_3))
  features$MHP_ML[i] <- mean(c(mean_harmonic_power_ml_1, mean_harmonic_power_ml_2,
                               mean_harmonic_power_ml_3))
  features$MHP_VT[i] <- mean(c(mean_harmonic_power_VT_1, mean_harmonic_power_VT_2,
                               mean_harmonic_power_VT_3))
  features$MHP_Pitch[i] <- mean(c(mean_harmonic_power_pi_1, mean_harmonic_power_pi_2,
                               mean_harmonic_power_pi_3))
  features$MHP_Roll[i] <- mean(c(mean_harmonic_power_Roll_1, mean_harmonic_power_Roll_2,
                               mean_harmonic_power_Roll_3))
  features$MHP_Yaw[i] <- mean(c(mean_harmonic_power_Yaw_1, mean_harmonic_power_Yaw_2,
                               mean_harmonic_power_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_MHP_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
MHP_AP_HYclass2 <- features$MHP_AP[features$HYclass == group_A]
MHP_AP_HYclass3 <- features$MHP_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MHP_AP <- wilcox.test(MHP_AP_HYclass2, MHP_AP_HYclass3)$p.value

```


```{r MHP_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MHP_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MHP_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MHP_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MHP_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```



### Mediolateral

```{r Mann-Whitney-U-test_MHP_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
MHP_ML_HYclass2 <- features$MHP_ML[features$HYclass == group_A]
MHP_ML_HYclass3 <- features$MHP_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MHP_ML <- wilcox.test(MHP_ML_HYclass2, MHP_ML_HYclass3)$p.value

```

```{r MHP_ML_plot, echo=FALSE}

boxplot(MHP_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "MHP_ML",
        main = "Relative Power in Tremor band - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```
```{r MHP_ML_plot_no_outlier, echo=FALSE}

boxplot(MHP_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "MHP_ML",
        outline = FALSE,
        main = "Mean harmonic peak power - ML (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r MHP_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MHP_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MHP_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MHP_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MHP_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Vertical

```{r Mann-Whitney-U-test_MHP_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
MHP_VT_HYclass2 <- features$MHP_VT[features$HYclass == group_A]
MHP_VT_HYclass3 <- features$MHP_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MHP_VT <- wilcox.test(MHP_VT_HYclass2, MHP_VT_HYclass3)$p.value

```


```{r MHP_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MHP_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MHP_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MHP_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MHP_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Pitch (AV)

```{r Mann-Whitney-U-test_MHP_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
MHP_Pitch_HYclass2 <- features$MHP_Pitch[features$HYclass == group_A]
MHP_Pitch_HYclass3 <- features$MHP_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MHP_Pitch <- wilcox.test(MHP_Pitch_HYclass2, MHP_Pitch_HYclass3)$p.value

```

```{r MHP_Pitch_plot, echo=FALSE}

boxplot(MHP_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "MHP_Pitch",
        main = "Relative Power in Tremor band - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```
```{r MHP_Pitch_plot_no_outlier, echo=FALSE}

boxplot(MHP_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "MHP_Pitch",
        outline = FALSE,
        main = "Mean harmonic peak power - Pitch (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r MHP_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MHP_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MHP_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MHP_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MHP_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_MHP_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
MHP_Roll_HYclass2 <- features$MHP_Roll[features$HYclass == group_A]
MHP_Roll_HYclass3 <- features$MHP_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MHP_Roll <- wilcox.test(MHP_Roll_HYclass2, MHP_Roll_HYclass3)$p.value

```


```{r MHP_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MHP_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MHP_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MHP_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MHP_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_MHP_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
MHP_Yaw_HYclass2 <- features$MHP_Yaw[features$HYclass == group_A]
MHP_Yaw_HYclass3 <- features$MHP_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$MHP_Yaw <- wilcox.test(MHP_Yaw_HYclass2, MHP_Yaw_HYclass3)$p.value

```


```{r MHP_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$MHP_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$MHP_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$MHP_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$MHP_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Spectral Entropy / Shannon entropy

```{r entropy, echo = FALSE}
features$H_AP <- NA
features$H_ML <- NA
features$H_VT <- NA
features$H_Pitch <- NA
features$H_Roll <- NA
features$H_Yaw <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2
  
  # Calculate normalized PSD on real half of FFT
  psd_norm_ap_1 <- psd_ap_1 / sum(psd_ap_1)
  psd_norm_ap_2 <- psd_ap_2 / sum(psd_ap_2)
  psd_norm_ap_3 <- psd_ap_3 / sum(psd_ap_3)
  
  psd_norm_ml_1 <- psd_ml_1 / sum(psd_ml_1)
  psd_norm_ml_2 <- psd_ml_2 / sum(psd_ml_2)
  psd_norm_ml_3 <- psd_ml_3 / sum(psd_ml_3)
  
  psd_norm_VT_1 <- psd_VT_1 / sum(psd_VT_1)
  psd_norm_VT_2 <- psd_VT_2 / sum(psd_VT_2)
  psd_norm_VT_3 <- psd_VT_3 / sum(psd_VT_3)
  
  psd_norm_pi_1 <- psd_pi_1 / sum(psd_pi_1)
  psd_norm_pi_2 <- psd_pi_2 / sum(psd_pi_2)
  psd_norm_pi_3 <- psd_pi_3 / sum(psd_pi_3)
  
  psd_norm_Roll_1 <- psd_Roll_1 / sum(psd_Roll_1)
  psd_norm_Roll_2 <- psd_Roll_2 / sum(psd_Roll_2)
  psd_norm_Roll_3 <- psd_Roll_3 / sum(psd_Roll_3)
  
  psd_norm_Yaw_1 <- psd_Yaw_1 / sum(psd_Yaw_1)
  psd_norm_Yaw_2 <- psd_Yaw_2 / sum(psd_Yaw_2)
  psd_norm_Yaw_3 <- psd_Yaw_3 / sum(psd_Yaw_3)
  
  # calculate special entropy
  entropy_ap_1 <- -sum(psd_norm_ap_1 * log(psd_norm_ap_1))
  entropy_ap_2 <- -sum(psd_norm_ap_2 * log(psd_norm_ap_2))
  entropy_ap_3 <- -sum(psd_norm_ap_3 * log(psd_norm_ap_3))
  
  entropy_ml_1 <- -sum(psd_norm_ml_1 * log(psd_norm_ml_1))
  entropy_ml_2 <- -sum(psd_norm_ml_2 * log(psd_norm_ml_2))
  entropy_ml_3 <- -sum(psd_norm_ml_3 * log(psd_norm_ml_3))
  
  entropy_VT_1 <- -sum(psd_norm_VT_1 * log(psd_norm_VT_1))
  entropy_VT_2 <- -sum(psd_norm_VT_2 * log(psd_norm_VT_2))
  entropy_VT_3 <- -sum(psd_norm_VT_3 * log(psd_norm_VT_3))
  
  entropy_pi_1 <- -sum(psd_norm_pi_1 * log(psd_norm_pi_1))
  entropy_pi_2 <- -sum(psd_norm_pi_2 * log(psd_norm_pi_2))
  entropy_pi_3 <- -sum(psd_norm_pi_3 * log(psd_norm_pi_3))
  
  entropy_Roll_1 <- -sum(psd_norm_Roll_1 * log(psd_norm_Roll_1))
  entropy_Roll_2 <- -sum(psd_norm_Roll_2 * log(psd_norm_Roll_2))
  entropy_Roll_3 <- -sum(psd_norm_Roll_3 * log(psd_norm_Roll_3))
  
  entropy_Yaw_1 <- -sum(psd_norm_Yaw_1 * log(psd_norm_Yaw_1))
  entropy_Yaw_2 <- -sum(psd_norm_Yaw_2 * log(psd_norm_Yaw_2))
  entropy_Yaw_3 <- -sum(psd_norm_Yaw_3 * log(psd_norm_Yaw_3))

  # Average for the three pulls
  features$H_AP[i] <- mean(c(entropy_ap_1, entropy_ap_2, entropy_ap_3))
  features$H_ML[i] <- mean(c(entropy_ml_1, entropy_ml_2, entropy_ml_3))
  features$H_VT[i] <- mean(c(entropy_VT_1, entropy_VT_2, entropy_VT_3))
  features$H_Pitch[i] <- mean(c(entropy_pi_1, entropy_pi_2, entropy_pi_3))
  features$H_Roll[i] <- mean(c(entropy_Roll_1, entropy_Roll_2, entropy_Roll_3))
  features$H_Yaw[i] <- mean(c(entropy_Yaw_1, entropy_Yaw_2, entropy_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_Ent_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
H_AP_HYclass2 <- features$H_AP[features$HYclass == group_A]
H_AP_HYclass3 <- features$H_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$H_AP <- wilcox.test(H_AP_HYclass2, H_AP_HYclass3)$p.value

```


```{r H_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$H_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$H_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$H_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$H_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_Ent_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
H_ML_HYclass2 <- features$H_ML[features$HYclass == group_A]
H_ML_HYclass3 <- features$H_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$H_ML <- wilcox.test(H_ML_HYclass2, H_ML_HYclass3)$p.value

```

```{r Ent_ML_plot, echo=FALSE}

boxplot(H_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "H_ML",
        main = "Relative Power in Tremor band - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r H_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$H_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$H_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$H_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$H_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_Ent_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
H_VT_HYclass2 <- features$H_VT[features$HYclass == group_A]
H_VT_HYclass3 <- features$H_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$H_VT <- wilcox.test(H_VT_HYclass2, H_VT_HYclass3)$p.value

```


```{r H_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$H_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$H_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$H_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$H_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch (AV)

```{r Mann-Whitney-U-test_Ent_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
H_Pitch_HYclass2 <- features$H_Pitch[features$HYclass == group_A]
H_Pitch_HYclass3 <- features$H_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$H_Pitch <- wilcox.test(H_Pitch_HYclass2, H_Pitch_HYclass3)$p.value

```

```{r Ent_Pitch_plot, echo=FALSE}

boxplot(H_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "H_Pitch",
        main = "Relative Power in Tremor band - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r H_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$H_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$H_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$H_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$H_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_Ent_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
H_Roll_HYclass2 <- features$H_Roll[features$HYclass == group_A]
H_Roll_HYclass3 <- features$H_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$H_Roll <- wilcox.test(H_Roll_HYclass2, H_Roll_HYclass3)$p.value

```


```{r H_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$H_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$H_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$H_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$H_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_Ent_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
H_Yaw_HYclass2 <- features$H_Yaw[features$HYclass == group_A]
H_Yaw_HYclass3 <- features$H_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$H_Yaw <- wilcox.test(H_Yaw_HYclass2, H_Yaw_HYclass3)$p.value

```


```{r H_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$H_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$H_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$H_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$H_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Spectral Flatness

```{r spectral_flatness, echo = FALSE}
features$SF_AP <- NA
features$SF_ML <- NA
features$SF_VT <- NA
features$SF_Pitch <- NA
features$SF_Roll <- NA
features$SF_Yaw <- NA

# function to make it easier on the code lines
spectral_flatness <- function(psd) {
  geometric_mean <- exp(mean(log(psd[psd > 0]))) # Geometric mean
  arithmetic_mean <- mean(psd) # Arithmetic mean

  return(geometric_mean / arithmetic_mean) # i.e Spectral Flatness
}

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_VT_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_VT_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_VT_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 
  
  fft_pi_1 <- fft(na.trim(pull_segments$Pitch_1[[i]], sides = "right")) 
  fft_pi_2 <- fft(na.trim(pull_segments$Pitch_2[[i]], sides = "right")) 
  fft_pi_3 <- fft(na.trim(pull_segments$Pitch_3[[i]], sides = "right")) 
  
  fft_Roll_1 <- fft(na.trim(pull_segments$Roll_1[[i]], sides = "right")) 
  fft_Roll_2 <- fft(na.trim(pull_segments$Roll_2[[i]], sides = "right")) 
  fft_Roll_3 <- fft(na.trim(pull_segments$Roll_3[[i]], sides = "right")) 
  
  fft_Yaw_1 <- fft(na.trim(pull_segments$Yaw_1[[i]], sides = "right")) 
  fft_Yaw_2 <- fft(na.trim(pull_segments$Yaw_2[[i]], sides = "right")) 
  fft_Yaw_3 <- fft(na.trim(pull_segments$Yaw_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_VT_1 <- Mod(fft_VT_1[1:(n1/2)])^2
  psd_VT_2 <- Mod(fft_VT_2[1:(n2/2)])^2
  psd_VT_3 <- Mod(fft_VT_3[1:(n3/2)])^2
  
  psd_pi_1 <- Mod(fft_pi_1[1:(n1/2)])^2
  psd_pi_2 <- Mod(fft_pi_2[1:(n2/2)])^2
  psd_pi_3 <- Mod(fft_pi_3[1:(n3/2)])^2
  
  psd_Roll_1 <- Mod(fft_Roll_1[1:(n1/2)])^2
  psd_Roll_2 <- Mod(fft_Roll_2[1:(n2/2)])^2
  psd_Roll_3 <- Mod(fft_Roll_3[1:(n3/2)])^2
  
  psd_Yaw_1 <- Mod(fft_Yaw_1[1:(n1/2)])^2
  psd_Yaw_2 <- Mod(fft_Yaw_2[1:(n2/2)])^2
  psd_Yaw_3 <- Mod(fft_Yaw_3[1:(n3/2)])^2
  
  # calculate special entropy
  SF_ap_1 <- spectral_flatness(psd_ap_1)
  SF_ap_2 <- spectral_flatness(psd_ap_2)
  SF_ap_3 <- spectral_flatness(psd_ap_3)
  
  SF_ml_1 <- spectral_flatness(psd_ml_1)
  SF_ml_2 <- spectral_flatness(psd_ml_2)
  SF_ml_3 <- spectral_flatness(psd_ml_3)
  
  SF_VT_1 <- spectral_flatness(psd_VT_1)
  SF_VT_2 <- spectral_flatness(psd_VT_2)
  SF_VT_3 <- spectral_flatness(psd_VT_3)
  
  SF_pi_1 <- spectral_flatness(psd_pi_1)
  SF_pi_2 <- spectral_flatness(psd_pi_2)
  SF_pi_3 <- spectral_flatness(psd_pi_3)
  
  SF_Roll_1 <- spectral_flatness(psd_Roll_1)
  SF_Roll_2 <- spectral_flatness(psd_Roll_2)
  SF_Roll_3 <- spectral_flatness(psd_Roll_3)
  
  SF_Yaw_1 <- spectral_flatness(psd_Yaw_1)
  SF_Yaw_2 <- spectral_flatness(psd_Yaw_2)
  SF_Yaw_3 <- spectral_flatness(psd_Yaw_3)

  # Average for the three pulls
  features$SF_AP[i] <- mean(c(SF_ap_1, SF_ap_2, SF_ap_3))
  features$SF_ML[i] <- mean(c(SF_ml_1, SF_ml_2, SF_ml_3))
  features$SF_VT[i] <- mean(c(SF_VT_1, SF_VT_2, SF_VT_3))
  features$SF_Pitch[i] <- mean(c(SF_pi_1, SF_pi_2, SF_pi_3))
  features$SF_Roll[i] <- mean(c(SF_Roll_1, SF_Roll_2, SF_Roll_3))
  features$SF_Yaw[i] <- mean(c(SF_Yaw_1, SF_Yaw_2, SF_Yaw_3))
}


```

### Anteroposterior

```{r Mann-Whitney-U-test_SF_ap, echo=FALSE}

# Extract values for HYclass 2 and 3
SF_AP_HYclass2 <- features$SF_AP[features$HYclass == group_A]
SF_AP_HYclass3 <- features$SF_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SF_AP <- wilcox.test(SF_AP_HYclass2, SF_AP_HYclass3)$p.value

```


```{r SF_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SF_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SF_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SF_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SF_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Mediolateral

```{r Mann-Whitney-U-test_SF_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
SF_ML_HYclass2 <- features$SF_ML[features$HYclass == group_A]
SF_ML_HYclass3 <- features$SF_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SF_ML <- wilcox.test(SF_ML_HYclass2, SF_ML_HYclass3)$p.value

```

```{r SF_ML_plot, echo=FALSE}

boxplot(SF_ML ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "SF_ML",
        main = "Relative Power in Tremor band - ML", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r SF_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SF_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SF_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SF_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SF_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Vertical

```{r Mann-Whitney-U-test_SF_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
SF_VT_HYclass2 <- features$SF_VT[features$HYclass == group_A]
SF_VT_HYclass3 <- features$SF_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SF_VT <- wilcox.test(SF_VT_HYclass2, SF_VT_HYclass3)$p.value

```


```{r SF_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SF_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SF_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SF_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SF_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Pitch (AV)

```{r Mann-Whitney-U-test_SF_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
SF_Pitch_HYclass2 <- features$SF_Pitch[features$HYclass == group_A]
SF_Pitch_HYclass3 <- features$SF_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SF_Pitch <- wilcox.test(SF_Pitch_HYclass2, SF_Pitch_HYclass3)$p.value

```

```{r SF_Pitch_plot, echo=FALSE}

boxplot(SF_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "SF_Pitch",
        main = "Relative Power in Tremor band - Pitch", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r SF_Pitch_plot_no_outlier, echo=FALSE}

boxplot(SF_Pitch ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "SF_Pitch",
        outline = FALSE,
        main = "Relative Power in Tremor band - Pitch (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r SF_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SF_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SF_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SF_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SF_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Roll

```{r Mann-Whitney-U-test_SF_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
SF_Roll_HYclass2 <- features$SF_Roll[features$HYclass == group_A]
SF_Roll_HYclass3 <- features$SF_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SF_Roll <- wilcox.test(SF_Roll_HYclass2, SF_Roll_HYclass3)$p.value

```


```{r SF_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SF_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SF_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SF_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SF_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### Yaw

```{r Mann-Whitney-U-test_SF_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
SF_Yaw_HYclass2 <- features$SF_Yaw[features$HYclass == group_A]
SF_Yaw_HYclass3 <- features$SF_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$SF_Yaw <- wilcox.test(SF_Yaw_HYclass2, SF_Yaw_HYclass3)$p.value

```


```{r SF_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$SF_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$SF_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$SF_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$SF_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```



\newpage
## Fourier Spectral Energy Integrals

```{r four_spectal_integrals, echo = FALSE}
features$FSEI_0.1_2.4 <- NA
features$FSEI_2.4_3.5 <- NA
features$FSEI_3.8_8 <- NA
features$FSEI_11_19 <- NA

for(i in 1:nrow(features)) {
  # Frequency vectors - different sizes due to a few segments being trimmed as 
  # the pull tests were performed within two seconds.
  n1 <- length(pull_segments$AP_1[[i]])
  freq1 <- seq(0, n1/2-1, length.out = n1/2) * (50 / n1)  # sampling freq
  n2 <- length(pull_segments$AP_2[[i]])
  freq2 <- seq(0, n2/2-1, length.out = n2/2) * (50 / n2)  # sampling freq
  n3 <- length(pull_segments$AP_3[[i]])
  freq3 <- seq(0, n3/2-1, length.out = n3/2) * (50 / n3)  # sampling freq
  
  # perform the fft to transform into frequency domain
  fft_ap_1 <- fft(na.trim(pull_segments$AP_1[[i]], sides = "right")) 
  fft_ap_2 <- fft(na.trim(pull_segments$AP_2[[i]], sides = "right")) 
  fft_ap_3 <- fft(na.trim(pull_segments$AP_3[[i]], sides = "right")) 
  
  fft_ml_1 <- fft(na.trim(pull_segments$ML_1[[i]], sides = "right")) 
  fft_ml_2 <- fft(na.trim(pull_segments$ML_2[[i]], sides = "right")) 
  fft_ml_3 <- fft(na.trim(pull_segments$ML_3[[i]], sides = "right")) 
  
  fft_vt_1 <- fft(na.trim(pull_segments$VT_1[[i]], sides = "right")) 
  fft_vt_2 <- fft(na.trim(pull_segments$VT_2[[i]], sides = "right")) 
  fft_vt_3 <- fft(na.trim(pull_segments$VT_3[[i]], sides = "right")) 

  # Calculate PSD on real half of FFT
  psd_ap_1 <- Mod(fft_ap_1[1:(n1/2)])^2
  psd_ap_2 <- Mod(fft_ap_2[1:(n2/2)])^2
  psd_ap_3 <- Mod(fft_ap_3[1:(n3/2)])^2
  
  psd_ml_1 <- Mod(fft_ml_1[1:(n1/2)])^2
  psd_ml_2 <- Mod(fft_ml_2[1:(n2/2)])^2
  psd_ml_3 <- Mod(fft_ml_3[1:(n3/2)])^2
  
  psd_vt_1 <- Mod(fft_vt_1[1:(n1/2)])^2
  psd_vt_2 <- Mod(fft_vt_2[1:(n2/2)])^2
  psd_vt_3 <- Mod(fft_vt_3[1:(n3/2)])^2

  # Calculate power in 0.1 to 2.4 Hz
  FSEI_0.1_2.4_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 0.1, 2.4)
  FSEI_0.1_2.4_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 0.1, 2.4)
  FSEI_0.1_2.4_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 0.1, 2.4)
  
  FSEI_0.1_2.4_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 0.1, 2.4) 
  FSEI_0.1_2.4_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 0.1, 2.4)
  FSEI_0.1_2.4_ML_3 <-  sum_power_in_band(psd_ml_3, freq3, 0.1, 2.4)
  
  FSEI_0.1_2.4_VT_1 <- sum_power_in_band(psd_vt_1, freq1, 0.1, 2.4)
  FSEI_0.1_2.4_VT_2 <- sum_power_in_band(psd_vt_2, freq2, 0.1, 2.4)
  FSEI_0.1_2.4_VT_3 <-  sum_power_in_band(psd_vt_3, freq3, 0.1, 2.4)
  
  # Calculate power in 2.4 to 3.5 Hz
  FSEI_2.4_3.5_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 2.4, 3.5)
  FSEI_2.4_3.5_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 2.4, 3.5)
  FSEI_2.4_3.5_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 2.4, 3.5)
  
  FSEI_2.4_3.5_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 2.4, 3.5) 
  FSEI_2.4_3.5_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 2.4, 3.5)
  FSEI_2.4_3.5_ML_3 <-  sum_power_in_band(psd_ml_3, freq3, 2.4, 3.5)
  
  FSEI_2.4_3.5_VT_1 <- sum_power_in_band(psd_vt_1, freq1, 2.4, 3.5)
  FSEI_2.4_3.5_VT_2 <- sum_power_in_band(psd_vt_2, freq2, 2.4, 3.5)
  FSEI_2.4_3.5_VT_3 <-  sum_power_in_band(psd_vt_3, freq3, 2.4, 3.5)
  
  # Calculate power in 3.8 to 8 Hz
  FSEI_3.8_8_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 3.8, 8)
  FSEI_3.8_8_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 3.8, 8)
  FSEI_3.8_8_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 3.8, 8)
  
  FSEI_3.8_8_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 3.8, 8) 
  FSEI_3.8_8_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 3.8, 8)
  FSEI_3.8_8_ML_3 <-  sum_power_in_band(psd_ml_3, freq3, 3.8, 8)
  
  FSEI_3.8_8_VT_1 <- sum_power_in_band(psd_vt_1, freq1, 3.8, 8)
  FSEI_3.8_8_VT_2 <- sum_power_in_band(psd_vt_2, freq2, 3.8, 8)
  FSEI_3.8_8_VT_3 <-  sum_power_in_band(psd_vt_3, freq3, 3.8, 8)
  
  # Calculate power in 11 to 19 Hz
  FSEI_11_19_AP_1 <- sum_power_in_band(psd_ap_1, freq1, 11, 19)
  FSEI_11_19_AP_2 <- sum_power_in_band(psd_ap_2, freq2, 11, 19)
  FSEI_11_19_AP_3 <- sum_power_in_band(psd_ap_3, freq3, 11, 19)
  
  FSEI_11_19_ML_1 <- sum_power_in_band(psd_ml_1, freq1, 11, 19) 
  FSEI_11_19_ML_2 <- sum_power_in_band(psd_ml_2, freq2, 11, 19)
  FSEI_11_19_ML_3 <-  sum_power_in_band(psd_ml_3, freq3, 11, 19)
  
  FSEI_11_19_VT_1 <- sum_power_in_band(psd_vt_1, freq1, 11, 19)
  FSEI_11_19_VT_2 <- sum_power_in_band(psd_vt_2, freq2, 11, 19)
  FSEI_11_19_VT_3 <- sum_power_in_band(psd_vt_3, freq3, 11, 19)

  # Average for the three pulls, adding all three axis together
  features$FSEI_0.1_2.4[i] <- mean(c(FSEI_0.1_2.4_AP_1 + FSEI_0.1_2.4_ML_1 + FSEI_0.1_2.4_VT_1,
                           FSEI_0.1_2.4_AP_2 + FSEI_0.1_2.4_ML_2 + FSEI_0.1_2.4_VT_2,
                           FSEI_0.1_2.4_AP_3 + FSEI_0.1_2.4_ML_3 + FSEI_0.1_2.4_VT_3))
  
  features$FSEI_2.4_3.5[i] <- mean(c(FSEI_2.4_3.5_AP_1 + FSEI_2.4_3.5_ML_1 + FSEI_2.4_3.5_VT_1,
                           FSEI_2.4_3.5_AP_2 + FSEI_2.4_3.5_ML_2 + FSEI_2.4_3.5_VT_2,
                           FSEI_2.4_3.5_AP_3 + FSEI_2.4_3.5_ML_3 + FSEI_2.4_3.5_VT_3))
  
  features$FSEI_3.8_8[i] <- mean(c(FSEI_3.8_8_AP_1 + FSEI_3.8_8_ML_1 + FSEI_3.8_8_VT_1,
                           FSEI_3.8_8_AP_2 + FSEI_3.8_8_ML_2 + FSEI_3.8_8_VT_2,
                           FSEI_3.8_8_AP_3 + FSEI_3.8_8_ML_3 + FSEI_3.8_8_VT_3))
  
  features$FSEI_11_19[i] <- mean(c(FSEI_11_19_AP_1 + FSEI_11_19_ML_1 + FSEI_11_19_VT_1,
                           FSEI_11_19_AP_2 + FSEI_11_19_ML_2 + FSEI_11_19_VT_2,
                           FSEI_11_19_AP_3 + FSEI_11_19_ML_3 + FSEI_11_19_VT_3))
  
  # alternative but equal approach:
  # features$FSEI_0.1_2.4[i] <- mean(c(FSEI_0.1_2.4_AP_1, FSEI_0.1_2.4_AP_2, FSEI_0.1_2.4_AP_3)) +
  #   mean(c(FSEI_0.1_2.4_ML_1, FSEI_0.1_2.4_ML_2, FSEI_0.1_2.4_ML_3)) +
  #   mean(c(FSEI_0.1_2.4_VT_1, FSEI_0.1_2.4_VT_2, FSEI_0.1_2.4_VT_3))
}


```

### 0.1 - 2.4 Hz

```{r Mann-Whitney-U-test_FSEI_0.1_2.4, echo=FALSE}

# Extract values for HYclass 2 and 3
FSEI_0.1_2.4_HYclass2 <- features$FSEI_0.1_2.4[features$HYclass == group_A]
FSEI_0.1_2.4_HYclass3 <- features$FSEI_0.1_2.4[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$FSEI_0.1_2.4 <- 
  wilcox.test(FSEI_0.1_2.4_HYclass2, FSEI_0.1_2.4_HYclass3)$p.value

```

```{r FSEI_0.1_2.4_plot, echo=FALSE}

boxplot(FSEI_0.1_2.4 ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "FSEI_0.1_2.4",
        main = "Fourier Spectral Energy Integrals (0.1 - 2.4 Hz)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r FSEI_0.1_2.4_plot_no_outlier, echo=FALSE}

boxplot(FSEI_0.1_2.4 ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "FSEI_0.1_2.4",
        outline = FALSE,
        main = "Fourier Spectral Energy Integrals (0.1 - 2.4 Hz) (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r FSEI_0.1_2.4_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$FSEI_0.1_2.4, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$FSEI_0.1_2.4 %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$FSEI_0.1_2.4 <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$FSEI_0.1_2.4[feature_outliers$Subject == subject_num] <- 1
  }
}

```

### 2.4 - 3.5 Hz

```{r Mann-Whitney-U-test_FSEI_2.4_3.5, echo=FALSE}

# Extract values for HYclass 2 and 3
FSEI_2.4_3.5_HYclass2 <- features$FSEI_2.4_3.5[features$HYclass == group_A]
FSEI_2.4_3.5_HYclass3 <- features$FSEI_2.4_3.5[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$FSEI_2.4_3.5 <- 
  wilcox.test(FSEI_2.4_3.5_HYclass2, FSEI_2.4_3.5_HYclass3)$p.value

```

```{r FSEI_2.4_3.5_plot, echo=FALSE}

boxplot(FSEI_2.4_3.5 ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "FSEI_2.4_3.5",
        main = "Fourier Spectral Energy Integrals (2.4 - 3.5 Hz)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r FSEI_2.4_3.5_plot_no_outlier, echo=FALSE}

boxplot(FSEI_2.4_3.5 ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "FSEI_2.4_3.5",
        outline = FALSE,
        main = "Fourier Spectral Energy Integrals (2.4 - 3.5 Hz) (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r FSEI_2.4_3.5_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$FSEI_2.4_3.5, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$FSEI_2.4_3.5 %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$FSEI_2.4_3.5 <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$FSEI_2.4_3.5[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### 3.8 - 8 Hz

```{r Mann-Whitney-U-test_FSEI_3.8_8, echo=FALSE}

# Extract values for HYclass 2 and 3
FSEI_3.8_8_HYclass2 <- features$FSEI_3.8_8[features$HYclass == group_A]
FSEI_3.8_8_HYclass3 <- features$FSEI_3.8_8[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$FSEI_3.8_8 <- wilcox.test(FSEI_3.8_8_HYclass2, FSEI_3.8_8_HYclass3)$p.value

```

```{r FSEI_3.8_8_plot, echo=FALSE}

boxplot(FSEI_3.8_8 ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "FSEI_3.8_8",
        main = "Fourier Spectral Energy Integrals (3.8 - 8 Hz)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r FSEI_3.8_8_plot_no_outlier, echo=FALSE}

boxplot(FSEI_3.8_8 ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "FSEI_3.8_8",
        outline = FALSE,
        main = "Fourier Spectral Energy Integrals (3.8 - 8 Hz) (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r FSEI_3.8_8_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$FSEI_3.8_8, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$FSEI_3.8_8 %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$FSEI_3.8_8 <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$FSEI_3.8_8[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### 11 - 19 Hz

```{r Mann-Whitney-U-test_FSEI_11_19, echo=FALSE}

# Extract values for HYclass 2 and 3
FSEI_11_19_HYclass2 <- features$FSEI_11_19[features$HYclass == group_A]
FSEI_11_19_HYclass3 <- features$FSEI_11_19[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$FSEI_11_19 <- wilcox.test(FSEI_11_19_HYclass2, FSEI_11_19_HYclass3)$p.value

```

```{r FSEI_11_19_plot, echo=FALSE}

boxplot(FSEI_11_19 ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "FSEI_11_19",
        main = "Fourier Spectral Energy Integrals (11 - 19 Hz)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r FSEI_11_19_plot_no_outlier, echo=FALSE}

boxplot(FSEI_11_19 ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "FSEI_11_19",
        outline = FALSE,
        main = "Fourier Spectral Energy Integrals (11 - 19 Hz) (outliers removed)", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r FSEI_11_19_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$FSEI_11_19, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$FSEI_11_19 %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$FSEI_11_19 <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$FSEI_11_19[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Hilbert Spectrum amplitude Anteroposterior

```{r Hilbert_spectrum, echo = FALSE}
# this code chunk will take a lot of time, as the EMD takes time to do
features$HS_amp_min_AP <- NA
features$HS_amp_med_AP <- NA
features$HS_amp_3Q_AP <- NA
features$HS_amp_max_AP <- NA

for(i in 1:nrow(features)) {
  
  # perform Empirical Mode Decomposition (EMD) on the time series to obtain
  # the Intrinsic Mode Functions (IMFs)
  emd_ap_1 <- emd(na.trim(pull_segments$AP_1[[i]], sides = "right"))
  emd_ap_2 <- emd(na.trim(pull_segments$AP_2[[i]], sides = "right"))
  emd_ap_3 <- emd(na.trim(pull_segments$AP_3[[i]], sides = "right"))
  
  # perform the Hilbert transform on the IMFs
  hilbert_ap_1 <- hilbert(emd_ap_1$imf)
  hilbert_ap_2 <- hilbert(emd_ap_2$imf)
  hilbert_ap_3 <- hilbert(emd_ap_3$imf)
  
  # Calculate Instantaneous Amplitude
  instantaneous_amp_ap_1 <- Mod(hilbert_ap_1)
  instantaneous_amp_ap_2 <- Mod(hilbert_ap_2)
  instantaneous_amp_ap_3 <- Mod(hilbert_ap_3)
  
  # Calculate Instantaneous Phase
  instantaneous_phase_ap_1 <- atan2(Im(hilbert_ap_1), Re(hilbert_ap_1))
  instantaneous_phase_ap_2 <- atan2(Im(hilbert_ap_2), Re(hilbert_ap_2))
  instantaneous_phase_ap_3 <- atan2(Im(hilbert_ap_3), Re(hilbert_ap_3))
  
  # Calculate Instantaneous Frequency
  instantaneous_freq_ap_1 <- diff(instantaneous_phase_ap_1) / (2 * pi) * 50
  instantaneous_freq_ap_2 <- diff(instantaneous_phase_ap_2) / (2 * pi) * 50
  instantaneous_freq_ap_3 <- diff(instantaneous_phase_ap_3) / (2 * pi) * 50

  ################ CODE FOR PLOTTING TO CHECK HILBERT SPECTRUMS ################ 
  
  #   # create the time vector for each segment (add 1 to adjust the cut)
  #   time_vector_1 <- seq(1, length(instantaneous_freq_ap_1)/ncol(instantaneous_freq_ap_1)+1)
  # 
  #   # Plotting each IMF's frequency and amplitude
  # for (i in 1:ncol(hilbert_ap_1)) {
  #     plot(time_vector_1[-length(time_vector_1)], instantaneous_freq_ap_1[,i],
  #          type = 'l', col = i, xlab = 'Time', ylab = 'Frequency',
  #          main = 'Hilbert Spectrum')
  # }
  # 
  ############################################################################## 


  # Calculate statistics for amplitude NOT FREQUENCY as per previous investigation
  amp_stats_ap_1 <- apply(instantaneous_amp_ap_1, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  amp_stats_ap_2 <- apply(instantaneous_amp_ap_2, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  amp_stats_ap_3 <- apply(instantaneous_amp_ap_3, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  
  # Average for the three pulls, adding all three axis together
  features$HS_amp_min_AP[i] <- mean(c(mean(amp_stats_ap_1[1,]) + 
                                          mean(amp_stats_ap_2[1,]) + 
                                          mean(amp_stats_ap_3[1,])))
  features$HS_amp_med_AP[i] <- mean(c(mean(amp_stats_ap_1[2,]) + 
                                          mean(amp_stats_ap_2[2,]) + 
                                          mean(amp_stats_ap_3[2,])))
  features$HS_amp_3Q_AP[i] <- mean(c(mean(amp_stats_ap_1[3,]) + 
                                         mean(amp_stats_ap_2[3,]) + 
                                         mean(amp_stats_ap_3[3,])))
  features$HS_amp_max_AP[i] <- mean(c(mean(amp_stats_ap_1[4,]) + 
                                          mean(amp_stats_ap_2[4,]) + 
                                          mean(amp_stats_ap_3[4,])))
  
}


```

### Minimum

```{r Mann-Whitney-U-test_HS_min_AP, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_min_AP_HYclass2 <- features$HS_amp_min_AP[features$HYclass == group_A]
HS_amp_min_AP_HYclass3 <- features$HS_amp_min_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_min_AP <- wilcox.test(HS_amp_min_AP_HYclass2, HS_amp_min_AP_HYclass3)$p.value

```


```{r HS_min_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_min_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_min_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_min_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_min_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Median

```{r Mann-Whitney-U-test_HS_med_AP, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_med_AP_HYclass2 <- features$HS_amp_med_AP[features$HYclass == group_A]
HS_amp_med_AP_HYclass3 <- features$HS_amp_med_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_med_AP <- wilcox.test(HS_amp_med_AP_HYclass2, HS_amp_med_AP_HYclass3)$p.value

```


```{r HS_amp_med_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_med_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_med_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_med_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_med_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### 3rd Quartile

```{r Mann-Whitney-U-test_HS_3Q_AP, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_3Q_AP_HYclass2 <- features$HS_amp_3Q_AP[features$HYclass == group_A]
HS_amp_3Q_AP_HYclass3 <- features$HS_amp_3Q_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_3Q_AP <- wilcox.test(HS_amp_3Q_AP_HYclass2, HS_amp_3Q_AP_HYclass3)$p.value

```


```{r HS_3Q_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_3Q_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_3Q_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_3Q_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_3Q_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Maximum

```{r Mann-Whitney-U-test_HS_max_AP, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_max_AP_HYclass2 <- features$HS_amp_max_AP[features$HYclass == group_A]
HS_amp_max_AP_HYclass3 <- features$HS_amp_max_AP[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_max_AP <- wilcox.test(HS_amp_max_AP_HYclass2, HS_amp_max_AP_HYclass3)$p.value

```


```{r HS_amp_max_AP_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_max_AP, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_max_AP %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_max_AP <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_max_AP[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Hilbert Spectrum amplitude Mediolateral

```{r Hilbert_spectrum, echo = FALSE}
# this code chunk will take a lot of time, as the EMD takes time to do
features$HS_amp_min_ML <- NA
features$HS_amp_med_ML <- NA
features$HS_amp_3Q_ML <- NA
features$HS_amp_max_ML <- NA

for(i in 1:nrow(features)) {
  
  # perform Empirical Mode Decomposition (EMD) on the time series to obtain
  # the Intrinsic Mode Functions (IMFs)
  emd_ml_1 <- emd(na.trim(pull_segments$ML_1[[i]], sides = "right"))
  emd_ml_2 <- emd(na.trim(pull_segments$ML_2[[i]], sides = "right"))
  emd_ml_3 <- emd(na.trim(pull_segments$ML_3[[i]], sides = "right"))
  
  # perform the Hilbert transform on the IMFs
  hilbert_ml_1 <- hilbert(emd_ml_1$imf)
  hilbert_ml_2 <- hilbert(emd_ml_2$imf)
  hilbert_ml_3 <- hilbert(emd_ml_3$imf)
  
  # Calculate Instantaneous Amplitude
  instantaneous_amp_ml_1 <- Mod(hilbert_ml_1)
  instantaneous_amp_ml_2 <- Mod(hilbert_ml_2)
  instantaneous_amp_ml_3 <- Mod(hilbert_ml_3)
  
  # Calculate Instantaneous Phase
  instantaneous_phase_ml_1 <- atan2(Im(hilbert_ml_1), Re(hilbert_ml_1))
  instantaneous_phase_ml_2 <- atan2(Im(hilbert_ml_2), Re(hilbert_ml_2))
  instantaneous_phase_ml_3 <- atan2(Im(hilbert_ml_3), Re(hilbert_ml_3))
  
  # Calculate Instantaneous Frequency
  instantaneous_freq_ml_1 <- diff(instantaneous_phase_ml_1) / (2 * pi) * 50
  instantaneous_freq_ml_2 <- diff(instantaneous_phase_ml_2) / (2 * pi) * 50
  instantaneous_freq_ml_3 <- diff(instantaneous_phase_ml_3) / (2 * pi) * 50

  ################ CODE FOR PLOTTING TO CHECK HILBERT SPECTRUMS ################ 
  
  #   # create the time vector for each segment (add 1 to adjust the cut)
  #   time_vector_1 <- seq(1, length(instantaneous_freq_ml_1)/ncol(instantaneous_freq_ml_1)+1)
  # 
  #   # Plotting each IMF's frequency and amplitude
  # for (i in 1:ncol(hilbert_ml_1)) {
  #     plot(time_vector_1[-length(time_vector_1)], instantaneous_freq_ml_1[,i],
  #          type = 'l', col = i, xlab = 'Time', ylab = 'Frequency',
  #          main = 'Hilbert Spectrum')
  # }
  # 
  ############################################################################## 


  # Calculate statistics for amplitude NOT FREQUENCY as per previous investigation
  amp_stats_ml_1 <- apply(instantaneous_amp_ml_1, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  amp_stats_ml_2 <- apply(instantaneous_amp_ml_2, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  amp_stats_ml_3 <- apply(instantaneous_amp_ml_3, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  
  # Average for the three pulls, adding all three axis together
  features$HS_amp_min_ML[i] <- mean(c(mean(amp_stats_ml_1[1,]) + 
                                          mean(amp_stats_ml_2[1,]) + 
                                          mean(amp_stats_ml_3[1,])))
  features$HS_amp_med_ML[i] <- mean(c(mean(amp_stats_ml_1[2,]) + 
                                          mean(amp_stats_ml_2[2,]) + 
                                          mean(amp_stats_ml_3[2,])))
  features$HS_amp_3Q_ML[i] <- mean(c(mean(amp_stats_ml_1[3,]) + 
                                         mean(amp_stats_ml_2[3,]) + 
                                         mean(amp_stats_ml_3[3,])))
  features$HS_amp_max_ML[i] <- mean(c(mean(amp_stats_ml_1[4,]) + 
                                          mean(amp_stats_ml_2[4,]) + 
                                          mean(amp_stats_ml_3[4,])))
  
}


```

### Minimum

```{r Mann-Whitney-U-test_HS_min_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_min_ML_HYclass2 <- features$HS_amp_min_ML[features$HYclass == group_A]
HS_amp_min_ML_HYclass3 <- features$HS_amp_min_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_min_ML <- wilcox.test(HS_amp_min_ML_HYclass2, HS_amp_min_ML_HYclass3)$p.value

```


```{r HS_min_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_min_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_min_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_min_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_min_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Median

```{r Mann-Whitney-U-test_HS_med_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_med_ML_HYclass2 <- features$HS_amp_med_ML[features$HYclass == group_A]
HS_amp_med_ML_HYclass3 <- features$HS_amp_med_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_med_ML <- wilcox.test(HS_amp_med_ML_HYclass2, HS_amp_med_ML_HYclass3)$p.value

```


```{r HS_amp_med_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_med_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_med_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_med_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_med_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### 3rd Quartile

```{r Mann-Whitney-U-test_HS_3Q_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_3Q_ML_HYclass2 <- features$HS_amp_3Q_ML[features$HYclass == group_A]
HS_amp_3Q_ML_HYclass3 <- features$HS_amp_3Q_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_3Q_ML <- wilcox.test(HS_amp_3Q_ML_HYclass2, HS_amp_3Q_ML_HYclass3)$p.value

```


```{r HS_3Q_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_3Q_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_3Q_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_3Q_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_3Q_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Maximum

```{r Mann-Whitney-U-test_HS_max_ML, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_max_ML_HYclass2 <- features$HS_amp_max_ML[features$HYclass == group_A]
HS_amp_max_ML_HYclass3 <- features$HS_amp_max_ML[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_max_ML <- wilcox.test(HS_amp_max_ML_HYclass2, HS_amp_max_ML_HYclass3)$p.value

```


```{r HS_amp_max_ML_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_max_ML, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_max_ML %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_max_ML <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_max_ML[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Hilbert Spectrum amplitude Vertical

```{r Hilbert_spectrum, echo = FALSE}
# this code chunk will take a lot of time, as the EMD takes time to do
features$HS_amp_min_VT <- NA
features$HS_amp_med_VT <- NA
features$HS_amp_3Q_VT <- NA
features$HS_amp_max_VT <- NA

for(i in 1:nrow(features)) {
  
  # perform Empirical Mode Decomposition (EMD) on the time series to obtain
  # the Intrinsic Mode Functions (IMFs)
  emd_vt_1 <- emd(na.trim(pull_segments$VT_1[[i]], sides = "right"))
  emd_vt_2 <- emd(na.trim(pull_segments$VT_2[[i]], sides = "right"))
  emd_vt_3 <- emd(na.trim(pull_segments$VT_3[[i]], sides = "right"))
  
  # perform the Hilbert transform on the IMFs
  hilbert_vt_1 <- hilbert(emd_vt_1$imf)
  hilbert_vt_2 <- hilbert(emd_vt_2$imf)
  hilbert_vt_3 <- hilbert(emd_vt_3$imf)
  
  # Calculate Instantaneous Amplitude
  instantaneous_amp_vt_1 <- Mod(hilbert_vt_1)
  instantaneous_amp_vt_2 <- Mod(hilbert_vt_2)
  instantaneous_amp_vt_3 <- Mod(hilbert_vt_3)
  
  # Calculate Instantaneous Phase
  instantaneous_phase_vt_1 <- atan2(Im(hilbert_vt_1), Re(hilbert_vt_1))
  instantaneous_phase_vt_2 <- atan2(Im(hilbert_vt_2), Re(hilbert_vt_2))
  instantaneous_phase_vt_3 <- atan2(Im(hilbert_vt_3), Re(hilbert_vt_3))
  
  # Calculate Instantaneous Frequency
  instantaneous_freq_vt_1 <- diff(instantaneous_phase_vt_1) / (2 * pi) * 50
  instantaneous_freq_vt_2 <- diff(instantaneous_phase_vt_2) / (2 * pi) * 50
  instantaneous_freq_vt_3 <- diff(instantaneous_phase_vt_3) / (2 * pi) * 50

  ################ CODE FOR PLOTTING TO CHECK HILBERT SPECTRUMS ################ 
  
  #   # create the time vector for each segment (add 1 to adjust the cut)
  #   time_vector_1 <- seq(1, length(instantaneous_freq_vt_1)/ncol(instantaneous_freq_vt_1)+1)
  # 
  #   # Plotting each IMF's frequency and amplitude
  # for (i in 1:ncol(hilbert_vt_1)) {
  #     plot(time_vector_1[-length(time_vector_1)], instantaneous_freq_vt_1[,i],
  #          type = 'l', col = i, xlab = 'Time', ylab = 'Frequency',
  #          main = 'Hilbert Spectrum')
  # }
  # 
  ############################################################################## 


  # Calculate statistics for amplitude NOT FREQUENCY as per previous investigation
  amp_stats_vt_1 <- apply(instantaneous_amp_vt_1, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  amp_stats_vt_2 <- apply(instantaneous_amp_vt_2, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  amp_stats_vt_3 <- apply(instantaneous_amp_vt_3, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  
  # Average for the three pulls, adding all three axis together
  features$HS_amp_min_VT[i] <- mean(c(mean(amp_stats_vt_1[1,]) + 
                                          mean(amp_stats_vt_2[1,]) + 
                                          mean(amp_stats_vt_3[1,])))
  features$HS_amp_med_VT[i] <- mean(c(mean(amp_stats_vt_1[2,]) + 
                                          mean(amp_stats_vt_2[2,]) + 
                                          mean(amp_stats_vt_3[2,])))
  features$HS_amp_3Q_VT[i] <- mean(c(mean(amp_stats_vt_1[3,]) + 
                                         mean(amp_stats_vt_2[3,]) + 
                                         mean(amp_stats_vt_3[3,])))
  features$HS_amp_max_VT[i] <- mean(c(mean(amp_stats_vt_1[4,]) + 
                                          mean(amp_stats_vt_2[4,]) + 
                                          mean(amp_stats_vt_3[4,])))
  
}


```

### Minimum

```{r Mann-Whitney-U-test_HS_min_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_min_VT_HYclass2 <- features$HS_amp_min_VT[features$HYclass == group_A]
HS_amp_min_VT_HYclass3 <- features$HS_amp_min_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_min_VT <- wilcox.test(HS_amp_min_VT_HYclass2, HS_amp_min_VT_HYclass3)$p.value

```


```{r HS_min_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_min_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_min_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_min_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_min_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Median

```{r Mann-Whitney-U-test_HS_med_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_med_VT_HYclass2 <- features$HS_amp_med_VT[features$HYclass == group_A]
HS_amp_med_VT_HYclass3 <- features$HS_amp_med_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_med_VT <- wilcox.test(HS_amp_med_VT_HYclass2, HS_amp_med_VT_HYclass3)$p.value

```


```{r HS_amp_med_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_med_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_med_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_med_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_med_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### 3rd Quartile

```{r Mann-Whitney-U-test_HS_3Q_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_3Q_VT_HYclass2 <- features$HS_amp_3Q_VT[features$HYclass == group_A]
HS_amp_3Q_VT_HYclass3 <- features$HS_amp_3Q_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_3Q_VT <- wilcox.test(HS_amp_3Q_VT_HYclass2, HS_amp_3Q_VT_HYclass3)$p.value

```


```{r HS_3Q_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_3Q_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_3Q_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_3Q_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_3Q_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Maximum

```{r Mann-Whitney-U-test_HS_max_VT, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_max_VT_HYclass2 <- features$HS_amp_max_VT[features$HYclass == group_A]
HS_amp_max_VT_HYclass3 <- features$HS_amp_max_VT[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_max_VT <- wilcox.test(HS_amp_max_VT_HYclass2, HS_amp_max_VT_HYclass3)$p.value

```


```{r HS_amp_max_VT_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_max_VT, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_max_VT %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_max_VT <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_max_VT[feature_outliers$Subject == subject_num] <- 1
  }
}

```


\newpage
## Hilbert Spectrum amplitude Pitch

```{r Hilbert_spectrum, echo = FALSE}
# this code chunk will take a lot of time, as the EMD takes time to do
features$HS_amp_min_Pitch <- NA
features$HS_amp_med_Pitch <- NA
features$HS_amp_3Q_Pitch <- NA
features$HS_amp_max_Pitch <- NA

for(i in 1:nrow(features)) {
  
  # perform Empirical Mode Decomposition (EMD) on the time series to obtain
  # the Intrinsic Mode Functions (IMFs)
  emd_pi_1 <- emd(na.trim(pull_segments$Pitch_1[[i]], sides = "right"))
  emd_pi_2 <- emd(na.trim(pull_segments$Pitch_2[[i]], sides = "right"))
  emd_pi_3 <- emd(na.trim(pull_segments$Pitch_3[[i]], sides = "right"))
  
  # perform the Hilbert transform on the IMFs
  hilbert_pi_1 <- hilbert(emd_pi_1$imf)
  hilbert_pi_2 <- hilbert(emd_pi_2$imf)
  hilbert_pi_3 <- hilbert(emd_pi_3$imf)
  
  # Calculate Instantaneous Amplitude
  instantaneous_amp_pi_1 <- Mod(hilbert_pi_1)
  instantaneous_amp_pi_2 <- Mod(hilbert_pi_2)
  instantaneous_amp_pi_3 <- Mod(hilbert_pi_3)
  
  # Calculate Instantaneous Phase
  instantaneous_phase_pi_1 <- atan2(Im(hilbert_pi_1), Re(hilbert_pi_1))
  instantaneous_phase_pi_2 <- atan2(Im(hilbert_pi_2), Re(hilbert_pi_2))
  instantaneous_phase_pi_3 <- atan2(Im(hilbert_pi_3), Re(hilbert_pi_3))
  
  # Calculate Instantaneous Frequency
  instantaneous_freq_pi_1 <- diff(instantaneous_phase_pi_1) / (2 * pi) * 50
  instantaneous_freq_pi_2 <- diff(instantaneous_phase_pi_2) / (2 * pi) * 50
  instantaneous_freq_pi_3 <- diff(instantaneous_phase_pi_3) / (2 * pi) * 50

  ################ CODE FOR PLOTTING TO CHECK HILBERT SPECTRUMS ################ 
  
  #   # create the time vector for each segment (add 1 to adjust the cut)
  #   time_vector_1 <- seq(1, length(instantaneous_freq_pi_1)/ncol(instantaneous_freq_pi_1)+1)
  # 
  #   # Plotting each IMF's frequency and amplitude
  # for (i in 1:ncol(hilbert_pi_1)) {
  #     plot(time_vector_1[-length(time_vector_1)], instantaneous_freq_pi_1[,i],
  #          type = 'l', col = i, xlab = 'Time', ylab = 'Frequency',
  #          main = 'Hilbert Spectrum')
  # }
  # 
  ############################################################################## 


  # Calculate statistics for amplitude NOT FREQUENCY as per previous investigation
  amp_stats_pi_1 <- apply(instantaneous_amp_pi_1, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  amp_stats_pi_2 <- apply(instantaneous_amp_pi_2, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  amp_stats_pi_3 <- apply(instantaneous_amp_pi_3, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  
  # Average for the three pulls, adding all three axis together
  features$HS_amp_min_Pitch[i] <- mean(c(mean(amp_stats_pi_1[1,]) + 
                                          mean(amp_stats_pi_2[1,]) + 
                                          mean(amp_stats_pi_3[1,])))
  features$HS_amp_med_Pitch[i] <- mean(c(mean(amp_stats_pi_1[2,]) + 
                                          mean(amp_stats_pi_2[2,]) + 
                                          mean(amp_stats_pi_3[2,])))
  features$HS_amp_3Q_Pitch[i] <- mean(c(mean(amp_stats_pi_1[3,]) + 
                                         mean(amp_stats_pi_2[3,]) + 
                                         mean(amp_stats_pi_3[3,])))
  features$HS_amp_max_Pitch[i] <- mean(c(mean(amp_stats_pi_1[4,]) + 
                                          mean(amp_stats_pi_2[4,]) + 
                                          mean(amp_stats_pi_3[4,])))
  
}


```

### Minimum

```{r Mann-Whitney-U-test_HS_min_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_min_Pitch_HYclass2 <- features$HS_amp_min_Pitch[features$HYclass == group_A]
HS_amp_min_Pitch_HYclass3 <- features$HS_amp_min_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_min_Pitch <- wilcox.test(HS_amp_min_Pitch_HYclass2, HS_amp_min_Pitch_HYclass3)$p.value

```


```{r HS_min_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_min_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_min_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_min_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_min_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Median

```{r Mann-Whitney-U-test_HS_med_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_med_Pitch_HYclass2 <- features$HS_amp_med_Pitch[features$HYclass == group_A]
HS_amp_med_Pitch_HYclass3 <- features$HS_amp_med_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_med_Pitch <- wilcox.test(HS_amp_med_Pitch_HYclass2, HS_amp_med_Pitch_HYclass3)$p.value

```


```{r HS_amp_med_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_med_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_med_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_med_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_med_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### 3rd Quartile

```{r Mann-Whitney-U-test_HS_3Q_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_3Q_Pitch_HYclass2 <- features$HS_amp_3Q_Pitch[features$HYclass == group_A]
HS_amp_3Q_Pitch_HYclass3 <- features$HS_amp_3Q_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_3Q_Pitch <- wilcox.test(HS_amp_3Q_Pitch_HYclass2, HS_amp_3Q_Pitch_HYclass3)$p.value

```


```{r HS_3Q_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_3Q_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_3Q_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_3Q_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_3Q_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Maximum

```{r Mann-Whitney-U-test_HS_max_Pitch, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_max_Pitch_HYclass2 <- features$HS_amp_max_Pitch[features$HYclass == group_A]
HS_amp_max_Pitch_HYclass3 <- features$HS_amp_max_Pitch[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_max_Pitch <- wilcox.test(HS_amp_max_Pitch_HYclass2, HS_amp_max_Pitch_HYclass3)$p.value

```


```{r HS_amp_max_Pitch_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_max_Pitch, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_max_Pitch %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_max_Pitch <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_max_Pitch[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Hilbert Spectrum amplitude Roll

```{r Hilbert_spectrum, echo = FALSE}
# this code chunk will take a lot of time, as the EMD takes time to do
features$HS_amp_min_Roll <- NA
features$HS_amp_med_Roll <- NA
features$HS_amp_3Q_Roll <- NA
features$HS_amp_max_Roll <- NA

for(i in 1:nrow(features)) {
  
  # perform Empirical Mode Decomposition (EMD) on the time series to obtain
  # the Intrinsic Mode Functions (IMFs)
  emd_ro_1 <- emd(na.trim(pull_segments$Roll_1[[i]], sides = "right"))
  emd_ro_2 <- emd(na.trim(pull_segments$Roll_2[[i]], sides = "right"))
  emd_ro_3 <- emd(na.trim(pull_segments$Roll_3[[i]], sides = "right"))
  
  # perform the Hilbert transform on the IMFs
  hilbert_ro_1 <- hilbert(emd_ro_1$imf)
  hilbert_ro_2 <- hilbert(emd_ro_2$imf)
  hilbert_ro_3 <- hilbert(emd_ro_3$imf)
  
  # Calculate Instantaneous Amplitude
  instantaneous_amp_ro_1 <- Mod(hilbert_ro_1)
  instantaneous_amp_ro_2 <- Mod(hilbert_ro_2)
  instantaneous_amp_ro_3 <- Mod(hilbert_ro_3)
  
  # Calculate Instantaneous Phase
  instantaneous_phase_ro_1 <- atan2(Im(hilbert_ro_1), Re(hilbert_ro_1))
  instantaneous_phase_ro_2 <- atan2(Im(hilbert_ro_2), Re(hilbert_ro_2))
  instantaneous_phase_ro_3 <- atan2(Im(hilbert_ro_3), Re(hilbert_ro_3))
  
  # Calculate Instantaneous Frequency
  instantaneous_freq_ro_1 <- diff(instantaneous_phase_ro_1) / (2 * pi) * 50
  instantaneous_freq_ro_2 <- diff(instantaneous_phase_ro_2) / (2 * pi) * 50
  instantaneous_freq_ro_3 <- diff(instantaneous_phase_ro_3) / (2 * pi) * 50

  ################ CODE FOR PLOTTING TO CHECK HILBERT SPECTRUMS ################ 
  
  #   # create the time vector for each segment (add 1 to adjust the cut)
  #   time_vector_1 <- seq(1, length(instantaneous_freq_ro_1)/ncol(instantaneous_freq_ro_1)+1)
  # 
  #   # Plotting each IMF's frequency and amplitude
  # for (i in 1:ncol(hilbert_ro_1)) {
  #     plot(time_vector_1[-length(time_vector_1)], instantaneous_freq_ro_1[,i],
  #          type = 'l', col = i, xlab = 'Time', ylab = 'Frequency',
  #          main = 'Hilbert Spectrum')
  # }
  # 
  ############################################################################## 


  # Calculate statistics for amplitude NOT FREQUENCY as per previous investigation
  amp_stats_ro_1 <- apply(instantaneous_amp_ro_1, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  amp_stats_ro_2 <- apply(instantaneous_amp_ro_2, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  amp_stats_ro_3 <- apply(instantaneous_amp_ro_3, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  
  # Average for the three pulls, adding all three axis together
  features$HS_amp_min_Roll[i] <- mean(c(mean(amp_stats_ro_1[1,]) + 
                                          mean(amp_stats_ro_2[1,]) + 
                                          mean(amp_stats_ro_3[1,])))
  features$HS_amp_med_Roll[i] <- mean(c(mean(amp_stats_ro_1[2,]) + 
                                          mean(amp_stats_ro_2[2,]) + 
                                          mean(amp_stats_ro_3[2,])))
  features$HS_amp_3Q_Roll[i] <- mean(c(mean(amp_stats_ro_1[3,]) + 
                                         mean(amp_stats_ro_2[3,]) + 
                                         mean(amp_stats_ro_3[3,])))
  features$HS_amp_max_Roll[i] <- mean(c(mean(amp_stats_ro_1[4,]) + 
                                          mean(amp_stats_ro_2[4,]) + 
                                          mean(amp_stats_ro_3[4,])))
  
}


```

### Minimum

```{r Mann-Whitney-U-test_HS_min_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_min_Roll_HYclass2 <- features$HS_amp_min_Roll[features$HYclass == group_A]
HS_amp_min_Roll_HYclass3 <- features$HS_amp_min_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_min_Roll <- wilcox.test(HS_amp_min_Roll_HYclass2, HS_amp_min_Roll_HYclass3)$p.value

```

```{r HS_min_Roll_plot, echo=FALSE}

boxplot(HS_amp_min_Roll ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "HS_min_Roll",
        main = "Hilbert Spectrum Amplitude Minimum - Roll", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r HS_min_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_min_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_min_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_min_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_min_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Median

```{r Mann-Whitney-U-test_HS_med_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_med_Roll_HYclass2 <- features$HS_amp_med_Roll[features$HYclass == group_A]
HS_amp_med_Roll_HYclass3 <- features$HS_amp_med_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_med_Roll <- wilcox.test(HS_amp_med_Roll_HYclass2, HS_amp_med_Roll_HYclass3)$p.value

```

```{r HS_med_Roll_plot, echo=FALSE}

boxplot(HS_amp_med_Roll ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "HS_med_Roll",
        main = "Hilbert Spectrum Amplitude Median - Roll", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r HS_amp_med_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_med_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_med_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_med_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_med_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### 3rd Quartile

```{r Mann-Whitney-U-test_HS_3Q_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_3Q_Roll_HYclass2 <- features$HS_amp_3Q_Roll[features$HYclass == group_A]
HS_amp_3Q_Roll_HYclass3 <- features$HS_amp_3Q_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_3Q_Roll <- wilcox.test(HS_amp_3Q_Roll_HYclass2, HS_amp_3Q_Roll_HYclass3)$p.value

```

```{r HS_3Q_Roll_plot, echo=FALSE}

boxplot(HS_amp_3Q_Roll ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "HS_3Q_Roll",
        main = "Hilbert Spectrum Amplitude 3rd Quartile - Roll", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r HS_3Q_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_3Q_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_3Q_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_3Q_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_3Q_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Maximum

```{r Mann-Whitney-U-test_HS_max_Roll, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_max_Roll_HYclass2 <- features$HS_amp_max_Roll[features$HYclass == group_A]
HS_amp_max_Roll_HYclass3 <- features$HS_amp_max_Roll[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_max_Roll <- wilcox.test(HS_amp_max_Roll_HYclass2, HS_amp_max_Roll_HYclass3)$p.value

```

```{r HS_max_Roll_plot, echo=FALSE}

boxplot(HS_amp_max_Roll ~ HYclass, data = features, 
        xlab = "HYclass", 
        ylab = "HS_max_Roll",
        main = "Hilbert Spectrum Amplitude Maximum - Roll", 
        col = c("lightblue", "lightgreen", "lightyellow", "lightpink"))

```

```{r HS_amp_max_Roll_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_max_Roll, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_max_Roll %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_max_Roll <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_max_Roll[feature_outliers$Subject == subject_num] <- 1
  }
}

```

\newpage
## Hilbert Spectrum amplitude Yaw

```{r Hilbert_spectrum, echo = FALSE}
# this code chunk will take a lot of time, as the EMD takes time to do
features$HS_amp_min_Yaw <- NA
features$HS_amp_med_Yaw <- NA
features$HS_amp_3Q_Yaw <- NA
features$HS_amp_max_Yaw <- NA

for(i in 1:nrow(features)) {
  
  # perform Empirical Mode Decomposition (EMD) on the time series to obtain
  # the Intrinsic Mode Functions (IMFs)
  emd_ya_1 <- emd(na.trim(pull_segments$Yaw_1[[i]], sides = "right"))
  emd_ya_2 <- emd(na.trim(pull_segments$Yaw_2[[i]], sides = "right"))
  emd_ya_3 <- emd(na.trim(pull_segments$Yaw_3[[i]], sides = "right"))
  
  # perform the Hilbert transform on the IMFs
  hilbert_ya_1 <- hilbert(emd_ya_1$imf)
  hilbert_ya_2 <- hilbert(emd_ya_2$imf)
  hilbert_ya_3 <- hilbert(emd_ya_3$imf)
  
  # Calculate Instantaneous Amplitude
  instantaneous_amp_ya_1 <- Mod(hilbert_ya_1)
  instantaneous_amp_ya_2 <- Mod(hilbert_ya_2)
  instantaneous_amp_ya_3 <- Mod(hilbert_ya_3)
  
  # Calculate Instantaneous Phase
  instantaneous_phase_ya_1 <- atan2(Im(hilbert_ya_1), Re(hilbert_ya_1))
  instantaneous_phase_ya_2 <- atan2(Im(hilbert_ya_2), Re(hilbert_ya_2))
  instantaneous_phase_ya_3 <- atan2(Im(hilbert_ya_3), Re(hilbert_ya_3))
  
  # Calculate Instantaneous Frequency
  instantaneous_freq_ya_1 <- diff(instantaneous_phase_ya_1) / (2 * pi) * 50
  instantaneous_freq_ya_2 <- diff(instantaneous_phase_ya_2) / (2 * pi) * 50
  instantaneous_freq_ya_3 <- diff(instantaneous_phase_ya_3) / (2 * pi) * 50

  ################ CODE FOR PLOTTING TO CHECK HILBERT SPECTRUMS ################ 
  
  #   # create the time vector for each segment (add 1 to adjust the cut)
  #   time_vector_1 <- seq(1, length(instantaneous_freq_ya_1)/ncol(instantaneous_freq_ya_1)+1)
  # 
  #   # Plotting each IMF's frequency and amplitude
  # for (i in 1:ncol(hilbert_ya_1)) {
  #     plot(time_vector_1[-length(time_vector_1)], instantaneous_freq_ya_1[,i],
  #          type = 'l', col = i, xlab = 'Time', ylab = 'Frequency',
  #          main = 'Hilbert Spectrum')
  # }
  # 
  ############################################################################## 


  # Calculate statistics for amplitude NOT FREQUENCY as per previous investigation
  amp_stats_ya_1 <- apply(instantaneous_amp_ya_1, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  amp_stats_ya_2 <- apply(instantaneous_amp_ya_2, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  amp_stats_ya_3 <- apply(instantaneous_amp_ya_3, 2, function(x) {
    c(min = min(x), median = median(x), q3 = quantile(x, 0.75), max = max(x))
  })
  
  # Average for the three pulls, adding all three axis together
  features$HS_amp_min_Yaw[i] <- mean(c(mean(amp_stats_ya_1[1,]) + 
                                          mean(amp_stats_ya_2[1,]) + 
                                          mean(amp_stats_ya_3[1,])))
  features$HS_amp_med_Yaw[i] <- mean(c(mean(amp_stats_ya_1[2,]) + 
                                          mean(amp_stats_ya_2[2,]) + 
                                          mean(amp_stats_ya_3[2,])))
  features$HS_amp_3Q_Yaw[i] <- mean(c(mean(amp_stats_ya_1[3,]) + 
                                         mean(amp_stats_ya_2[3,]) + 
                                         mean(amp_stats_ya_3[3,])))
  features$HS_amp_max_Yaw[i] <- mean(c(mean(amp_stats_ya_1[4,]) + 
                                          mean(amp_stats_ya_2[4,]) + 
                                          mean(amp_stats_ya_3[4,])))
  
}


```

### Minimum

```{r Mann-Whitney-U-test_HS_min_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_min_Yaw_HYclass2 <- features$HS_amp_min_Yaw[features$HYclass == group_A]
HS_amp_min_Yaw_HYclass3 <- features$HS_amp_min_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_min_Yaw <- wilcox.test(HS_amp_min_Yaw_HYclass2, HS_amp_min_Yaw_HYclass3)$p.value

```


```{r HS_min_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_min_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_min_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_min_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_min_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Median

```{r Mann-Whitney-U-test_HS_med_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_med_Yaw_HYclass2 <- features$HS_amp_med_Yaw[features$HYclass == group_A]
HS_amp_med_Yaw_HYclass3 <- features$HS_amp_med_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_med_Yaw <- wilcox.test(HS_amp_med_Yaw_HYclass2, HS_amp_med_Yaw_HYclass3)$p.value

```


```{r HS_amp_med_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_med_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_med_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_med_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_med_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### 3rd Quartile

```{r Mann-Whitney-U-test_HS_3Q_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_3Q_Yaw_HYclass2 <- features$HS_amp_3Q_Yaw[features$HYclass == group_A]
HS_amp_3Q_Yaw_HYclass3 <- features$HS_amp_3Q_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_3Q_Yaw <- wilcox.test(HS_amp_3Q_Yaw_HYclass2, HS_amp_3Q_Yaw_HYclass3)$p.value

```


```{r HS_3Q_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_3Q_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_3Q_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_3Q_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_3Q_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


### Maximum

```{r Mann-Whitney-U-test_HS_max_Yaw, echo=FALSE}

# Extract values for HYclass 2 and 3
HS_amp_max_Yaw_HYclass2 <- features$HS_amp_max_Yaw[features$HYclass == group_A]
HS_amp_max_Yaw_HYclass3 <- features$HS_amp_max_Yaw[features$HYclass == group_B]

# Perform the Mann-Whitney U test / wilcoxon rank sum test
p_values$HS_amp_max_Yaw <- wilcox.test(HS_amp_max_Yaw_HYclass2, HS_amp_max_Yaw_HYclass3)$p.value

```


```{r HS_amp_max_Yaw_outliers, echo=FALSE}

# split the data into lists based on 'HYclass'
split_data <- split(features$HS_amp_max_Yaw, features$HYclass)

outlier_subjects <- list()

# identify outliers, and map them to subject numbers
for (i in unique(features$HYclass)) {
  # boxplot.stats
  outliers <- boxplot.stats(split_data[[as.character(i)]])$out

  # Find the indices of the outliers
  outlier_indices <- which(features$HS_amp_max_Yaw %in% outliers & features$HYclass == i)

  # get the corresponding subject numbers
  outlier_subjects[[as.character(i)]] <- features$Subject[outlier_indices]
}

# now add these to the list of outliers
feature_outliers$HS_amp_max_Yaw <- 0

for (i in names(outlier_subjects)) {
  # Get the list of outlier subjects for the current HYclass
  current_outliers <- outlier_subjects[[i]]

  # Iterate over each subject number in the list
  for (subject_num in current_outliers) {
    # Find the corresponding row in feature_outliers and set to 1
    feature_outliers$HS_amp_max_Yaw[feature_outliers$Subject == subject_num] <- 1
  }
}

```


## Export all items to csv

```{r features_to_csv, echo = FALSE}

#features
write.csv(features, file = "features.csv", row.names = FALSE)

#p_values
write.csv(p_values, file = "p_values.csv", row.names = FALSE)

#feature_outliers
write.csv(feature_outliers, 
          file = "feature_outliers.csv", 
          row.names = FALSE)


```

## Print all p-values

```{r p_value_print, echo = FALSE}
for (col_name in colnames(p_values)) {
  # get the p-value
  p_val <- p_values[[col_name]][1]

  # Check if p_val is NA
  if (is.na(p_val)) {
    significance = " _Data Missing_"
  } else {
    # Determine the significance level
    if (p_val < 0.0001) {
      significance = "***"
    } else if (p_val < 0.001) {
      significance = "**"
    } else if (p_val < 0.01) {
      significance = "*"
    } else if (p_val < 0.05) {
      significance = "-"
    } else {
      significance = " _Not Significant_"
    }
  }

  # Print the p-value with significance symbol
  cat(col_name, ":", p_val, significance, "\n")
}


```


